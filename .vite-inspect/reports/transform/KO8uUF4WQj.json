{
  "resolvedId": "C:/Users/ryan.wong/Desktop/dev/TourneyPro_v2/node_modules/.vite/deps/chunk-PA33DROR.js?v=3c106fdb",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "import {\n  TransitionGroup_default\n} from \"./chunk-ZFUPPDSN.js\";\nimport {\n  init_useEventCallback,\n  useEventCallback_default\n} from \"./chunk-LKP4EHGH.js\";\nimport {\n  init_useIsFocusVisible,\n  useIsFocusVisible_default\n} from \"./chunk-KUYV4CAE.js\";\nimport {\n  init_useForkRef,\n  useForkRef_default\n} from \"./chunk-23AETIBN.js\";\nimport {\n  init_composeClasses\n} from \"./chunk-NEVWHIAS.js\";\nimport {\n  _objectWithoutPropertiesLoose,\n  clsx_default,\n  composeClasses,\n  elementTypeAcceptingRef_default,\n  generateUtilityClass,\n  generateUtilityClasses,\n  init_clsx,\n  init_esm,\n  init_esm2,\n  init_generateUtilityClass,\n  init_objectWithoutPropertiesLoose,\n  init_styled,\n  init_useThemeProps,\n  refType_default,\n  require_prop_types,\n  styled_default,\n  useThemeProps2 as useThemeProps\n} from \"./chunk-6ZT6S2Z7.js\";\nimport {\n  require_jsx_runtime\n} from \"./chunk-U73TBONF.js\";\nimport {\n  keyframes\n} from \"./chunk-6XVPP5RS.js\";\nimport {\n  _extends,\n  init_extends\n} from \"./chunk-HMTWVGVS.js\";\nimport {\n  require_react\n} from \"./chunk-ZGRSIX2Q.js\";\nimport {\n  __toESM\n} from \"./chunk-ROME4SDB.js\";\n\n// node_modules/@mui/material/ButtonBase/touchRippleClasses.js\ninit_esm();\ninit_generateUtilityClass();\nfunction getTouchRippleUtilityClass(slot) {\n  return generateUtilityClass(\"MuiTouchRipple\", slot);\n}\nvar touchRippleClasses = generateUtilityClasses(\"MuiTouchRipple\", [\"root\", \"ripple\", \"rippleVisible\", \"ripplePulsate\", \"child\", \"childLeaving\", \"childPulsate\"]);\nvar touchRippleClasses_default = touchRippleClasses;\n\n// node_modules/@mui/material/ButtonBase/buttonBaseClasses.js\ninit_esm();\ninit_generateUtilityClass();\nfunction getButtonBaseUtilityClass(slot) {\n  return generateUtilityClass(\"MuiButtonBase\", slot);\n}\nvar buttonBaseClasses = generateUtilityClasses(\"MuiButtonBase\", [\"root\", \"disabled\", \"focusVisible\"]);\nvar buttonBaseClasses_default = buttonBaseClasses;\n\n// node_modules/@mui/material/ButtonBase/ButtonBase.js\ninit_extends();\ninit_objectWithoutPropertiesLoose();\nvar React3 = __toESM(require_react());\nvar import_prop_types3 = __toESM(require_prop_types());\ninit_clsx();\ninit_esm();\ninit_composeClasses();\ninit_styled();\ninit_useThemeProps();\ninit_useForkRef();\ninit_useEventCallback();\ninit_useIsFocusVisible();\n\n// node_modules/@mui/material/ButtonBase/TouchRipple.js\ninit_extends();\ninit_objectWithoutPropertiesLoose();\nvar React2 = __toESM(require_react());\nvar import_prop_types2 = __toESM(require_prop_types());\ninit_clsx();\ninit_esm2();\ninit_styled();\ninit_useThemeProps();\n\n// node_modules/@mui/material/ButtonBase/Ripple.js\nvar React = __toESM(require_react());\nvar import_prop_types = __toESM(require_prop_types());\ninit_clsx();\nvar import_jsx_runtime = __toESM(require_jsx_runtime());\nfunction Ripple(props) {\n  const {\n    className,\n    classes,\n    pulsate = false,\n    rippleX,\n    rippleY,\n    rippleSize,\n    in: inProp,\n    onExited,\n    timeout\n  } = props;\n  const [leaving, setLeaving] = React.useState(false);\n  const rippleClassName = clsx_default(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);\n  const rippleStyles = {\n    width: rippleSize,\n    height: rippleSize,\n    top: -(rippleSize / 2) + rippleY,\n    left: -(rippleSize / 2) + rippleX\n  };\n  const childClassName = clsx_default(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);\n  if (!inProp && !leaving) {\n    setLeaving(true);\n  }\n  React.useEffect(() => {\n    if (!inProp && onExited != null) {\n      const timeoutId = setTimeout(onExited, timeout);\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n    return void 0;\n  }, [onExited, inProp, timeout]);\n  return (0, import_jsx_runtime.jsx)(\"span\", {\n    className: rippleClassName,\n    style: rippleStyles,\n    children: (0, import_jsx_runtime.jsx)(\"span\", {\n      className: childClassName\n    })\n  });\n}\ntrue ? Ripple.propTypes = {\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: import_prop_types.default.object.isRequired,\n  className: import_prop_types.default.string,\n  /**\n   * @ignore - injected from TransitionGroup\n   */\n  in: import_prop_types.default.bool,\n  /**\n   * @ignore - injected from TransitionGroup\n   */\n  onExited: import_prop_types.default.func,\n  /**\n   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.\n   */\n  pulsate: import_prop_types.default.bool,\n  /**\n   * Diameter of the ripple.\n   */\n  rippleSize: import_prop_types.default.number,\n  /**\n   * Horizontal position of the ripple center.\n   */\n  rippleX: import_prop_types.default.number,\n  /**\n   * Vertical position of the ripple center.\n   */\n  rippleY: import_prop_types.default.number,\n  /**\n   * exit delay\n   */\n  timeout: import_prop_types.default.number.isRequired\n} : void 0;\nvar Ripple_default = Ripple;\n\n// node_modules/@mui/material/ButtonBase/TouchRipple.js\nvar import_jsx_runtime2 = __toESM(require_jsx_runtime());\nvar _excluded = [\"center\", \"classes\", \"className\"];\nvar _ = (t) => t;\nvar _t;\nvar _t2;\nvar _t3;\nvar _t4;\nvar DURATION = 550;\nvar DELAY_RIPPLE = 80;\nvar enterKeyframe = keyframes(_t || (_t = _`\n  0% {\n    transform: scale(0);\n    opacity: 0.1;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 0.3;\n  }\n`));\nvar exitKeyframe = keyframes(_t2 || (_t2 = _`\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`));\nvar pulsateKeyframe = keyframes(_t3 || (_t3 = _`\n  0% {\n    transform: scale(1);\n  }\n\n  50% {\n    transform: scale(0.92);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n`));\nvar TouchRippleRoot = styled_default(\"span\", {\n  name: \"MuiTouchRipple\",\n  slot: \"Root\"\n})({\n  overflow: \"hidden\",\n  pointerEvents: \"none\",\n  position: \"absolute\",\n  zIndex: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  borderRadius: \"inherit\"\n});\nvar TouchRippleRipple = styled_default(Ripple_default, {\n  name: \"MuiTouchRipple\",\n  slot: \"Ripple\"\n})(_t4 || (_t4 = _`\n  opacity: 0;\n  position: absolute;\n\n  &.${0} {\n    opacity: 0.3;\n    transform: scale(1);\n    animation-name: ${0};\n    animation-duration: ${0}ms;\n    animation-timing-function: ${0};\n  }\n\n  &.${0} {\n    animation-duration: ${0}ms;\n  }\n\n  & .${0} {\n    opacity: 1;\n    display: block;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: currentColor;\n  }\n\n  & .${0} {\n    opacity: 0;\n    animation-name: ${0};\n    animation-duration: ${0}ms;\n    animation-timing-function: ${0};\n  }\n\n  & .${0} {\n    position: absolute;\n    /* @noflip */\n    left: 0px;\n    top: 0;\n    animation-name: ${0};\n    animation-duration: 2500ms;\n    animation-timing-function: ${0};\n    animation-iteration-count: infinite;\n    animation-delay: 200ms;\n  }\n`), touchRippleClasses_default.rippleVisible, enterKeyframe, DURATION, ({\n  theme\n}) => theme.transitions.easing.easeInOut, touchRippleClasses_default.ripplePulsate, ({\n  theme\n}) => theme.transitions.duration.shorter, touchRippleClasses_default.child, touchRippleClasses_default.childLeaving, exitKeyframe, DURATION, ({\n  theme\n}) => theme.transitions.easing.easeInOut, touchRippleClasses_default.childPulsate, pulsateKeyframe, ({\n  theme\n}) => theme.transitions.easing.easeInOut);\nvar TouchRipple = React2.forwardRef(function TouchRipple2(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: \"MuiTouchRipple\"\n  });\n  const {\n    center: centerProp = false,\n    classes = {},\n    className\n  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);\n  const [ripples, setRipples] = React2.useState([]);\n  const nextKey = React2.useRef(0);\n  const rippleCallback = React2.useRef(null);\n  React2.useEffect(() => {\n    if (rippleCallback.current) {\n      rippleCallback.current();\n      rippleCallback.current = null;\n    }\n  }, [ripples]);\n  const ignoringMouseDown = React2.useRef(false);\n  const startTimer = React2.useRef(0);\n  const startTimerCommit = React2.useRef(null);\n  const container = React2.useRef(null);\n  React2.useEffect(() => {\n    return () => {\n      if (startTimer.current) {\n        clearTimeout(startTimer.current);\n      }\n    };\n  }, []);\n  const startCommit = React2.useCallback((params) => {\n    const {\n      pulsate: pulsate2,\n      rippleX,\n      rippleY,\n      rippleSize,\n      cb\n    } = params;\n    setRipples((oldRipples) => [...oldRipples, (0, import_jsx_runtime2.jsx)(TouchRippleRipple, {\n      classes: {\n        ripple: clsx_default(classes.ripple, touchRippleClasses_default.ripple),\n        rippleVisible: clsx_default(classes.rippleVisible, touchRippleClasses_default.rippleVisible),\n        ripplePulsate: clsx_default(classes.ripplePulsate, touchRippleClasses_default.ripplePulsate),\n        child: clsx_default(classes.child, touchRippleClasses_default.child),\n        childLeaving: clsx_default(classes.childLeaving, touchRippleClasses_default.childLeaving),\n        childPulsate: clsx_default(classes.childPulsate, touchRippleClasses_default.childPulsate)\n      },\n      timeout: DURATION,\n      pulsate: pulsate2,\n      rippleX,\n      rippleY,\n      rippleSize\n    }, nextKey.current)]);\n    nextKey.current += 1;\n    rippleCallback.current = cb;\n  }, [classes]);\n  const start = React2.useCallback((event = {}, options = {}, cb = () => {\n  }) => {\n    const {\n      pulsate: pulsate2 = false,\n      center = centerProp || options.pulsate,\n      fakeElement = false\n      // For test purposes\n    } = options;\n    if ((event == null ? void 0 : event.type) === \"mousedown\" && ignoringMouseDown.current) {\n      ignoringMouseDown.current = false;\n      return;\n    }\n    if ((event == null ? void 0 : event.type) === \"touchstart\") {\n      ignoringMouseDown.current = true;\n    }\n    const element = fakeElement ? null : container.current;\n    const rect = element ? element.getBoundingClientRect() : {\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0\n    };\n    let rippleX;\n    let rippleY;\n    let rippleSize;\n    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {\n      rippleX = Math.round(rect.width / 2);\n      rippleY = Math.round(rect.height / 2);\n    } else {\n      const {\n        clientX,\n        clientY\n      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;\n      rippleX = Math.round(clientX - rect.left);\n      rippleY = Math.round(clientY - rect.top);\n    }\n    if (center) {\n      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);\n      if (rippleSize % 2 === 0) {\n        rippleSize += 1;\n      }\n    } else {\n      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;\n      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;\n      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);\n    }\n    if (event != null && event.touches) {\n      if (startTimerCommit.current === null) {\n        startTimerCommit.current = () => {\n          startCommit({\n            pulsate: pulsate2,\n            rippleX,\n            rippleY,\n            rippleSize,\n            cb\n          });\n        };\n        startTimer.current = setTimeout(() => {\n          if (startTimerCommit.current) {\n            startTimerCommit.current();\n            startTimerCommit.current = null;\n          }\n        }, DELAY_RIPPLE);\n      }\n    } else {\n      startCommit({\n        pulsate: pulsate2,\n        rippleX,\n        rippleY,\n        rippleSize,\n        cb\n      });\n    }\n  }, [centerProp, startCommit]);\n  const pulsate = React2.useCallback(() => {\n    start({}, {\n      pulsate: true\n    });\n  }, [start]);\n  const stop = React2.useCallback((event, cb) => {\n    clearTimeout(startTimer.current);\n    if ((event == null ? void 0 : event.type) === \"touchend\" && startTimerCommit.current) {\n      startTimerCommit.current();\n      startTimerCommit.current = null;\n      startTimer.current = setTimeout(() => {\n        stop(event, cb);\n      });\n      return;\n    }\n    startTimerCommit.current = null;\n    setRipples((oldRipples) => {\n      if (oldRipples.length > 0) {\n        return oldRipples.slice(1);\n      }\n      return oldRipples;\n    });\n    rippleCallback.current = cb;\n  }, []);\n  React2.useImperativeHandle(ref, () => ({\n    pulsate,\n    start,\n    stop\n  }), [pulsate, start, stop]);\n  return (0, import_jsx_runtime2.jsx)(TouchRippleRoot, _extends({\n    className: clsx_default(touchRippleClasses_default.root, classes.root, className),\n    ref: container\n  }, other, {\n    children: (0, import_jsx_runtime2.jsx)(TransitionGroup_default, {\n      component: null,\n      exit: true,\n      children: ripples\n    })\n  }));\n});\ntrue ? TouchRipple.propTypes = {\n  /**\n   * If `true`, the ripple starts at the center of the component\n   * rather than at the point of interaction.\n   */\n  center: import_prop_types2.default.bool,\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: import_prop_types2.default.object,\n  /**\n   * @ignore\n   */\n  className: import_prop_types2.default.string\n} : void 0;\nvar TouchRipple_default = TouchRipple;\n\n// node_modules/@mui/material/ButtonBase/ButtonBase.js\nvar import_jsx_runtime3 = __toESM(require_jsx_runtime());\nvar import_jsx_runtime4 = __toESM(require_jsx_runtime());\nvar _excluded2 = [\"action\", \"centerRipple\", \"children\", \"className\", \"component\", \"disabled\", \"disableRipple\", \"disableTouchRipple\", \"focusRipple\", \"focusVisibleClassName\", \"LinkComponent\", \"onBlur\", \"onClick\", \"onContextMenu\", \"onDragLeave\", \"onFocus\", \"onFocusVisible\", \"onKeyDown\", \"onKeyUp\", \"onMouseDown\", \"onMouseLeave\", \"onMouseUp\", \"onTouchEnd\", \"onTouchMove\", \"onTouchStart\", \"tabIndex\", \"TouchRippleProps\", \"touchRippleRef\", \"type\"];\nvar useUtilityClasses = (ownerState) => {\n  const {\n    disabled,\n    focusVisible,\n    focusVisibleClassName,\n    classes\n  } = ownerState;\n  const slots = {\n    root: [\"root\", disabled && \"disabled\", focusVisible && \"focusVisible\"]\n  };\n  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);\n  if (focusVisible && focusVisibleClassName) {\n    composedClasses.root += ` ${focusVisibleClassName}`;\n  }\n  return composedClasses;\n};\nvar ButtonBaseRoot = styled_default(\"button\", {\n  name: \"MuiButtonBase\",\n  slot: \"Root\",\n  overridesResolver: (props, styles) => styles.root\n})({\n  display: \"inline-flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  position: \"relative\",\n  boxSizing: \"border-box\",\n  WebkitTapHighlightColor: \"transparent\",\n  backgroundColor: \"transparent\",\n  // Reset default value\n  // We disable the focus ring for mouse, touch and keyboard users.\n  outline: 0,\n  border: 0,\n  margin: 0,\n  // Remove the margin in Safari\n  borderRadius: 0,\n  padding: 0,\n  // Remove the padding in Firefox\n  cursor: \"pointer\",\n  userSelect: \"none\",\n  verticalAlign: \"middle\",\n  MozAppearance: \"none\",\n  // Reset\n  WebkitAppearance: \"none\",\n  // Reset\n  textDecoration: \"none\",\n  // So we take precedent over the style of a native <a /> element.\n  color: \"inherit\",\n  \"&::-moz-focus-inner\": {\n    borderStyle: \"none\"\n    // Remove Firefox dotted outline.\n  },\n  [`&.${buttonBaseClasses_default.disabled}`]: {\n    pointerEvents: \"none\",\n    // Disable link interactions\n    cursor: \"default\"\n  },\n  \"@media print\": {\n    colorAdjust: \"exact\"\n  }\n});\nvar ButtonBase = React3.forwardRef(function ButtonBase2(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: \"MuiButtonBase\"\n  });\n  const {\n    action,\n    centerRipple = false,\n    children,\n    className,\n    component = \"button\",\n    disabled = false,\n    disableRipple = false,\n    disableTouchRipple = false,\n    focusRipple = false,\n    LinkComponent = \"a\",\n    onBlur,\n    onClick,\n    onContextMenu,\n    onDragLeave,\n    onFocus,\n    onFocusVisible,\n    onKeyDown,\n    onKeyUp,\n    onMouseDown,\n    onMouseLeave,\n    onMouseUp,\n    onTouchEnd,\n    onTouchMove,\n    onTouchStart,\n    tabIndex = 0,\n    TouchRippleProps,\n    touchRippleRef,\n    type\n  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);\n  const buttonRef = React3.useRef(null);\n  const rippleRef = React3.useRef(null);\n  const handleRippleRef = useForkRef_default(rippleRef, touchRippleRef);\n  const {\n    isFocusVisibleRef,\n    onFocus: handleFocusVisible,\n    onBlur: handleBlurVisible,\n    ref: focusVisibleRef\n  } = useIsFocusVisible_default();\n  const [focusVisible, setFocusVisible] = React3.useState(false);\n  if (disabled && focusVisible) {\n    setFocusVisible(false);\n  }\n  React3.useImperativeHandle(action, () => ({\n    focusVisible: () => {\n      setFocusVisible(true);\n      buttonRef.current.focus();\n    }\n  }), []);\n  const [mountedState, setMountedState] = React3.useState(false);\n  React3.useEffect(() => {\n    setMountedState(true);\n  }, []);\n  const enableTouchRipple = mountedState && !disableRipple && !disabled;\n  React3.useEffect(() => {\n    if (focusVisible && focusRipple && !disableRipple && mountedState) {\n      rippleRef.current.pulsate();\n    }\n  }, [disableRipple, focusRipple, focusVisible, mountedState]);\n  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {\n    return useEventCallback_default((event) => {\n      if (eventCallback) {\n        eventCallback(event);\n      }\n      const ignore = skipRippleAction;\n      if (!ignore && rippleRef.current) {\n        rippleRef.current[rippleAction](event);\n      }\n      return true;\n    });\n  }\n  const handleMouseDown = useRippleHandler(\"start\", onMouseDown);\n  const handleContextMenu = useRippleHandler(\"stop\", onContextMenu);\n  const handleDragLeave = useRippleHandler(\"stop\", onDragLeave);\n  const handleMouseUp = useRippleHandler(\"stop\", onMouseUp);\n  const handleMouseLeave = useRippleHandler(\"stop\", (event) => {\n    if (focusVisible) {\n      event.preventDefault();\n    }\n    if (onMouseLeave) {\n      onMouseLeave(event);\n    }\n  });\n  const handleTouchStart = useRippleHandler(\"start\", onTouchStart);\n  const handleTouchEnd = useRippleHandler(\"stop\", onTouchEnd);\n  const handleTouchMove = useRippleHandler(\"stop\", onTouchMove);\n  const handleBlur = useRippleHandler(\"stop\", (event) => {\n    handleBlurVisible(event);\n    if (isFocusVisibleRef.current === false) {\n      setFocusVisible(false);\n    }\n    if (onBlur) {\n      onBlur(event);\n    }\n  }, false);\n  const handleFocus = useEventCallback_default((event) => {\n    if (!buttonRef.current) {\n      buttonRef.current = event.currentTarget;\n    }\n    handleFocusVisible(event);\n    if (isFocusVisibleRef.current === true) {\n      setFocusVisible(true);\n      if (onFocusVisible) {\n        onFocusVisible(event);\n      }\n    }\n    if (onFocus) {\n      onFocus(event);\n    }\n  });\n  const isNonNativeButton = () => {\n    const button = buttonRef.current;\n    return component && component !== \"button\" && !(button.tagName === \"A\" && button.href);\n  };\n  const keydownRef = React3.useRef(false);\n  const handleKeyDown = useEventCallback_default((event) => {\n    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === \" \") {\n      keydownRef.current = true;\n      rippleRef.current.stop(event, () => {\n        rippleRef.current.start(event);\n      });\n    }\n    if (event.target === event.currentTarget && isNonNativeButton() && event.key === \" \") {\n      event.preventDefault();\n    }\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n    if (event.target === event.currentTarget && isNonNativeButton() && event.key === \"Enter\" && !disabled) {\n      event.preventDefault();\n      if (onClick) {\n        onClick(event);\n      }\n    }\n  });\n  const handleKeyUp = useEventCallback_default((event) => {\n    if (focusRipple && event.key === \" \" && rippleRef.current && focusVisible && !event.defaultPrevented) {\n      keydownRef.current = false;\n      rippleRef.current.stop(event, () => {\n        rippleRef.current.pulsate(event);\n      });\n    }\n    if (onKeyUp) {\n      onKeyUp(event);\n    }\n    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === \" \" && !event.defaultPrevented) {\n      onClick(event);\n    }\n  });\n  let ComponentProp = component;\n  if (ComponentProp === \"button\" && (other.href || other.to)) {\n    ComponentProp = LinkComponent;\n  }\n  const buttonProps = {};\n  if (ComponentProp === \"button\") {\n    buttonProps.type = type === void 0 ? \"button\" : type;\n    buttonProps.disabled = disabled;\n  } else {\n    if (!other.href && !other.to) {\n      buttonProps.role = \"button\";\n    }\n    if (disabled) {\n      buttonProps[\"aria-disabled\"] = disabled;\n    }\n  }\n  const handleRef = useForkRef_default(ref, focusVisibleRef, buttonRef);\n  if (true) {\n    React3.useEffect(() => {\n      if (enableTouchRipple && !rippleRef.current) {\n        console.error([\"MUI: The `component` prop provided to ButtonBase is invalid.\", \"Please make sure the children prop is rendered in this custom component.\"].join(\"\\n\"));\n      }\n    }, [enableTouchRipple]);\n  }\n  const ownerState = _extends({}, props, {\n    centerRipple,\n    component,\n    disabled,\n    disableRipple,\n    disableTouchRipple,\n    focusRipple,\n    tabIndex,\n    focusVisible\n  });\n  const classes = useUtilityClasses(ownerState);\n  return (0, import_jsx_runtime4.jsxs)(ButtonBaseRoot, _extends({\n    as: ComponentProp,\n    className: clsx_default(classes.root, className),\n    ownerState,\n    onBlur: handleBlur,\n    onClick,\n    onContextMenu: handleContextMenu,\n    onFocus: handleFocus,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onMouseDown: handleMouseDown,\n    onMouseLeave: handleMouseLeave,\n    onMouseUp: handleMouseUp,\n    onDragLeave: handleDragLeave,\n    onTouchEnd: handleTouchEnd,\n    onTouchMove: handleTouchMove,\n    onTouchStart: handleTouchStart,\n    ref: handleRef,\n    tabIndex: disabled ? -1 : tabIndex,\n    type\n  }, buttonProps, other, {\n    children: [children, enableTouchRipple ? (\n      /* TouchRipple is only needed client-side, x2 boost on the server. */\n      (0, import_jsx_runtime3.jsx)(TouchRipple_default, _extends({\n        ref: handleRippleRef,\n        center: centerRipple\n      }, TouchRippleProps))\n    ) : null]\n  }));\n});\ntrue ? ButtonBase.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * A ref for imperative actions.\n   * It currently only supports `focusVisible()` action.\n   */\n  action: refType_default,\n  /**\n   * If `true`, the ripples are centered.\n   * They won't start at the cursor interaction position.\n   * @default false\n   */\n  centerRipple: import_prop_types3.default.bool,\n  /**\n   * The content of the component.\n   */\n  children: import_prop_types3.default.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: import_prop_types3.default.object,\n  /**\n   * @ignore\n   */\n  className: import_prop_types3.default.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: elementTypeAcceptingRef_default,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: import_prop_types3.default.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   *\n   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure\n   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.\n   * @default false\n   */\n  disableRipple: import_prop_types3.default.bool,\n  /**\n   * If `true`, the touch ripple effect is disabled.\n   * @default false\n   */\n  disableTouchRipple: import_prop_types3.default.bool,\n  /**\n   * If `true`, the base button will have a keyboard focus ripple.\n   * @default false\n   */\n  focusRipple: import_prop_types3.default.bool,\n  /**\n   * This prop can help identify which element has keyboard focus.\n   * The class name will be applied when the element gains the focus through keyboard interaction.\n   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).\n   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).\n   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components\n   * if needed.\n   */\n  focusVisibleClassName: import_prop_types3.default.string,\n  /**\n   * @ignore\n   */\n  href: import_prop_types3.default.any,\n  /**\n   * The component used to render a link when the `href` prop is provided.\n   * @default 'a'\n   */\n  LinkComponent: import_prop_types3.default.elementType,\n  /**\n   * @ignore\n   */\n  onBlur: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onClick: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onContextMenu: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onDragLeave: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onFocus: import_prop_types3.default.func,\n  /**\n   * Callback fired when the component is focused with a keyboard.\n   * We trigger a `onFocus` callback too.\n   */\n  onFocusVisible: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onKeyDown: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onKeyUp: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onMouseDown: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onMouseLeave: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onMouseUp: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onTouchEnd: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onTouchMove: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onTouchStart: import_prop_types3.default.func,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),\n  /**\n   * @default 0\n   */\n  tabIndex: import_prop_types3.default.number,\n  /**\n   * Props applied to the `TouchRipple` element.\n   */\n  TouchRippleProps: import_prop_types3.default.object,\n  /**\n   * A ref that points to the `TouchRipple` element.\n   */\n  touchRippleRef: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.shape({\n    current: import_prop_types3.default.shape({\n      pulsate: import_prop_types3.default.func.isRequired,\n      start: import_prop_types3.default.func.isRequired,\n      stop: import_prop_types3.default.func.isRequired\n    })\n  })]),\n  /**\n   * @ignore\n   */\n  type: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf([\"button\", \"reset\", \"submit\"]), import_prop_types3.default.string])\n} : void 0;\nvar ButtonBase_default = ButtonBase;\n\nexport {\n  getTouchRippleUtilityClass,\n  touchRippleClasses_default,\n  getButtonBaseUtilityClass,\n  buttonBaseClasses_default,\n  ButtonBase_default\n};\n//# sourceMappingURL=chunk-PA33DROR.js.map\n",
      "start": 1701766112550,
      "end": 1701766112680,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:react-swc",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1701766112680,
      "end": 1701766112680,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import {\n  TransitionGroup_default\n} from \"/node_modules/.vite/deps/chunk-ZFUPPDSN.js?v=3c106fdb\";\nimport {\n  init_useEventCallback,\n  useEventCallback_default\n} from \"/node_modules/.vite/deps/chunk-LKP4EHGH.js?v=3c106fdb\";\nimport {\n  init_useIsFocusVisible,\n  useIsFocusVisible_default\n} from \"/node_modules/.vite/deps/chunk-KUYV4CAE.js?v=3c106fdb\";\nimport {\n  init_useForkRef,\n  useForkRef_default\n} from \"/node_modules/.vite/deps/chunk-23AETIBN.js?v=3c106fdb\";\nimport {\n  init_composeClasses\n} from \"/node_modules/.vite/deps/chunk-NEVWHIAS.js?v=3c106fdb\";\nimport {\n  _objectWithoutPropertiesLoose,\n  clsx_default,\n  composeClasses,\n  elementTypeAcceptingRef_default,\n  generateUtilityClass,\n  generateUtilityClasses,\n  init_clsx,\n  init_esm,\n  init_esm2,\n  init_generateUtilityClass,\n  init_objectWithoutPropertiesLoose,\n  init_styled,\n  init_useThemeProps,\n  refType_default,\n  require_prop_types,\n  styled_default,\n  useThemeProps2 as useThemeProps\n} from \"/node_modules/.vite/deps/chunk-6ZT6S2Z7.js?v=3c106fdb\";\nimport {\n  require_jsx_runtime\n} from \"/node_modules/.vite/deps/chunk-U73TBONF.js?v=3c106fdb\";\nimport {\n  keyframes\n} from \"/node_modules/.vite/deps/chunk-6XVPP5RS.js?v=3c106fdb\";\nimport {\n  _extends,\n  init_extends\n} from \"/node_modules/.vite/deps/chunk-HMTWVGVS.js?v=3c106fdb\";\nimport {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-ZGRSIX2Q.js?v=3c106fdb\";\nimport {\n  __toESM\n} from \"/node_modules/.vite/deps/chunk-ROME4SDB.js?v=3c106fdb\";\n\n// node_modules/@mui/material/ButtonBase/touchRippleClasses.js\ninit_esm();\ninit_generateUtilityClass();\nfunction getTouchRippleUtilityClass(slot) {\n  return generateUtilityClass(\"MuiTouchRipple\", slot);\n}\nvar touchRippleClasses = generateUtilityClasses(\"MuiTouchRipple\", [\"root\", \"ripple\", \"rippleVisible\", \"ripplePulsate\", \"child\", \"childLeaving\", \"childPulsate\"]);\nvar touchRippleClasses_default = touchRippleClasses;\n\n// node_modules/@mui/material/ButtonBase/buttonBaseClasses.js\ninit_esm();\ninit_generateUtilityClass();\nfunction getButtonBaseUtilityClass(slot) {\n  return generateUtilityClass(\"MuiButtonBase\", slot);\n}\nvar buttonBaseClasses = generateUtilityClasses(\"MuiButtonBase\", [\"root\", \"disabled\", \"focusVisible\"]);\nvar buttonBaseClasses_default = buttonBaseClasses;\n\n// node_modules/@mui/material/ButtonBase/ButtonBase.js\ninit_extends();\ninit_objectWithoutPropertiesLoose();\nvar React3 = __toESM(require_react());\nvar import_prop_types3 = __toESM(require_prop_types());\ninit_clsx();\ninit_esm();\ninit_composeClasses();\ninit_styled();\ninit_useThemeProps();\ninit_useForkRef();\ninit_useEventCallback();\ninit_useIsFocusVisible();\n\n// node_modules/@mui/material/ButtonBase/TouchRipple.js\ninit_extends();\ninit_objectWithoutPropertiesLoose();\nvar React2 = __toESM(require_react());\nvar import_prop_types2 = __toESM(require_prop_types());\ninit_clsx();\ninit_esm2();\ninit_styled();\ninit_useThemeProps();\n\n// node_modules/@mui/material/ButtonBase/Ripple.js\nvar React = __toESM(require_react());\nvar import_prop_types = __toESM(require_prop_types());\ninit_clsx();\nvar import_jsx_runtime = __toESM(require_jsx_runtime());\nfunction Ripple(props) {\n  const {\n    className,\n    classes,\n    pulsate = false,\n    rippleX,\n    rippleY,\n    rippleSize,\n    in: inProp,\n    onExited,\n    timeout\n  } = props;\n  const [leaving, setLeaving] = React.useState(false);\n  const rippleClassName = clsx_default(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);\n  const rippleStyles = {\n    width: rippleSize,\n    height: rippleSize,\n    top: -(rippleSize / 2) + rippleY,\n    left: -(rippleSize / 2) + rippleX\n  };\n  const childClassName = clsx_default(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);\n  if (!inProp && !leaving) {\n    setLeaving(true);\n  }\n  React.useEffect(() => {\n    if (!inProp && onExited != null) {\n      const timeoutId = setTimeout(onExited, timeout);\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n    return void 0;\n  }, [onExited, inProp, timeout]);\n  return (0, import_jsx_runtime.jsx)(\"span\", {\n    className: rippleClassName,\n    style: rippleStyles,\n    children: (0, import_jsx_runtime.jsx)(\"span\", {\n      className: childClassName\n    })\n  });\n}\ntrue ? Ripple.propTypes = {\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: import_prop_types.default.object.isRequired,\n  className: import_prop_types.default.string,\n  /**\n   * @ignore - injected from TransitionGroup\n   */\n  in: import_prop_types.default.bool,\n  /**\n   * @ignore - injected from TransitionGroup\n   */\n  onExited: import_prop_types.default.func,\n  /**\n   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.\n   */\n  pulsate: import_prop_types.default.bool,\n  /**\n   * Diameter of the ripple.\n   */\n  rippleSize: import_prop_types.default.number,\n  /**\n   * Horizontal position of the ripple center.\n   */\n  rippleX: import_prop_types.default.number,\n  /**\n   * Vertical position of the ripple center.\n   */\n  rippleY: import_prop_types.default.number,\n  /**\n   * exit delay\n   */\n  timeout: import_prop_types.default.number.isRequired\n} : void 0;\nvar Ripple_default = Ripple;\n\n// node_modules/@mui/material/ButtonBase/TouchRipple.js\nvar import_jsx_runtime2 = __toESM(require_jsx_runtime());\nvar _excluded = [\"center\", \"classes\", \"className\"];\nvar _ = (t) => t;\nvar _t;\nvar _t2;\nvar _t3;\nvar _t4;\nvar DURATION = 550;\nvar DELAY_RIPPLE = 80;\nvar enterKeyframe = keyframes(_t || (_t = _`\n  0% {\n    transform: scale(0);\n    opacity: 0.1;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 0.3;\n  }\n`));\nvar exitKeyframe = keyframes(_t2 || (_t2 = _`\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`));\nvar pulsateKeyframe = keyframes(_t3 || (_t3 = _`\n  0% {\n    transform: scale(1);\n  }\n\n  50% {\n    transform: scale(0.92);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n`));\nvar TouchRippleRoot = styled_default(\"span\", {\n  name: \"MuiTouchRipple\",\n  slot: \"Root\"\n})({\n  overflow: \"hidden\",\n  pointerEvents: \"none\",\n  position: \"absolute\",\n  zIndex: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  borderRadius: \"inherit\"\n});\nvar TouchRippleRipple = styled_default(Ripple_default, {\n  name: \"MuiTouchRipple\",\n  slot: \"Ripple\"\n})(_t4 || (_t4 = _`\n  opacity: 0;\n  position: absolute;\n\n  &.${0} {\n    opacity: 0.3;\n    transform: scale(1);\n    animation-name: ${0};\n    animation-duration: ${0}ms;\n    animation-timing-function: ${0};\n  }\n\n  &.${0} {\n    animation-duration: ${0}ms;\n  }\n\n  & .${0} {\n    opacity: 1;\n    display: block;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: currentColor;\n  }\n\n  & .${0} {\n    opacity: 0;\n    animation-name: ${0};\n    animation-duration: ${0}ms;\n    animation-timing-function: ${0};\n  }\n\n  & .${0} {\n    position: absolute;\n    /* @noflip */\n    left: 0px;\n    top: 0;\n    animation-name: ${0};\n    animation-duration: 2500ms;\n    animation-timing-function: ${0};\n    animation-iteration-count: infinite;\n    animation-delay: 200ms;\n  }\n`), touchRippleClasses_default.rippleVisible, enterKeyframe, DURATION, ({\n  theme\n}) => theme.transitions.easing.easeInOut, touchRippleClasses_default.ripplePulsate, ({\n  theme\n}) => theme.transitions.duration.shorter, touchRippleClasses_default.child, touchRippleClasses_default.childLeaving, exitKeyframe, DURATION, ({\n  theme\n}) => theme.transitions.easing.easeInOut, touchRippleClasses_default.childPulsate, pulsateKeyframe, ({\n  theme\n}) => theme.transitions.easing.easeInOut);\nvar TouchRipple = React2.forwardRef(function TouchRipple2(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: \"MuiTouchRipple\"\n  });\n  const {\n    center: centerProp = false,\n    classes = {},\n    className\n  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);\n  const [ripples, setRipples] = React2.useState([]);\n  const nextKey = React2.useRef(0);\n  const rippleCallback = React2.useRef(null);\n  React2.useEffect(() => {\n    if (rippleCallback.current) {\n      rippleCallback.current();\n      rippleCallback.current = null;\n    }\n  }, [ripples]);\n  const ignoringMouseDown = React2.useRef(false);\n  const startTimer = React2.useRef(0);\n  const startTimerCommit = React2.useRef(null);\n  const container = React2.useRef(null);\n  React2.useEffect(() => {\n    return () => {\n      if (startTimer.current) {\n        clearTimeout(startTimer.current);\n      }\n    };\n  }, []);\n  const startCommit = React2.useCallback((params) => {\n    const {\n      pulsate: pulsate2,\n      rippleX,\n      rippleY,\n      rippleSize,\n      cb\n    } = params;\n    setRipples((oldRipples) => [...oldRipples, (0, import_jsx_runtime2.jsx)(TouchRippleRipple, {\n      classes: {\n        ripple: clsx_default(classes.ripple, touchRippleClasses_default.ripple),\n        rippleVisible: clsx_default(classes.rippleVisible, touchRippleClasses_default.rippleVisible),\n        ripplePulsate: clsx_default(classes.ripplePulsate, touchRippleClasses_default.ripplePulsate),\n        child: clsx_default(classes.child, touchRippleClasses_default.child),\n        childLeaving: clsx_default(classes.childLeaving, touchRippleClasses_default.childLeaving),\n        childPulsate: clsx_default(classes.childPulsate, touchRippleClasses_default.childPulsate)\n      },\n      timeout: DURATION,\n      pulsate: pulsate2,\n      rippleX,\n      rippleY,\n      rippleSize\n    }, nextKey.current)]);\n    nextKey.current += 1;\n    rippleCallback.current = cb;\n  }, [classes]);\n  const start = React2.useCallback((event = {}, options = {}, cb = () => {\n  }) => {\n    const {\n      pulsate: pulsate2 = false,\n      center = centerProp || options.pulsate,\n      fakeElement = false\n      // For test purposes\n    } = options;\n    if ((event == null ? void 0 : event.type) === \"mousedown\" && ignoringMouseDown.current) {\n      ignoringMouseDown.current = false;\n      return;\n    }\n    if ((event == null ? void 0 : event.type) === \"touchstart\") {\n      ignoringMouseDown.current = true;\n    }\n    const element = fakeElement ? null : container.current;\n    const rect = element ? element.getBoundingClientRect() : {\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0\n    };\n    let rippleX;\n    let rippleY;\n    let rippleSize;\n    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {\n      rippleX = Math.round(rect.width / 2);\n      rippleY = Math.round(rect.height / 2);\n    } else {\n      const {\n        clientX,\n        clientY\n      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;\n      rippleX = Math.round(clientX - rect.left);\n      rippleY = Math.round(clientY - rect.top);\n    }\n    if (center) {\n      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);\n      if (rippleSize % 2 === 0) {\n        rippleSize += 1;\n      }\n    } else {\n      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;\n      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;\n      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);\n    }\n    if (event != null && event.touches) {\n      if (startTimerCommit.current === null) {\n        startTimerCommit.current = () => {\n          startCommit({\n            pulsate: pulsate2,\n            rippleX,\n            rippleY,\n            rippleSize,\n            cb\n          });\n        };\n        startTimer.current = setTimeout(() => {\n          if (startTimerCommit.current) {\n            startTimerCommit.current();\n            startTimerCommit.current = null;\n          }\n        }, DELAY_RIPPLE);\n      }\n    } else {\n      startCommit({\n        pulsate: pulsate2,\n        rippleX,\n        rippleY,\n        rippleSize,\n        cb\n      });\n    }\n  }, [centerProp, startCommit]);\n  const pulsate = React2.useCallback(() => {\n    start({}, {\n      pulsate: true\n    });\n  }, [start]);\n  const stop = React2.useCallback((event, cb) => {\n    clearTimeout(startTimer.current);\n    if ((event == null ? void 0 : event.type) === \"touchend\" && startTimerCommit.current) {\n      startTimerCommit.current();\n      startTimerCommit.current = null;\n      startTimer.current = setTimeout(() => {\n        stop(event, cb);\n      });\n      return;\n    }\n    startTimerCommit.current = null;\n    setRipples((oldRipples) => {\n      if (oldRipples.length > 0) {\n        return oldRipples.slice(1);\n      }\n      return oldRipples;\n    });\n    rippleCallback.current = cb;\n  }, []);\n  React2.useImperativeHandle(ref, () => ({\n    pulsate,\n    start,\n    stop\n  }), [pulsate, start, stop]);\n  return (0, import_jsx_runtime2.jsx)(TouchRippleRoot, _extends({\n    className: clsx_default(touchRippleClasses_default.root, classes.root, className),\n    ref: container\n  }, other, {\n    children: (0, import_jsx_runtime2.jsx)(TransitionGroup_default, {\n      component: null,\n      exit: true,\n      children: ripples\n    })\n  }));\n});\ntrue ? TouchRipple.propTypes = {\n  /**\n   * If `true`, the ripple starts at the center of the component\n   * rather than at the point of interaction.\n   */\n  center: import_prop_types2.default.bool,\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: import_prop_types2.default.object,\n  /**\n   * @ignore\n   */\n  className: import_prop_types2.default.string\n} : void 0;\nvar TouchRipple_default = TouchRipple;\n\n// node_modules/@mui/material/ButtonBase/ButtonBase.js\nvar import_jsx_runtime3 = __toESM(require_jsx_runtime());\nvar import_jsx_runtime4 = __toESM(require_jsx_runtime());\nvar _excluded2 = [\"action\", \"centerRipple\", \"children\", \"className\", \"component\", \"disabled\", \"disableRipple\", \"disableTouchRipple\", \"focusRipple\", \"focusVisibleClassName\", \"LinkComponent\", \"onBlur\", \"onClick\", \"onContextMenu\", \"onDragLeave\", \"onFocus\", \"onFocusVisible\", \"onKeyDown\", \"onKeyUp\", \"onMouseDown\", \"onMouseLeave\", \"onMouseUp\", \"onTouchEnd\", \"onTouchMove\", \"onTouchStart\", \"tabIndex\", \"TouchRippleProps\", \"touchRippleRef\", \"type\"];\nvar useUtilityClasses = (ownerState) => {\n  const {\n    disabled,\n    focusVisible,\n    focusVisibleClassName,\n    classes\n  } = ownerState;\n  const slots = {\n    root: [\"root\", disabled && \"disabled\", focusVisible && \"focusVisible\"]\n  };\n  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);\n  if (focusVisible && focusVisibleClassName) {\n    composedClasses.root += ` ${focusVisibleClassName}`;\n  }\n  return composedClasses;\n};\nvar ButtonBaseRoot = styled_default(\"button\", {\n  name: \"MuiButtonBase\",\n  slot: \"Root\",\n  overridesResolver: (props, styles) => styles.root\n})({\n  display: \"inline-flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  position: \"relative\",\n  boxSizing: \"border-box\",\n  WebkitTapHighlightColor: \"transparent\",\n  backgroundColor: \"transparent\",\n  // Reset default value\n  // We disable the focus ring for mouse, touch and keyboard users.\n  outline: 0,\n  border: 0,\n  margin: 0,\n  // Remove the margin in Safari\n  borderRadius: 0,\n  padding: 0,\n  // Remove the padding in Firefox\n  cursor: \"pointer\",\n  userSelect: \"none\",\n  verticalAlign: \"middle\",\n  MozAppearance: \"none\",\n  // Reset\n  WebkitAppearance: \"none\",\n  // Reset\n  textDecoration: \"none\",\n  // So we take precedent over the style of a native <a /> element.\n  color: \"inherit\",\n  \"&::-moz-focus-inner\": {\n    borderStyle: \"none\"\n    // Remove Firefox dotted outline.\n  },\n  [`&.${buttonBaseClasses_default.disabled}`]: {\n    pointerEvents: \"none\",\n    // Disable link interactions\n    cursor: \"default\"\n  },\n  \"@media print\": {\n    colorAdjust: \"exact\"\n  }\n});\nvar ButtonBase = React3.forwardRef(function ButtonBase2(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: \"MuiButtonBase\"\n  });\n  const {\n    action,\n    centerRipple = false,\n    children,\n    className,\n    component = \"button\",\n    disabled = false,\n    disableRipple = false,\n    disableTouchRipple = false,\n    focusRipple = false,\n    LinkComponent = \"a\",\n    onBlur,\n    onClick,\n    onContextMenu,\n    onDragLeave,\n    onFocus,\n    onFocusVisible,\n    onKeyDown,\n    onKeyUp,\n    onMouseDown,\n    onMouseLeave,\n    onMouseUp,\n    onTouchEnd,\n    onTouchMove,\n    onTouchStart,\n    tabIndex = 0,\n    TouchRippleProps,\n    touchRippleRef,\n    type\n  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);\n  const buttonRef = React3.useRef(null);\n  const rippleRef = React3.useRef(null);\n  const handleRippleRef = useForkRef_default(rippleRef, touchRippleRef);\n  const {\n    isFocusVisibleRef,\n    onFocus: handleFocusVisible,\n    onBlur: handleBlurVisible,\n    ref: focusVisibleRef\n  } = useIsFocusVisible_default();\n  const [focusVisible, setFocusVisible] = React3.useState(false);\n  if (disabled && focusVisible) {\n    setFocusVisible(false);\n  }\n  React3.useImperativeHandle(action, () => ({\n    focusVisible: () => {\n      setFocusVisible(true);\n      buttonRef.current.focus();\n    }\n  }), []);\n  const [mountedState, setMountedState] = React3.useState(false);\n  React3.useEffect(() => {\n    setMountedState(true);\n  }, []);\n  const enableTouchRipple = mountedState && !disableRipple && !disabled;\n  React3.useEffect(() => {\n    if (focusVisible && focusRipple && !disableRipple && mountedState) {\n      rippleRef.current.pulsate();\n    }\n  }, [disableRipple, focusRipple, focusVisible, mountedState]);\n  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {\n    return useEventCallback_default((event) => {\n      if (eventCallback) {\n        eventCallback(event);\n      }\n      const ignore = skipRippleAction;\n      if (!ignore && rippleRef.current) {\n        rippleRef.current[rippleAction](event);\n      }\n      return true;\n    });\n  }\n  const handleMouseDown = useRippleHandler(\"start\", onMouseDown);\n  const handleContextMenu = useRippleHandler(\"stop\", onContextMenu);\n  const handleDragLeave = useRippleHandler(\"stop\", onDragLeave);\n  const handleMouseUp = useRippleHandler(\"stop\", onMouseUp);\n  const handleMouseLeave = useRippleHandler(\"stop\", (event) => {\n    if (focusVisible) {\n      event.preventDefault();\n    }\n    if (onMouseLeave) {\n      onMouseLeave(event);\n    }\n  });\n  const handleTouchStart = useRippleHandler(\"start\", onTouchStart);\n  const handleTouchEnd = useRippleHandler(\"stop\", onTouchEnd);\n  const handleTouchMove = useRippleHandler(\"stop\", onTouchMove);\n  const handleBlur = useRippleHandler(\"stop\", (event) => {\n    handleBlurVisible(event);\n    if (isFocusVisibleRef.current === false) {\n      setFocusVisible(false);\n    }\n    if (onBlur) {\n      onBlur(event);\n    }\n  }, false);\n  const handleFocus = useEventCallback_default((event) => {\n    if (!buttonRef.current) {\n      buttonRef.current = event.currentTarget;\n    }\n    handleFocusVisible(event);\n    if (isFocusVisibleRef.current === true) {\n      setFocusVisible(true);\n      if (onFocusVisible) {\n        onFocusVisible(event);\n      }\n    }\n    if (onFocus) {\n      onFocus(event);\n    }\n  });\n  const isNonNativeButton = () => {\n    const button = buttonRef.current;\n    return component && component !== \"button\" && !(button.tagName === \"A\" && button.href);\n  };\n  const keydownRef = React3.useRef(false);\n  const handleKeyDown = useEventCallback_default((event) => {\n    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === \" \") {\n      keydownRef.current = true;\n      rippleRef.current.stop(event, () => {\n        rippleRef.current.start(event);\n      });\n    }\n    if (event.target === event.currentTarget && isNonNativeButton() && event.key === \" \") {\n      event.preventDefault();\n    }\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n    if (event.target === event.currentTarget && isNonNativeButton() && event.key === \"Enter\" && !disabled) {\n      event.preventDefault();\n      if (onClick) {\n        onClick(event);\n      }\n    }\n  });\n  const handleKeyUp = useEventCallback_default((event) => {\n    if (focusRipple && event.key === \" \" && rippleRef.current && focusVisible && !event.defaultPrevented) {\n      keydownRef.current = false;\n      rippleRef.current.stop(event, () => {\n        rippleRef.current.pulsate(event);\n      });\n    }\n    if (onKeyUp) {\n      onKeyUp(event);\n    }\n    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === \" \" && !event.defaultPrevented) {\n      onClick(event);\n    }\n  });\n  let ComponentProp = component;\n  if (ComponentProp === \"button\" && (other.href || other.to)) {\n    ComponentProp = LinkComponent;\n  }\n  const buttonProps = {};\n  if (ComponentProp === \"button\") {\n    buttonProps.type = type === void 0 ? \"button\" : type;\n    buttonProps.disabled = disabled;\n  } else {\n    if (!other.href && !other.to) {\n      buttonProps.role = \"button\";\n    }\n    if (disabled) {\n      buttonProps[\"aria-disabled\"] = disabled;\n    }\n  }\n  const handleRef = useForkRef_default(ref, focusVisibleRef, buttonRef);\n  if (true) {\n    React3.useEffect(() => {\n      if (enableTouchRipple && !rippleRef.current) {\n        console.error([\"MUI: The `component` prop provided to ButtonBase is invalid.\", \"Please make sure the children prop is rendered in this custom component.\"].join(\"\\n\"));\n      }\n    }, [enableTouchRipple]);\n  }\n  const ownerState = _extends({}, props, {\n    centerRipple,\n    component,\n    disabled,\n    disableRipple,\n    disableTouchRipple,\n    focusRipple,\n    tabIndex,\n    focusVisible\n  });\n  const classes = useUtilityClasses(ownerState);\n  return (0, import_jsx_runtime4.jsxs)(ButtonBaseRoot, _extends({\n    as: ComponentProp,\n    className: clsx_default(classes.root, className),\n    ownerState,\n    onBlur: handleBlur,\n    onClick,\n    onContextMenu: handleContextMenu,\n    onFocus: handleFocus,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    onMouseDown: handleMouseDown,\n    onMouseLeave: handleMouseLeave,\n    onMouseUp: handleMouseUp,\n    onDragLeave: handleDragLeave,\n    onTouchEnd: handleTouchEnd,\n    onTouchMove: handleTouchMove,\n    onTouchStart: handleTouchStart,\n    ref: handleRef,\n    tabIndex: disabled ? -1 : tabIndex,\n    type\n  }, buttonProps, other, {\n    children: [children, enableTouchRipple ? (\n      /* TouchRipple is only needed client-side, x2 boost on the server. */\n      (0, import_jsx_runtime3.jsx)(TouchRipple_default, _extends({\n        ref: handleRippleRef,\n        center: centerRipple\n      }, TouchRippleProps))\n    ) : null]\n  }));\n});\ntrue ? ButtonBase.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * A ref for imperative actions.\n   * It currently only supports `focusVisible()` action.\n   */\n  action: refType_default,\n  /**\n   * If `true`, the ripples are centered.\n   * They won't start at the cursor interaction position.\n   * @default false\n   */\n  centerRipple: import_prop_types3.default.bool,\n  /**\n   * The content of the component.\n   */\n  children: import_prop_types3.default.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: import_prop_types3.default.object,\n  /**\n   * @ignore\n   */\n  className: import_prop_types3.default.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: elementTypeAcceptingRef_default,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: import_prop_types3.default.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   *\n   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure\n   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.\n   * @default false\n   */\n  disableRipple: import_prop_types3.default.bool,\n  /**\n   * If `true`, the touch ripple effect is disabled.\n   * @default false\n   */\n  disableTouchRipple: import_prop_types3.default.bool,\n  /**\n   * If `true`, the base button will have a keyboard focus ripple.\n   * @default false\n   */\n  focusRipple: import_prop_types3.default.bool,\n  /**\n   * This prop can help identify which element has keyboard focus.\n   * The class name will be applied when the element gains the focus through keyboard interaction.\n   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).\n   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).\n   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components\n   * if needed.\n   */\n  focusVisibleClassName: import_prop_types3.default.string,\n  /**\n   * @ignore\n   */\n  href: import_prop_types3.default.any,\n  /**\n   * The component used to render a link when the `href` prop is provided.\n   * @default 'a'\n   */\n  LinkComponent: import_prop_types3.default.elementType,\n  /**\n   * @ignore\n   */\n  onBlur: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onClick: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onContextMenu: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onDragLeave: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onFocus: import_prop_types3.default.func,\n  /**\n   * Callback fired when the component is focused with a keyboard.\n   * We trigger a `onFocus` callback too.\n   */\n  onFocusVisible: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onKeyDown: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onKeyUp: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onMouseDown: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onMouseLeave: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onMouseUp: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onTouchEnd: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onTouchMove: import_prop_types3.default.func,\n  /**\n   * @ignore\n   */\n  onTouchStart: import_prop_types3.default.func,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),\n  /**\n   * @default 0\n   */\n  tabIndex: import_prop_types3.default.number,\n  /**\n   * Props applied to the `TouchRipple` element.\n   */\n  TouchRippleProps: import_prop_types3.default.object,\n  /**\n   * A ref that points to the `TouchRipple` element.\n   */\n  touchRippleRef: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.shape({\n    current: import_prop_types3.default.shape({\n      pulsate: import_prop_types3.default.func.isRequired,\n      start: import_prop_types3.default.func.isRequired,\n      stop: import_prop_types3.default.func.isRequired\n    })\n  })]),\n  /**\n   * @ignore\n   */\n  type: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf([\"button\", \"reset\", \"submit\"]), import_prop_types3.default.string])\n} : void 0;\nvar ButtonBase_default = ButtonBase;\n\nexport {\n  getTouchRippleUtilityClass,\n  touchRippleClasses_default,\n  getButtonBaseUtilityClass,\n  buttonBaseClasses_default,\n  ButtonBase_default\n};\n//# sourceMappingURL=chunk-PA33DROR.js.map\n",
      "start": 1701766112680,
      "end": 1701766112681,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
