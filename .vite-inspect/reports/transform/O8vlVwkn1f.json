{
  "resolvedId": "C:/Users/ryan.wong/Desktop/dev/TourneyPro_v2/node_modules/.vite/deps/jotai.js?v=3c106fdb",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "import {\n  require_react\n} from \"./chunk-ZGRSIX2Q.js\";\nimport {\n  __toESM\n} from \"./chunk-ROME4SDB.js\";\n\n// node_modules/jotai/esm/vanilla.mjs\nvar keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function(get) {\n      return get(this);\n    };\n    config.write = function(get, set, arg) {\n      return set(\n        this,\n        typeof arg === \"function\" ? arg(get(this)) : arg\n      );\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nvar hasInitialValue = (atom2) => \"init\" in atom2;\nvar isActuallyWritableAtom = (atom2) => !!atom2.write;\nvar cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nvar registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nvar cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nvar resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nvar rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nvar isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nvar isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nvar isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nvar hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nvar isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nvar returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nvar createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom2) => atomStateMap.get(atom2);\n  const setAtomState = (atom2, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom2);\n    atomStateMap.set(atom2, atomState);\n    if (!pendingMap.has(atom2)) {\n      pendingMap.set(atom2, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom2, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom2) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom2, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom2);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom2, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom2, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom2, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom2);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom2,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom2) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom2, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom2, promise, nextDependencies);\n    }\n    return setAtomValue(atom2, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom2, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom2);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom2, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom2, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom2, force) => {\n    const atomState = getAtomState(atom2);\n    if (!force && atomState) {\n      if (mountedMap.has(atom2)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom2) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (a === atom2) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom2)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom2)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom2, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom2.read(getter, options);\n      return setAtomValueOrPromise(\n        atom2,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom2, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom2) => returnAtomValue(readAtomState(atom2));\n  const addAtom = (atom2) => {\n    let mounted = mountedMap.get(atom2);\n    if (!mounted) {\n      mounted = mountAtom(atom2);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom2, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom2));\n  const delAtom = (atom2) => {\n    const mounted = mountedMap.get(atom2);\n    if (mounted && canUnmountAtom(atom2, mounted)) {\n      unmountAtom(atom2);\n    }\n  };\n  const recomputeDependents = (atom2) => {\n    const dependencyMap = /* @__PURE__ */ new Map();\n    const dirtyMap = /* @__PURE__ */ new WeakMap();\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const loop1 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        if (dependent !== a) {\n          dependencyMap.set(\n            dependent,\n            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a)\n          );\n          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n          loop1(dependent);\n        }\n      });\n    };\n    loop1(atom2);\n    const loop2 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        var _a;\n        if (dependent !== a) {\n          let dirtyCount = dirtyMap.get(dependent);\n          if (dirtyCount) {\n            dirtyMap.set(dependent, --dirtyCount);\n          }\n          if (!dirtyCount) {\n            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n            if (isChanged) {\n              const prevAtomState = getAtomState(dependent);\n              const nextAtomState = readAtomState(dependent, true);\n              isChanged = !isEqualAtomValue(prevAtomState, nextAtomState);\n            }\n            if (!isChanged) {\n              dependencyMap.forEach((s) => s.delete(dependent));\n            }\n          }\n          loop2(dependent);\n        }\n      });\n    };\n    loop2(atom2);\n  };\n  const writeAtomState = (atom2, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom2) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom2.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom2, ...args) => {\n    const result = writeAtomState(atom2, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom2, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom2)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom2);\n      } else {\n        if (a !== atom2) {\n          mountAtom(a, atom2, queue);\n        }\n      }\n    });\n    readAtomState(atom2);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom2, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom2);\n    }\n    if (isActuallyWritableAtom(atom2) && atom2.onMount) {\n      const { onMount } = atom2;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom2, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom2) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom2)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom2);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom2);\n    }\n    const atomState = getAtomState(atom2);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom2) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom2);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom2);\n    }\n  };\n  const mountDependencies = (atom2, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom2);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom2);\n      } else if (mountedMap.has(atom2)) {\n        mountAtom(a, atom2);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom2, prevAtomState]) => {\n        const atomState = getAtomState(atom2);\n        if (atomState) {\n          const mounted = mountedMap.get(atom2);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom2);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom2, listener) => {\n    const mounted = addAtom(atom2);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom2);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom2, valueOrPromise] of values) {\n          if (hasInitialValue(atom2)) {\n            setAtomValueOrPromise(atom2, valueOrPromise);\n            recomputeDependents(atom2);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nvar defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nvar getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\n// node_modules/jotai/esm/react.mjs\nvar import_react = __toESM(require_react(), 1);\nvar StoreContext = (0, import_react.createContext)(void 0);\nvar useStore = (options) => {\n  const store = (0, import_react.useContext)(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nvar Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = (0, import_react.useRef)();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return (0, import_react.createElement)(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\nvar isPromiseLike2 = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nvar use = import_react.default.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom2, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, import_react.useReducer)(\n    (prev) => {\n      const nextValue = store.get(atom2);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {\n        return prev;\n      }\n      return [nextValue, store, atom2];\n    },\n    void 0,\n    () => [store.get(atom2), store, atom2]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom2) {\n    rerender();\n    value = store.get(atom2);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  (0, import_react.useEffect)(() => {\n    const unsub = store.sub(atom2, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom2, delay]);\n  (0, import_react.useDebugValue)(value);\n  return isPromiseLike2(value) ? use(value) : value;\n}\nfunction useSetAtom(atom2, options) {\n  const store = useStore(options);\n  const setAtom = (0, import_react.useCallback)(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom2)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom2, ...args);\n    },\n    [store, atom2]\n  );\n  return setAtom;\n}\nfunction useAtom(atom2, options) {\n  return [\n    useAtomValue(atom2, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom2, options)\n  ];\n}\nexport {\n  Provider,\n  atom,\n  createStore,\n  getDefaultStore,\n  useAtom,\n  useAtomValue,\n  useSetAtom,\n  useStore\n};\n//# sourceMappingURL=jotai.js.map\n",
      "start": 1701766112058,
      "end": 1701766112077,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1701766112077,
      "end": 1701766112077,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1701766112077,
      "end": 1701766112077,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1701766112077,
      "end": 1701766112078,
      "order": "normal"
    },
    {
      "name": "vite:react-swc",
      "start": 1701766112078,
      "end": 1701766112078,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1701766112078,
      "end": 1701766112078,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1701766112079,
      "end": 1701766112079,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1701766112079,
      "end": 1701766112079,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1701766112079,
      "end": 1701766112079,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1701766112079,
      "end": 1701766112079,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1701766112079,
      "end": 1701766112079,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1701766112079,
      "end": 1701766112079,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import.meta.env = {\"VITE_APP_NAME\":\"TourneyPro\",\"VITE_FIREBASE_CONFIG\":\"{\",\"BASE_URL\":\"/\",\"MODE\":\"development\",\"DEV\":true,\"PROD\":false,\"SSR\":false};import {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-ZGRSIX2Q.js?v=3c106fdb\";\nimport {\n  __toESM\n} from \"/node_modules/.vite/deps/chunk-ROME4SDB.js?v=3c106fdb\";\n\n// node_modules/jotai/esm/vanilla.mjs\nvar keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function(get) {\n      return get(this);\n    };\n    config.write = function(get, set, arg) {\n      return set(\n        this,\n        typeof arg === \"function\" ? arg(get(this)) : arg\n      );\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nvar hasInitialValue = (atom2) => \"init\" in atom2;\nvar isActuallyWritableAtom = (atom2) => !!atom2.write;\nvar cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nvar registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nvar cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nvar resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nvar rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nvar isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nvar isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nvar isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nvar hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nvar isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nvar returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nvar createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom2) => atomStateMap.get(atom2);\n  const setAtomState = (atom2, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom2);\n    atomStateMap.set(atom2, atomState);\n    if (!pendingMap.has(atom2)) {\n      pendingMap.set(atom2, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom2, nextAtomState, nextDependencies) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && a === atom2) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom2, value, nextDependencies) => {\n    const prevAtomState = getAtomState(atom2);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom2, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom2, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom2, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom2);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom2,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom2) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom2, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom2, promise, nextDependencies);\n    }\n    return setAtomValue(atom2, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom2, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom2);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom2, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom2, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom2, force) => {\n    const atomState = getAtomState(atom2);\n    if (!force && atomState) {\n      if (mountedMap.has(atom2)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom2) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (a === atom2) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom2)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom2)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom2, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom2.read(getter, options);\n      return setAtomValueOrPromise(\n        atom2,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom2, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom2) => returnAtomValue(readAtomState(atom2));\n  const addAtom = (atom2) => {\n    let mounted = mountedMap.get(atom2);\n    if (!mounted) {\n      mounted = mountAtom(atom2);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom2, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom2));\n  const delAtom = (atom2) => {\n    const mounted = mountedMap.get(atom2);\n    if (mounted && canUnmountAtom(atom2, mounted)) {\n      unmountAtom(atom2);\n    }\n  };\n  const recomputeDependents = (atom2) => {\n    const dependencyMap = /* @__PURE__ */ new Map();\n    const dirtyMap = /* @__PURE__ */ new WeakMap();\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const loop1 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        if (dependent !== a) {\n          dependencyMap.set(\n            dependent,\n            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a)\n          );\n          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);\n          loop1(dependent);\n        }\n      });\n    };\n    loop1(atom2);\n    const loop2 = (a) => {\n      getDependents(a).forEach((dependent) => {\n        var _a;\n        if (dependent !== a) {\n          let dirtyCount = dirtyMap.get(dependent);\n          if (dirtyCount) {\n            dirtyMap.set(dependent, --dirtyCount);\n          }\n          if (!dirtyCount) {\n            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);\n            if (isChanged) {\n              const prevAtomState = getAtomState(dependent);\n              const nextAtomState = readAtomState(dependent, true);\n              isChanged = !isEqualAtomValue(prevAtomState, nextAtomState);\n            }\n            if (!isChanged) {\n              dependencyMap.forEach((s) => s.delete(dependent));\n            }\n          }\n          loop2(dependent);\n        }\n      });\n    };\n    loop2(atom2);\n  };\n  const writeAtomState = (atom2, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom2) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom2.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom2, ...args) => {\n    const result = writeAtomState(atom2, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom2, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom2)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom2);\n      } else {\n        if (a !== atom2) {\n          mountAtom(a, atom2, queue);\n        }\n      }\n    });\n    readAtomState(atom2);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom2, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom2);\n    }\n    if (isActuallyWritableAtom(atom2) && atom2.onMount) {\n      const { onMount } = atom2;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom2, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom2) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom2)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom2);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom2);\n    }\n    const atomState = getAtomState(atom2);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom2) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom2);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom2);\n    }\n  };\n  const mountDependencies = (atom2, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom2);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom2);\n      } else if (mountedMap.has(atom2)) {\n        mountAtom(a, atom2);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom2, prevAtomState]) => {\n        const atomState = getAtomState(atom2);\n        if (atomState) {\n          const mounted = mountedMap.get(atom2);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom2);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom2, listener) => {\n    const mounted = addAtom(atom2);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom2);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom2, valueOrPromise] of values) {\n          if (hasInitialValue(atom2)) {\n            setAtomValueOrPromise(atom2, valueOrPromise);\n            recomputeDependents(atom2);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nvar defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nvar getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\n// node_modules/jotai/esm/react.mjs\nvar import_react = __toESM(require_react(), 1);\nvar StoreContext = (0, import_react.createContext)(void 0);\nvar useStore = (options) => {\n  const store = (0, import_react.useContext)(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nvar Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = (0, import_react.useRef)();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return (0, import_react.createElement)(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\nvar isPromiseLike2 = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nvar use = import_react.default.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom2, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, import_react.useReducer)(\n    (prev) => {\n      const nextValue = store.get(atom2);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {\n        return prev;\n      }\n      return [nextValue, store, atom2];\n    },\n    void 0,\n    () => [store.get(atom2), store, atom2]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom2) {\n    rerender();\n    value = store.get(atom2);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  (0, import_react.useEffect)(() => {\n    const unsub = store.sub(atom2, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom2, delay]);\n  (0, import_react.useDebugValue)(value);\n  return isPromiseLike2(value) ? use(value) : value;\n}\nfunction useSetAtom(atom2, options) {\n  const store = useStore(options);\n  const setAtom = (0, import_react.useCallback)(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom2)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom2, ...args);\n    },\n    [store, atom2]\n  );\n  return setAtom;\n}\nfunction useAtom(atom2, options) {\n  return [\n    useAtomValue(atom2, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom2, options)\n  ];\n}\nexport {\n  Provider,\n  atom,\n  createStore,\n  getDefaultStore,\n  useAtom,\n  useAtomValue,\n  useSetAtom,\n  useStore\n};\n//# sourceMappingURL=jotai.js.map\n",
      "start": 1701766112079,
      "end": 1701766112081,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
