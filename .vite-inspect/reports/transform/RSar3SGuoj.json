{
  "resolvedId": "C:/Users/ryan.wong/Desktop/dev/TourneyPro_v2/node_modules/.vite/deps/react-slick.js?v=3c106fdb",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "import {\n  require_react\n} from \"./chunk-ZGRSIX2Q.js\";\nimport {\n  __commonJS,\n  __esm,\n  __export,\n  __toCommonJS\n} from \"./chunk-ROME4SDB.js\";\n\n// node_modules/react-slick/lib/initial-state.js\nvar require_initial_state = __commonJS({\n  \"node_modules/react-slick/lib/initial-state.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var initialState = {\n      animating: false,\n      autoplaying: null,\n      currentDirection: 0,\n      currentLeft: null,\n      currentSlide: 0,\n      direction: 1,\n      dragging: false,\n      edgeDragged: false,\n      initialized: false,\n      lazyLoadedList: [],\n      listHeight: null,\n      listWidth: null,\n      scrolling: false,\n      slideCount: null,\n      slideHeight: null,\n      slideWidth: null,\n      swipeLeft: null,\n      swiped: false,\n      // used by swipeEvent. differentites between touch and swipe.\n      swiping: false,\n      touchObject: {\n        startX: 0,\n        startY: 0,\n        curX: 0,\n        curY: 0\n      },\n      trackStyle: {},\n      trackWidth: 0,\n      targetSlide: 0\n    };\n    var _default = initialState;\n    exports[\"default\"] = _default;\n  }\n});\n\n// node_modules/lodash.debounce/index.js\nvar require_lodash = __commonJS({\n  \"node_modules/lodash.debounce/index.js\"(exports, module) {\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    var NAN = 0 / 0;\n    var symbolTag = \"[object Symbol]\";\n    var reTrim = /^\\s+|\\s+$/g;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var objectProto = Object.prototype;\n    var objectToString = objectProto.toString;\n    var nativeMax = Math.max;\n    var nativeMin = Math.min;\n    var now = function() {\n      return root.Date.now();\n    };\n    function debounce(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, \"\");\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module.exports = debounce;\n  }\n});\n\n// node_modules/classnames/index.js\nvar require_classnames = __commonJS({\n  \"node_modules/classnames/index.js\"(exports, module) {\n    (function() {\n      \"use strict\";\n      var hasOwn = {}.hasOwnProperty;\n      var nativeCodeString = \"[native code]\";\n      function classNames() {\n        var classes = [];\n        for (var i = 0; i < arguments.length; i++) {\n          var arg = arguments[i];\n          if (!arg)\n            continue;\n          var argType = typeof arg;\n          if (argType === \"string\" || argType === \"number\") {\n            classes.push(arg);\n          } else if (Array.isArray(arg)) {\n            if (arg.length) {\n              var inner = classNames.apply(null, arg);\n              if (inner) {\n                classes.push(inner);\n              }\n            }\n          } else if (argType === \"object\") {\n            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes(\"[native code]\")) {\n              classes.push(arg.toString());\n              continue;\n            }\n            for (var key in arg) {\n              if (hasOwn.call(arg, key) && arg[key]) {\n                classes.push(key);\n              }\n            }\n          }\n        }\n        return classes.join(\" \");\n      }\n      if (typeof module !== \"undefined\" && module.exports) {\n        classNames.default = classNames;\n        module.exports = classNames;\n      } else if (typeof define === \"function\" && typeof define.amd === \"object\" && define.amd) {\n        define(\"classnames\", [], function() {\n          return classNames;\n        });\n      } else {\n        window.classNames = classNames;\n      }\n    })();\n  }\n});\n\n// node_modules/react-slick/lib/utils/innerSliderUtils.js\nvar require_innerSliderUtils = __commonJS({\n  \"node_modules/react-slick/lib/utils/innerSliderUtils.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.checkSpecKeys = exports.checkNavigable = exports.changeSlide = exports.canUseDOM = exports.canGoNext = void 0;\n    exports.clamp = clamp;\n    exports.swipeStart = exports.swipeMove = exports.swipeEnd = exports.slidesOnRight = exports.slidesOnLeft = exports.slideHandler = exports.siblingDirection = exports.safePreventDefault = exports.lazyStartIndex = exports.lazySlidesOnRight = exports.lazySlidesOnLeft = exports.lazyEndIndex = exports.keyHandler = exports.initializedState = exports.getWidth = exports.getTrackLeft = exports.getTrackCSS = exports.getTrackAnimateCSS = exports.getTotalSlides = exports.getSwipeDirection = exports.getSlideCount = exports.getRequiredLazySlides = exports.getPreClones = exports.getPostClones = exports.getOnDemandLazySlides = exports.getNavigableIndexes = exports.getHeight = exports.extractObject = void 0;\n    var _react = _interopRequireDefault(require_react());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function clamp(number, lowerBound, upperBound) {\n      return Math.max(lowerBound, Math.min(number, upperBound));\n    }\n    var safePreventDefault = function safePreventDefault2(event) {\n      var passiveEvents = [\"onTouchStart\", \"onTouchMove\", \"onWheel\"];\n      if (!passiveEvents.includes(event._reactName)) {\n        event.preventDefault();\n      }\n    };\n    exports.safePreventDefault = safePreventDefault;\n    var getOnDemandLazySlides = function getOnDemandLazySlides2(spec) {\n      var onDemandSlides = [];\n      var startIndex = lazyStartIndex(spec);\n      var endIndex = lazyEndIndex(spec);\n      for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n        if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n          onDemandSlides.push(slideIndex);\n        }\n      }\n      return onDemandSlides;\n    };\n    exports.getOnDemandLazySlides = getOnDemandLazySlides;\n    var getRequiredLazySlides = function getRequiredLazySlides2(spec) {\n      var requiredSlides = [];\n      var startIndex = lazyStartIndex(spec);\n      var endIndex = lazyEndIndex(spec);\n      for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n        requiredSlides.push(slideIndex);\n      }\n      return requiredSlides;\n    };\n    exports.getRequiredLazySlides = getRequiredLazySlides;\n    var lazyStartIndex = function lazyStartIndex2(spec) {\n      return spec.currentSlide - lazySlidesOnLeft(spec);\n    };\n    exports.lazyStartIndex = lazyStartIndex;\n    var lazyEndIndex = function lazyEndIndex2(spec) {\n      return spec.currentSlide + lazySlidesOnRight(spec);\n    };\n    exports.lazyEndIndex = lazyEndIndex;\n    var lazySlidesOnLeft = function lazySlidesOnLeft2(spec) {\n      return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\n    };\n    exports.lazySlidesOnLeft = lazySlidesOnLeft;\n    var lazySlidesOnRight = function lazySlidesOnRight2(spec) {\n      return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n    };\n    exports.lazySlidesOnRight = lazySlidesOnRight;\n    var getWidth = function getWidth2(elem) {\n      return elem && elem.offsetWidth || 0;\n    };\n    exports.getWidth = getWidth;\n    var getHeight = function getHeight2(elem) {\n      return elem && elem.offsetHeight || 0;\n    };\n    exports.getHeight = getHeight;\n    var getSwipeDirection = function getSwipeDirection2(touchObject) {\n      var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      var xDist, yDist, r, swipeAngle;\n      xDist = touchObject.startX - touchObject.curX;\n      yDist = touchObject.startY - touchObject.curY;\n      r = Math.atan2(yDist, xDist);\n      swipeAngle = Math.round(r * 180 / Math.PI);\n      if (swipeAngle < 0) {\n        swipeAngle = 360 - Math.abs(swipeAngle);\n      }\n      if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n        return \"left\";\n      }\n      if (swipeAngle >= 135 && swipeAngle <= 225) {\n        return \"right\";\n      }\n      if (verticalSwiping === true) {\n        if (swipeAngle >= 35 && swipeAngle <= 135) {\n          return \"up\";\n        } else {\n          return \"down\";\n        }\n      }\n      return \"vertical\";\n    };\n    exports.getSwipeDirection = getSwipeDirection;\n    var canGoNext = function canGoNext2(spec) {\n      var canGo = true;\n      if (!spec.infinite) {\n        if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n          canGo = false;\n        } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n          canGo = false;\n        }\n      }\n      return canGo;\n    };\n    exports.canGoNext = canGoNext;\n    var extractObject = function extractObject2(spec, keys) {\n      var newObject = {};\n      keys.forEach(function(key) {\n        return newObject[key] = spec[key];\n      });\n      return newObject;\n    };\n    exports.extractObject = extractObject;\n    var initializedState = function initializedState2(spec) {\n      var slideCount = _react[\"default\"].Children.count(spec.children);\n      var listNode = spec.listRef;\n      var listWidth = Math.ceil(getWidth(listNode));\n      var trackNode = spec.trackRef && spec.trackRef.node;\n      var trackWidth = Math.ceil(getWidth(trackNode));\n      var slideWidth;\n      if (!spec.vertical) {\n        var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n        if (typeof spec.centerPadding === \"string\" && spec.centerPadding.slice(-1) === \"%\") {\n          centerPaddingAdj *= listWidth / 100;\n        }\n        slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n      } else {\n        slideWidth = listWidth;\n      }\n      var slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'));\n      var listHeight = slideHeight * spec.slidesToShow;\n      var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;\n      if (spec.rtl && spec.currentSlide === void 0) {\n        currentSlide = slideCount - 1 - spec.initialSlide;\n      }\n      var lazyLoadedList = spec.lazyLoadedList || [];\n      var slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n        currentSlide,\n        lazyLoadedList\n      }));\n      lazyLoadedList = lazyLoadedList.concat(slidesToLoad);\n      var state = {\n        slideCount,\n        slideWidth,\n        listWidth,\n        trackWidth,\n        currentSlide,\n        slideHeight,\n        listHeight,\n        lazyLoadedList\n      };\n      if (spec.autoplaying === null && spec.autoplay) {\n        state[\"autoplaying\"] = \"playing\";\n      }\n      return state;\n    };\n    exports.initializedState = initializedState;\n    var slideHandler = function slideHandler2(spec) {\n      var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;\n      var lazyLoadedList = spec.lazyLoadedList;\n      if (waitForAnimate && animating)\n        return {};\n      var animationSlide = index2, finalSlide, animationLeft, finalLeft;\n      var state = {}, nextState = {};\n      var targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);\n      if (fade) {\n        if (!infinite && (index2 < 0 || index2 >= slideCount))\n          return {};\n        if (index2 < 0) {\n          animationSlide = index2 + slideCount;\n        } else if (index2 >= slideCount) {\n          animationSlide = index2 - slideCount;\n        }\n        if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n          lazyLoadedList = lazyLoadedList.concat(animationSlide);\n        }\n        state = {\n          animating: true,\n          currentSlide: animationSlide,\n          lazyLoadedList,\n          targetSlide: animationSlide\n        };\n        nextState = {\n          animating: false,\n          targetSlide: animationSlide\n        };\n      } else {\n        finalSlide = animationSlide;\n        if (animationSlide < 0) {\n          finalSlide = animationSlide + slideCount;\n          if (!infinite)\n            finalSlide = 0;\n          else if (slideCount % slidesToScroll !== 0)\n            finalSlide = slideCount - slideCount % slidesToScroll;\n        } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n          animationSlide = finalSlide = currentSlide;\n        } else if (centerMode && animationSlide >= slideCount) {\n          animationSlide = infinite ? slideCount : slideCount - 1;\n          finalSlide = infinite ? 0 : slideCount - 1;\n        } else if (animationSlide >= slideCount) {\n          finalSlide = animationSlide - slideCount;\n          if (!infinite)\n            finalSlide = slideCount - slidesToShow;\n          else if (slideCount % slidesToScroll !== 0)\n            finalSlide = 0;\n        }\n        if (!infinite && animationSlide + slidesToShow >= slideCount) {\n          finalSlide = slideCount - slidesToShow;\n        }\n        animationLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n          slideIndex: animationSlide\n        }));\n        finalLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n          slideIndex: finalSlide\n        }));\n        if (!infinite) {\n          if (animationLeft === finalLeft)\n            animationSlide = finalSlide;\n          animationLeft = finalLeft;\n        }\n        if (lazyLoad) {\n          lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n            currentSlide: animationSlide\n          })));\n        }\n        if (!useCSS) {\n          state = {\n            currentSlide: finalSlide,\n            trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n              left: finalLeft\n            })),\n            lazyLoadedList,\n            targetSlide\n          };\n        } else {\n          state = {\n            animating: true,\n            currentSlide: finalSlide,\n            trackStyle: getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n              left: animationLeft\n            })),\n            lazyLoadedList,\n            targetSlide\n          };\n          nextState = {\n            animating: false,\n            currentSlide: finalSlide,\n            trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n              left: finalLeft\n            })),\n            swipeLeft: null,\n            targetSlide\n          };\n        }\n      }\n      return {\n        state,\n        nextState\n      };\n    };\n    exports.slideHandler = slideHandler;\n    var changeSlide = function changeSlide2(spec, options) {\n      var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;\n      var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;\n      unevenOffset = slideCount % slidesToScroll !== 0;\n      indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n      if (options.message === \"previous\") {\n        slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n        targetSlide = currentSlide - slideOffset;\n        if (lazyLoad && !infinite) {\n          previousInt = currentSlide - slideOffset;\n          targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n        }\n        if (!infinite) {\n          targetSlide = previousTargetSlide - slidesToScroll;\n        }\n      } else if (options.message === \"next\") {\n        slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n        targetSlide = currentSlide + slideOffset;\n        if (lazyLoad && !infinite) {\n          targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n        }\n        if (!infinite) {\n          targetSlide = previousTargetSlide + slidesToScroll;\n        }\n      } else if (options.message === \"dots\") {\n        targetSlide = options.index * options.slidesToScroll;\n      } else if (options.message === \"children\") {\n        targetSlide = options.index;\n        if (infinite) {\n          var direction = siblingDirection(_objectSpread(_objectSpread({}, spec), {}, {\n            targetSlide\n          }));\n          if (targetSlide > options.currentSlide && direction === \"left\") {\n            targetSlide = targetSlide - slideCount;\n          } else if (targetSlide < options.currentSlide && direction === \"right\") {\n            targetSlide = targetSlide + slideCount;\n          }\n        }\n      } else if (options.message === \"index\") {\n        targetSlide = Number(options.index);\n      }\n      return targetSlide;\n    };\n    exports.changeSlide = changeSlide;\n    var keyHandler = function keyHandler2(e, accessibility, rtl) {\n      if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility)\n        return \"\";\n      if (e.keyCode === 37)\n        return rtl ? \"next\" : \"previous\";\n      if (e.keyCode === 39)\n        return rtl ? \"previous\" : \"next\";\n      return \"\";\n    };\n    exports.keyHandler = keyHandler;\n    var swipeStart = function swipeStart2(e, swipe, draggable) {\n      e.target.tagName === \"IMG\" && safePreventDefault(e);\n      if (!swipe || !draggable && e.type.indexOf(\"mouse\") !== -1)\n        return \"\";\n      return {\n        dragging: true,\n        touchObject: {\n          startX: e.touches ? e.touches[0].pageX : e.clientX,\n          startY: e.touches ? e.touches[0].pageY : e.clientY,\n          curX: e.touches ? e.touches[0].pageX : e.clientX,\n          curY: e.touches ? e.touches[0].pageY : e.clientY\n        }\n      };\n    };\n    exports.swipeStart = swipeStart;\n    var swipeMove = function swipeMove2(e, spec) {\n      var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;\n      if (scrolling)\n        return;\n      if (animating)\n        return safePreventDefault(e);\n      if (vertical && swipeToSlide && verticalSwiping)\n        safePreventDefault(e);\n      var swipeLeft, state = {};\n      var curLeft = getTrackLeft(spec);\n      touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n      touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n      touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n      var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n      if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n        return {\n          scrolling: true\n        };\n      }\n      if (verticalSwiping)\n        touchObject.swipeLength = verticalSwipeLength;\n      var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n      if (verticalSwiping)\n        positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n      var dotCount = Math.ceil(slideCount / slidesToScroll);\n      var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n      var touchSwipeLength = touchObject.swipeLength;\n      if (!infinite) {\n        if (currentSlide === 0 && (swipeDirection === \"right\" || swipeDirection === \"down\") || currentSlide + 1 >= dotCount && (swipeDirection === \"left\" || swipeDirection === \"up\") || !canGoNext(spec) && (swipeDirection === \"left\" || swipeDirection === \"up\")) {\n          touchSwipeLength = touchObject.swipeLength * edgeFriction;\n          if (edgeDragged === false && onEdge) {\n            onEdge(swipeDirection);\n            state[\"edgeDragged\"] = true;\n          }\n        }\n      }\n      if (!swiped && swipeEvent) {\n        swipeEvent(swipeDirection);\n        state[\"swiped\"] = true;\n      }\n      if (!vertical) {\n        if (!rtl) {\n          swipeLeft = curLeft + touchSwipeLength * positionOffset;\n        } else {\n          swipeLeft = curLeft - touchSwipeLength * positionOffset;\n        }\n      } else {\n        swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n      }\n      if (verticalSwiping) {\n        swipeLeft = curLeft + touchSwipeLength * positionOffset;\n      }\n      state = _objectSpread(_objectSpread({}, state), {}, {\n        touchObject,\n        swipeLeft,\n        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: swipeLeft\n        }))\n      });\n      if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n        return state;\n      }\n      if (touchObject.swipeLength > 10) {\n        state[\"swiping\"] = true;\n        safePreventDefault(e);\n      }\n      return state;\n    };\n    exports.swipeMove = swipeMove;\n    var swipeEnd = function swipeEnd2(e, spec) {\n      var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;\n      if (!dragging) {\n        if (swipe)\n          safePreventDefault(e);\n        return {};\n      }\n      var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n      var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);\n      var state = {\n        dragging: false,\n        edgeDragged: false,\n        scrolling: false,\n        swiping: false,\n        swiped: false,\n        swipeLeft: null,\n        touchObject: {}\n      };\n      if (scrolling) {\n        return state;\n      }\n      if (!touchObject.swipeLength) {\n        return state;\n      }\n      if (touchObject.swipeLength > minSwipe) {\n        safePreventDefault(e);\n        if (onSwipe) {\n          onSwipe(swipeDirection);\n        }\n        var slideCount, newSlide;\n        var activeSlide = infinite ? currentSlide : targetSlide;\n        switch (swipeDirection) {\n          case \"left\":\n          case \"up\":\n            newSlide = activeSlide + getSlideCount(spec);\n            slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n            state[\"currentDirection\"] = 0;\n            break;\n          case \"right\":\n          case \"down\":\n            newSlide = activeSlide - getSlideCount(spec);\n            slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n            state[\"currentDirection\"] = 1;\n            break;\n          default:\n            slideCount = activeSlide;\n        }\n        state[\"triggerSlideHandler\"] = slideCount;\n      } else {\n        var currentLeft = getTrackLeft(spec);\n        state[\"trackStyle\"] = getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: currentLeft\n        }));\n      }\n      return state;\n    };\n    exports.swipeEnd = swipeEnd;\n    var getNavigableIndexes = function getNavigableIndexes2(spec) {\n      var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n      var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n      var counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n      var indexes = [];\n      while (breakpoint < max) {\n        indexes.push(breakpoint);\n        breakpoint = counter + spec.slidesToScroll;\n        counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n      }\n      return indexes;\n    };\n    exports.getNavigableIndexes = getNavigableIndexes;\n    var checkNavigable = function checkNavigable2(spec, index2) {\n      var navigables = getNavigableIndexes(spec);\n      var prevNavigable = 0;\n      if (index2 > navigables[navigables.length - 1]) {\n        index2 = navigables[navigables.length - 1];\n      } else {\n        for (var n in navigables) {\n          if (index2 < navigables[n]) {\n            index2 = prevNavigable;\n            break;\n          }\n          prevNavigable = navigables[n];\n        }\n      }\n      return index2;\n    };\n    exports.checkNavigable = checkNavigable;\n    var getSlideCount = function getSlideCount2(spec) {\n      var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n      if (spec.swipeToSlide) {\n        var swipedSlide;\n        var slickList = spec.listRef;\n        var slides = slickList.querySelectorAll && slickList.querySelectorAll(\".slick-slide\") || [];\n        Array.from(slides).every(function(slide) {\n          if (!spec.vertical) {\n            if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n              swipedSlide = slide;\n              return false;\n            }\n          } else {\n            if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n              swipedSlide = slide;\n              return false;\n            }\n          }\n          return true;\n        });\n        if (!swipedSlide) {\n          return 0;\n        }\n        var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n        var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n        return slidesTraversed;\n      } else {\n        return spec.slidesToScroll;\n      }\n    };\n    exports.getSlideCount = getSlideCount;\n    var checkSpecKeys = function checkSpecKeys2(spec, keysArray) {\n      return keysArray.reduce(function(value, key) {\n        return value && spec.hasOwnProperty(key);\n      }, true) ? null : console.error(\"Keys Missing:\", spec);\n    };\n    exports.checkSpecKeys = checkSpecKeys;\n    var getTrackCSS = function getTrackCSS2(spec) {\n      checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\"]);\n      var trackWidth, trackHeight;\n      var trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n      if (!spec.vertical) {\n        trackWidth = getTotalSlides(spec) * spec.slideWidth;\n      } else {\n        trackHeight = trackChildren * spec.slideHeight;\n      }\n      var style = {\n        opacity: 1,\n        transition: \"\",\n        WebkitTransition: \"\"\n      };\n      if (spec.useTransform) {\n        var WebkitTransform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n        var transform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n        var msTransform = !spec.vertical ? \"translateX(\" + spec.left + \"px)\" : \"translateY(\" + spec.left + \"px)\";\n        style = _objectSpread(_objectSpread({}, style), {}, {\n          WebkitTransform,\n          transform,\n          msTransform\n        });\n      } else {\n        if (spec.vertical) {\n          style[\"top\"] = spec.left;\n        } else {\n          style[\"left\"] = spec.left;\n        }\n      }\n      if (spec.fade)\n        style = {\n          opacity: 1\n        };\n      if (trackWidth)\n        style.width = trackWidth;\n      if (trackHeight)\n        style.height = trackHeight;\n      if (window && !window.addEventListener && window.attachEvent) {\n        if (!spec.vertical) {\n          style.marginLeft = spec.left + \"px\";\n        } else {\n          style.marginTop = spec.left + \"px\";\n        }\n      }\n      return style;\n    };\n    exports.getTrackCSS = getTrackCSS;\n    var getTrackAnimateCSS = function getTrackAnimateCSS2(spec) {\n      checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\", \"speed\", \"cssEase\"]);\n      var style = getTrackCSS(spec);\n      if (spec.useTransform) {\n        style.WebkitTransition = \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase;\n        style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase;\n      } else {\n        if (spec.vertical) {\n          style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase;\n        } else {\n          style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase;\n        }\n      }\n      return style;\n    };\n    exports.getTrackAnimateCSS = getTrackAnimateCSS;\n    var getTrackLeft = function getTrackLeft2(spec) {\n      if (spec.unslick) {\n        return 0;\n      }\n      checkSpecKeys(spec, [\"slideIndex\", \"trackRef\", \"infinite\", \"centerMode\", \"slideCount\", \"slidesToShow\", \"slidesToScroll\", \"slideWidth\", \"listWidth\", \"variableWidth\", \"slideHeight\"]);\n      var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;\n      var slideOffset = 0;\n      var targetLeft;\n      var targetSlide;\n      var verticalOffset = 0;\n      if (fade || spec.slideCount === 1) {\n        return 0;\n      }\n      var slidesToOffset = 0;\n      if (infinite) {\n        slidesToOffset = -getPreClones(spec);\n        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n          slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n        }\n        if (centerMode) {\n          slidesToOffset += parseInt(slidesToShow / 2);\n        }\n      } else {\n        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n          slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n        }\n        if (centerMode) {\n          slidesToOffset = parseInt(slidesToShow / 2);\n        }\n      }\n      slideOffset = slidesToOffset * slideWidth;\n      verticalOffset = slidesToOffset * slideHeight;\n      if (!vertical) {\n        targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n      } else {\n        targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n      }\n      if (variableWidth === true) {\n        var targetSlideIndex;\n        var trackElem = trackRef && trackRef.node;\n        targetSlideIndex = slideIndex + getPreClones(spec);\n        targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n        targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n        if (centerMode === true) {\n          targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n          targetSlide = trackElem && trackElem.children[targetSlideIndex];\n          targetLeft = 0;\n          for (var slide = 0; slide < targetSlideIndex; slide++) {\n            targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n          }\n          targetLeft -= parseInt(spec.centerPadding);\n          targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n        }\n      }\n      return targetLeft;\n    };\n    exports.getTrackLeft = getTrackLeft;\n    var getPreClones = function getPreClones2(spec) {\n      if (spec.unslick || !spec.infinite) {\n        return 0;\n      }\n      if (spec.variableWidth) {\n        return spec.slideCount;\n      }\n      return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n    };\n    exports.getPreClones = getPreClones;\n    var getPostClones = function getPostClones2(spec) {\n      if (spec.unslick || !spec.infinite) {\n        return 0;\n      }\n      return spec.slideCount;\n    };\n    exports.getPostClones = getPostClones;\n    var getTotalSlides = function getTotalSlides2(spec) {\n      return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\n    };\n    exports.getTotalSlides = getTotalSlides;\n    var siblingDirection = function siblingDirection2(spec) {\n      if (spec.targetSlide > spec.currentSlide) {\n        if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n          return \"left\";\n        }\n        return \"right\";\n      } else {\n        if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n          return \"right\";\n        }\n        return \"left\";\n      }\n    };\n    exports.siblingDirection = siblingDirection;\n    var slidesOnRight = function slidesOnRight2(_ref) {\n      var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;\n      if (centerMode) {\n        var right = (slidesToShow - 1) / 2 + 1;\n        if (parseInt(centerPadding) > 0)\n          right += 1;\n        if (rtl && slidesToShow % 2 === 0)\n          right += 1;\n        return right;\n      }\n      if (rtl) {\n        return 0;\n      }\n      return slidesToShow - 1;\n    };\n    exports.slidesOnRight = slidesOnRight;\n    var slidesOnLeft = function slidesOnLeft2(_ref2) {\n      var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;\n      if (centerMode) {\n        var left = (slidesToShow - 1) / 2 + 1;\n        if (parseInt(centerPadding) > 0)\n          left += 1;\n        if (!rtl && slidesToShow % 2 === 0)\n          left += 1;\n        return left;\n      }\n      if (rtl) {\n        return slidesToShow - 1;\n      }\n      return 0;\n    };\n    exports.slidesOnLeft = slidesOnLeft;\n    var canUseDOM = function canUseDOM2() {\n      return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n    };\n    exports.canUseDOM = canUseDOM;\n  }\n});\n\n// node_modules/react-slick/lib/track.js\nvar require_track = __commonJS({\n  \"node_modules/react-slick/lib/track.js\"(exports) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.Track = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _classnames = _interopRequireDefault(require_classnames());\n    var _innerSliderUtils = require_innerSliderUtils();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var getSlideClasses = function getSlideClasses2(spec) {\n      var slickActive, slickCenter, slickCloned;\n      var centerOffset, index2;\n      if (spec.rtl) {\n        index2 = spec.slideCount - 1 - spec.index;\n      } else {\n        index2 = spec.index;\n      }\n      slickCloned = index2 < 0 || index2 >= spec.slideCount;\n      if (spec.centerMode) {\n        centerOffset = Math.floor(spec.slidesToShow / 2);\n        slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;\n        if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {\n          slickActive = true;\n        }\n      } else {\n        slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;\n      }\n      var focusedSlide;\n      if (spec.targetSlide < 0) {\n        focusedSlide = spec.targetSlide + spec.slideCount;\n      } else if (spec.targetSlide >= spec.slideCount) {\n        focusedSlide = spec.targetSlide - spec.slideCount;\n      } else {\n        focusedSlide = spec.targetSlide;\n      }\n      var slickCurrent = index2 === focusedSlide;\n      return {\n        \"slick-slide\": true,\n        \"slick-active\": slickActive,\n        \"slick-center\": slickCenter,\n        \"slick-cloned\": slickCloned,\n        \"slick-current\": slickCurrent\n        // dubious in case of RTL\n      };\n    };\n    var getSlideStyle = function getSlideStyle2(spec) {\n      var style = {};\n      if (spec.variableWidth === void 0 || spec.variableWidth === false) {\n        style.width = spec.slideWidth;\n      }\n      if (spec.fade) {\n        style.position = \"relative\";\n        if (spec.vertical) {\n          style.top = -spec.index * parseInt(spec.slideHeight);\n        } else {\n          style.left = -spec.index * parseInt(spec.slideWidth);\n        }\n        style.opacity = spec.currentSlide === spec.index ? 1 : 0;\n        if (spec.useCSS) {\n          style.transition = \"opacity \" + spec.speed + \"ms \" + spec.cssEase + \", visibility \" + spec.speed + \"ms \" + spec.cssEase;\n        }\n      }\n      return style;\n    };\n    var getKey = function getKey2(child, fallbackKey) {\n      return child.key || fallbackKey;\n    };\n    var renderSlides = function renderSlides2(spec) {\n      var key;\n      var slides = [];\n      var preCloneSlides = [];\n      var postCloneSlides = [];\n      var childrenCount = _react[\"default\"].Children.count(spec.children);\n      var startIndex = (0, _innerSliderUtils.lazyStartIndex)(spec);\n      var endIndex = (0, _innerSliderUtils.lazyEndIndex)(spec);\n      _react[\"default\"].Children.forEach(spec.children, function(elem, index2) {\n        var child;\n        var childOnClickOptions = {\n          message: \"children\",\n          index: index2,\n          slidesToScroll: spec.slidesToScroll,\n          currentSlide: spec.currentSlide\n        };\n        if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {\n          child = elem;\n        } else {\n          child = _react[\"default\"].createElement(\"div\", null);\n        }\n        var childStyle = getSlideStyle(_objectSpread(_objectSpread({}, spec), {}, {\n          index: index2\n        }));\n        var slideClass = child.props.className || \"\";\n        var slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n          index: index2\n        }));\n        slides.push(_react[\"default\"].cloneElement(child, {\n          key: \"original\" + getKey(child, index2),\n          \"data-index\": index2,\n          className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n          tabIndex: \"-1\",\n          \"aria-hidden\": !slideClasses[\"slick-active\"],\n          style: _objectSpread(_objectSpread({\n            outline: \"none\"\n          }, child.props.style || {}), childStyle),\n          onClick: function onClick(e) {\n            child.props && child.props.onClick && child.props.onClick(e);\n            if (spec.focusOnSelect) {\n              spec.focusOnSelect(childOnClickOptions);\n            }\n          }\n        }));\n        if (spec.infinite && spec.fade === false) {\n          var preCloneNo = childrenCount - index2;\n          if (preCloneNo <= (0, _innerSliderUtils.getPreClones)(spec) && childrenCount !== spec.slidesToShow) {\n            key = -preCloneNo;\n            if (key >= startIndex) {\n              child = elem;\n            }\n            slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n              index: key\n            }));\n            preCloneSlides.push(_react[\"default\"].cloneElement(child, {\n              key: \"precloned\" + getKey(child, key),\n              \"data-index\": key,\n              tabIndex: \"-1\",\n              className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n              \"aria-hidden\": !slideClasses[\"slick-active\"],\n              style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n              onClick: function onClick(e) {\n                child.props && child.props.onClick && child.props.onClick(e);\n                if (spec.focusOnSelect) {\n                  spec.focusOnSelect(childOnClickOptions);\n                }\n              }\n            }));\n          }\n          if (childrenCount !== spec.slidesToShow) {\n            key = childrenCount + index2;\n            if (key < endIndex) {\n              child = elem;\n            }\n            slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n              index: key\n            }));\n            postCloneSlides.push(_react[\"default\"].cloneElement(child, {\n              key: \"postcloned\" + getKey(child, key),\n              \"data-index\": key,\n              tabIndex: \"-1\",\n              className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n              \"aria-hidden\": !slideClasses[\"slick-active\"],\n              style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n              onClick: function onClick(e) {\n                child.props && child.props.onClick && child.props.onClick(e);\n                if (spec.focusOnSelect) {\n                  spec.focusOnSelect(childOnClickOptions);\n                }\n              }\n            }));\n          }\n        }\n      });\n      if (spec.rtl) {\n        return preCloneSlides.concat(slides, postCloneSlides).reverse();\n      } else {\n        return preCloneSlides.concat(slides, postCloneSlides);\n      }\n    };\n    var Track = function(_React$PureComponent) {\n      _inherits(Track2, _React$PureComponent);\n      var _super = _createSuper(Track2);\n      function Track2() {\n        var _this;\n        _classCallCheck(this, Track2);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [this].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"node\", null);\n        _defineProperty(_assertThisInitialized(_this), \"handleRef\", function(ref) {\n          _this.node = ref;\n        });\n        return _this;\n      }\n      _createClass(Track2, [{\n        key: \"render\",\n        value: function render() {\n          var slides = renderSlides(this.props);\n          var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;\n          var mouseEvents = {\n            onMouseEnter,\n            onMouseOver,\n            onMouseLeave\n          };\n          return _react[\"default\"].createElement(\"div\", _extends({\n            ref: this.handleRef,\n            className: \"slick-track\",\n            style: this.props.trackStyle\n          }, mouseEvents), slides);\n        }\n      }]);\n      return Track2;\n    }(_react[\"default\"].PureComponent);\n    exports.Track = Track;\n  }\n});\n\n// node_modules/react-slick/lib/dots.js\nvar require_dots = __commonJS({\n  \"node_modules/react-slick/lib/dots.js\"(exports) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.Dots = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _classnames = _interopRequireDefault(require_classnames());\n    var _innerSliderUtils = require_innerSliderUtils();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    var getDotCount = function getDotCount2(spec) {\n      var dots;\n      if (spec.infinite) {\n        dots = Math.ceil(spec.slideCount / spec.slidesToScroll);\n      } else {\n        dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;\n      }\n      return dots;\n    };\n    var Dots = function(_React$PureComponent) {\n      _inherits(Dots2, _React$PureComponent);\n      var _super = _createSuper(Dots2);\n      function Dots2() {\n        _classCallCheck(this, Dots2);\n        return _super.apply(this, arguments);\n      }\n      _createClass(Dots2, [{\n        key: \"clickHandler\",\n        value: function clickHandler(options, e) {\n          e.preventDefault();\n          this.props.clickHandler(options);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;\n          var dotCount = getDotCount({\n            slideCount,\n            slidesToScroll,\n            slidesToShow,\n            infinite\n          });\n          var mouseEvents = {\n            onMouseEnter,\n            onMouseOver,\n            onMouseLeave\n          };\n          var dots = [];\n          for (var i = 0; i < dotCount; i++) {\n            var _rightBound = (i + 1) * slidesToScroll - 1;\n            var rightBound = infinite ? _rightBound : (0, _innerSliderUtils.clamp)(_rightBound, 0, slideCount - 1);\n            var _leftBound = rightBound - (slidesToScroll - 1);\n            var leftBound = infinite ? _leftBound : (0, _innerSliderUtils.clamp)(_leftBound, 0, slideCount - 1);\n            var className = (0, _classnames[\"default\"])({\n              \"slick-active\": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound\n            });\n            var dotOptions = {\n              message: \"dots\",\n              index: i,\n              slidesToScroll,\n              currentSlide\n            };\n            var onClick = this.clickHandler.bind(this, dotOptions);\n            dots = dots.concat(_react[\"default\"].createElement(\"li\", {\n              key: i,\n              className\n            }, _react[\"default\"].cloneElement(this.props.customPaging(i), {\n              onClick\n            })));\n          }\n          return _react[\"default\"].cloneElement(this.props.appendDots(dots), _objectSpread({\n            className: this.props.dotsClass\n          }, mouseEvents));\n        }\n      }]);\n      return Dots2;\n    }(_react[\"default\"].PureComponent);\n    exports.Dots = Dots;\n  }\n});\n\n// node_modules/react-slick/lib/arrows.js\nvar require_arrows = __commonJS({\n  \"node_modules/react-slick/lib/arrows.js\"(exports) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.PrevArrow = exports.NextArrow = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _classnames = _interopRequireDefault(require_classnames());\n    var _innerSliderUtils = require_innerSliderUtils();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    var PrevArrow = function(_React$PureComponent) {\n      _inherits(PrevArrow2, _React$PureComponent);\n      var _super = _createSuper(PrevArrow2);\n      function PrevArrow2() {\n        _classCallCheck(this, PrevArrow2);\n        return _super.apply(this, arguments);\n      }\n      _createClass(PrevArrow2, [{\n        key: \"clickHandler\",\n        value: function clickHandler(options, e) {\n          if (e) {\n            e.preventDefault();\n          }\n          this.props.clickHandler(options, e);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var prevClasses = {\n            \"slick-arrow\": true,\n            \"slick-prev\": true\n          };\n          var prevHandler = this.clickHandler.bind(this, {\n            message: \"previous\"\n          });\n          if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {\n            prevClasses[\"slick-disabled\"] = true;\n            prevHandler = null;\n          }\n          var prevArrowProps = {\n            key: \"0\",\n            \"data-role\": \"none\",\n            className: (0, _classnames[\"default\"])(prevClasses),\n            style: {\n              display: \"block\"\n            },\n            onClick: prevHandler\n          };\n          var customProps = {\n            currentSlide: this.props.currentSlide,\n            slideCount: this.props.slideCount\n          };\n          var prevArrow;\n          if (this.props.prevArrow) {\n            prevArrow = _react[\"default\"].cloneElement(this.props.prevArrow, _objectSpread(_objectSpread({}, prevArrowProps), customProps));\n          } else {\n            prevArrow = _react[\"default\"].createElement(\"button\", _extends({\n              key: \"0\",\n              type: \"button\"\n            }, prevArrowProps), \" \", \"Previous\");\n          }\n          return prevArrow;\n        }\n      }]);\n      return PrevArrow2;\n    }(_react[\"default\"].PureComponent);\n    exports.PrevArrow = PrevArrow;\n    var NextArrow = function(_React$PureComponent2) {\n      _inherits(NextArrow2, _React$PureComponent2);\n      var _super2 = _createSuper(NextArrow2);\n      function NextArrow2() {\n        _classCallCheck(this, NextArrow2);\n        return _super2.apply(this, arguments);\n      }\n      _createClass(NextArrow2, [{\n        key: \"clickHandler\",\n        value: function clickHandler(options, e) {\n          if (e) {\n            e.preventDefault();\n          }\n          this.props.clickHandler(options, e);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var nextClasses = {\n            \"slick-arrow\": true,\n            \"slick-next\": true\n          };\n          var nextHandler = this.clickHandler.bind(this, {\n            message: \"next\"\n          });\n          if (!(0, _innerSliderUtils.canGoNext)(this.props)) {\n            nextClasses[\"slick-disabled\"] = true;\n            nextHandler = null;\n          }\n          var nextArrowProps = {\n            key: \"1\",\n            \"data-role\": \"none\",\n            className: (0, _classnames[\"default\"])(nextClasses),\n            style: {\n              display: \"block\"\n            },\n            onClick: nextHandler\n          };\n          var customProps = {\n            currentSlide: this.props.currentSlide,\n            slideCount: this.props.slideCount\n          };\n          var nextArrow;\n          if (this.props.nextArrow) {\n            nextArrow = _react[\"default\"].cloneElement(this.props.nextArrow, _objectSpread(_objectSpread({}, nextArrowProps), customProps));\n          } else {\n            nextArrow = _react[\"default\"].createElement(\"button\", _extends({\n              key: \"1\",\n              type: \"button\"\n            }, nextArrowProps), \" \", \"Next\");\n          }\n          return nextArrow;\n        }\n      }]);\n      return NextArrow2;\n    }(_react[\"default\"].PureComponent);\n    exports.NextArrow = NextArrow;\n  }\n});\n\n// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\nvar ResizeObserver_es_exports = {};\n__export(ResizeObserver_es_exports, {\n  default: () => ResizeObserver_es_default\n});\nfunction throttle(callback, delay) {\n  var leadingCall = false, trailingCall = false, lastCallTime = 0;\n  function resolvePending() {\n    if (leadingCall) {\n      leadingCall = false;\n      callback();\n    }\n    if (trailingCall) {\n      proxy();\n    }\n  }\n  function timeoutCallback() {\n    requestAnimationFrame$1(resolvePending);\n  }\n  function proxy() {\n    var timeStamp = Date.now();\n    if (leadingCall) {\n      if (timeStamp - lastCallTime < trailingTimeout) {\n        return;\n      }\n      trailingCall = true;\n    } else {\n      leadingCall = true;\n      trailingCall = false;\n      setTimeout(timeoutCallback, delay);\n    }\n    lastCallTime = timeStamp;\n  }\n  return proxy;\n}\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\nfunction getBordersSize(styles) {\n  var positions = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positions[_i - 1] = arguments[_i];\n  }\n  return positions.reduce(function(size, position) {\n    var value = styles[\"border-\" + position + \"-width\"];\n    return size + toFloat(value);\n  }, 0);\n}\nfunction getPaddings(styles) {\n  var positions = [\"top\", \"right\", \"bottom\", \"left\"];\n  var paddings = {};\n  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n    var position = positions_1[_i];\n    var value = styles[\"padding-\" + position];\n    paddings[position] = toFloat(value);\n  }\n  return paddings;\n}\nfunction getSVGContentRect(target) {\n  var bbox = target.getBBox();\n  return createRectInit(0, 0, bbox.width, bbox.height);\n}\nfunction getHTMLElementContentRect(target) {\n  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\n  if (!clientWidth && !clientHeight) {\n    return emptyRect;\n  }\n  var styles = getWindowOf(target).getComputedStyle(target);\n  var paddings = getPaddings(styles);\n  var horizPad = paddings.left + paddings.right;\n  var vertPad = paddings.top + paddings.bottom;\n  var width = toFloat(styles.width), height = toFloat(styles.height);\n  if (styles.boxSizing === \"border-box\") {\n    if (Math.round(width + horizPad) !== clientWidth) {\n      width -= getBordersSize(styles, \"left\", \"right\") + horizPad;\n    }\n    if (Math.round(height + vertPad) !== clientHeight) {\n      height -= getBordersSize(styles, \"top\", \"bottom\") + vertPad;\n    }\n  }\n  if (!isDocumentElement(target)) {\n    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n    var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n    if (Math.abs(vertScrollbar) !== 1) {\n      width -= vertScrollbar;\n    }\n    if (Math.abs(horizScrollbar) !== 1) {\n      height -= horizScrollbar;\n    }\n  }\n  return createRectInit(paddings.left, paddings.top, width, height);\n}\nfunction isDocumentElement(target) {\n  return target === getWindowOf(target).document.documentElement;\n}\nfunction getContentRect(target) {\n  if (!isBrowser) {\n    return emptyRect;\n  }\n  if (isSVGGraphicsElement(target)) {\n    return getSVGContentRect(target);\n  }\n  return getHTMLElementContentRect(target);\n}\nfunction createReadOnlyRect(_a) {\n  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n  var Constr = typeof DOMRectReadOnly !== \"undefined\" ? DOMRectReadOnly : Object;\n  var rect = Object.create(Constr.prototype);\n  defineConfigurable(rect, {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: height + y,\n    left: x\n  });\n  return rect;\n}\nfunction createRectInit(x, y, width, height) {\n  return { x, y, width, height };\n}\nvar MapShim, isBrowser, global$1, requestAnimationFrame$1, trailingTimeout, REFRESH_DELAY, transitionKeys, mutationObserverSupported, ResizeObserverController, defineConfigurable, getWindowOf, emptyRect, isSVGGraphicsElement, ResizeObservation, ResizeObserverEntry, ResizeObserverSPI, observers, ResizeObserver, index, ResizeObserver_es_default;\nvar init_ResizeObserver_es = __esm({\n  \"node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"() {\n    MapShim = function() {\n      if (typeof Map !== \"undefined\") {\n        return Map;\n      }\n      function getIndex(arr, key) {\n        var result = -1;\n        arr.some(function(entry, index2) {\n          if (entry[0] === key) {\n            result = index2;\n            return true;\n          }\n          return false;\n        });\n        return result;\n      }\n      return (\n        /** @class */\n        function() {\n          function class_1() {\n            this.__entries__ = [];\n          }\n          Object.defineProperty(class_1.prototype, \"size\", {\n            /**\n             * @returns {boolean}\n             */\n            get: function() {\n              return this.__entries__.length;\n            },\n            enumerable: true,\n            configurable: true\n          });\n          class_1.prototype.get = function(key) {\n            var index2 = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index2];\n            return entry && entry[1];\n          };\n          class_1.prototype.set = function(key, value) {\n            var index2 = getIndex(this.__entries__, key);\n            if (~index2) {\n              this.__entries__[index2][1] = value;\n            } else {\n              this.__entries__.push([key, value]);\n            }\n          };\n          class_1.prototype.delete = function(key) {\n            var entries = this.__entries__;\n            var index2 = getIndex(entries, key);\n            if (~index2) {\n              entries.splice(index2, 1);\n            }\n          };\n          class_1.prototype.has = function(key) {\n            return !!~getIndex(this.__entries__, key);\n          };\n          class_1.prototype.clear = function() {\n            this.__entries__.splice(0);\n          };\n          class_1.prototype.forEach = function(callback, ctx) {\n            if (ctx === void 0) {\n              ctx = null;\n            }\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n              var entry = _a[_i];\n              callback.call(ctx, entry[1], entry[0]);\n            }\n          };\n          return class_1;\n        }()\n      );\n    }();\n    isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.document === document;\n    global$1 = function() {\n      if (typeof global !== \"undefined\" && global.Math === Math) {\n        return global;\n      }\n      if (typeof self !== \"undefined\" && self.Math === Math) {\n        return self;\n      }\n      if (typeof window !== \"undefined\" && window.Math === Math) {\n        return window;\n      }\n      return Function(\"return this\")();\n    }();\n    requestAnimationFrame$1 = function() {\n      if (typeof requestAnimationFrame === \"function\") {\n        return requestAnimationFrame.bind(global$1);\n      }\n      return function(callback) {\n        return setTimeout(function() {\n          return callback(Date.now());\n        }, 1e3 / 60);\n      };\n    }();\n    trailingTimeout = 2;\n    REFRESH_DELAY = 20;\n    transitionKeys = [\"top\", \"right\", \"bottom\", \"left\", \"width\", \"height\", \"size\", \"weight\"];\n    mutationObserverSupported = typeof MutationObserver !== \"undefined\";\n    ResizeObserverController = /** @class */\n    function() {\n      function ResizeObserverController2() {\n        this.connected_ = false;\n        this.mutationEventsAdded_ = false;\n        this.mutationsObserver_ = null;\n        this.observers_ = [];\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n      }\n      ResizeObserverController2.prototype.addObserver = function(observer) {\n        if (!~this.observers_.indexOf(observer)) {\n          this.observers_.push(observer);\n        }\n        if (!this.connected_) {\n          this.connect_();\n        }\n      };\n      ResizeObserverController2.prototype.removeObserver = function(observer) {\n        var observers2 = this.observers_;\n        var index2 = observers2.indexOf(observer);\n        if (~index2) {\n          observers2.splice(index2, 1);\n        }\n        if (!observers2.length && this.connected_) {\n          this.disconnect_();\n        }\n      };\n      ResizeObserverController2.prototype.refresh = function() {\n        var changesDetected = this.updateObservers_();\n        if (changesDetected) {\n          this.refresh();\n        }\n      };\n      ResizeObserverController2.prototype.updateObservers_ = function() {\n        var activeObservers = this.observers_.filter(function(observer) {\n          return observer.gatherActive(), observer.hasActive();\n        });\n        activeObservers.forEach(function(observer) {\n          return observer.broadcastActive();\n        });\n        return activeObservers.length > 0;\n      };\n      ResizeObserverController2.prototype.connect_ = function() {\n        if (!isBrowser || this.connected_) {\n          return;\n        }\n        document.addEventListener(\"transitionend\", this.onTransitionEnd_);\n        window.addEventListener(\"resize\", this.refresh);\n        if (mutationObserverSupported) {\n          this.mutationsObserver_ = new MutationObserver(this.refresh);\n          this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n          });\n        } else {\n          document.addEventListener(\"DOMSubtreeModified\", this.refresh);\n          this.mutationEventsAdded_ = true;\n        }\n        this.connected_ = true;\n      };\n      ResizeObserverController2.prototype.disconnect_ = function() {\n        if (!isBrowser || !this.connected_) {\n          return;\n        }\n        document.removeEventListener(\"transitionend\", this.onTransitionEnd_);\n        window.removeEventListener(\"resize\", this.refresh);\n        if (this.mutationsObserver_) {\n          this.mutationsObserver_.disconnect();\n        }\n        if (this.mutationEventsAdded_) {\n          document.removeEventListener(\"DOMSubtreeModified\", this.refresh);\n        }\n        this.mutationsObserver_ = null;\n        this.mutationEventsAdded_ = false;\n        this.connected_ = false;\n      };\n      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {\n        var _b = _a.propertyName, propertyName = _b === void 0 ? \"\" : _b;\n        var isReflowProperty = transitionKeys.some(function(key) {\n          return !!~propertyName.indexOf(key);\n        });\n        if (isReflowProperty) {\n          this.refresh();\n        }\n      };\n      ResizeObserverController2.getInstance = function() {\n        if (!this.instance_) {\n          this.instance_ = new ResizeObserverController2();\n        }\n        return this.instance_;\n      };\n      ResizeObserverController2.instance_ = null;\n      return ResizeObserverController2;\n    }();\n    defineConfigurable = function(target, props) {\n      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n        var key = _a[_i];\n        Object.defineProperty(target, key, {\n          value: props[key],\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n      }\n      return target;\n    };\n    getWindowOf = function(target) {\n      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n      return ownerGlobal || global$1;\n    };\n    emptyRect = createRectInit(0, 0, 0, 0);\n    isSVGGraphicsElement = function() {\n      if (typeof SVGGraphicsElement !== \"undefined\") {\n        return function(target) {\n          return target instanceof getWindowOf(target).SVGGraphicsElement;\n        };\n      }\n      return function(target) {\n        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === \"function\";\n      };\n    }();\n    ResizeObservation = /** @class */\n    function() {\n      function ResizeObservation2(target) {\n        this.broadcastWidth = 0;\n        this.broadcastHeight = 0;\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\n        this.target = target;\n      }\n      ResizeObservation2.prototype.isActive = function() {\n        var rect = getContentRect(this.target);\n        this.contentRect_ = rect;\n        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n      };\n      ResizeObservation2.prototype.broadcastRect = function() {\n        var rect = this.contentRect_;\n        this.broadcastWidth = rect.width;\n        this.broadcastHeight = rect.height;\n        return rect;\n      };\n      return ResizeObservation2;\n    }();\n    ResizeObserverEntry = /** @class */\n    function() {\n      function ResizeObserverEntry2(target, rectInit) {\n        var contentRect = createReadOnlyRect(rectInit);\n        defineConfigurable(this, { target, contentRect });\n      }\n      return ResizeObserverEntry2;\n    }();\n    ResizeObserverSPI = /** @class */\n    function() {\n      function ResizeObserverSPI2(callback, controller, callbackCtx) {\n        this.activeObservations_ = [];\n        this.observations_ = new MapShim();\n        if (typeof callback !== \"function\") {\n          throw new TypeError(\"The callback provided as parameter 1 is not a function.\");\n        }\n        this.callback_ = callback;\n        this.controller_ = controller;\n        this.callbackCtx_ = callbackCtx;\n      }\n      ResizeObserverSPI2.prototype.observe = function(target) {\n        if (!arguments.length) {\n          throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        if (typeof Element === \"undefined\" || !(Element instanceof Object)) {\n          return;\n        }\n        if (!(target instanceof getWindowOf(target).Element)) {\n          throw new TypeError('parameter 1 is not of type \"Element\".');\n        }\n        var observations = this.observations_;\n        if (observations.has(target)) {\n          return;\n        }\n        observations.set(target, new ResizeObservation(target));\n        this.controller_.addObserver(this);\n        this.controller_.refresh();\n      };\n      ResizeObserverSPI2.prototype.unobserve = function(target) {\n        if (!arguments.length) {\n          throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        if (typeof Element === \"undefined\" || !(Element instanceof Object)) {\n          return;\n        }\n        if (!(target instanceof getWindowOf(target).Element)) {\n          throw new TypeError('parameter 1 is not of type \"Element\".');\n        }\n        var observations = this.observations_;\n        if (!observations.has(target)) {\n          return;\n        }\n        observations.delete(target);\n        if (!observations.size) {\n          this.controller_.removeObserver(this);\n        }\n      };\n      ResizeObserverSPI2.prototype.disconnect = function() {\n        this.clearActive();\n        this.observations_.clear();\n        this.controller_.removeObserver(this);\n      };\n      ResizeObserverSPI2.prototype.gatherActive = function() {\n        var _this = this;\n        this.clearActive();\n        this.observations_.forEach(function(observation) {\n          if (observation.isActive()) {\n            _this.activeObservations_.push(observation);\n          }\n        });\n      };\n      ResizeObserverSPI2.prototype.broadcastActive = function() {\n        if (!this.hasActive()) {\n          return;\n        }\n        var ctx = this.callbackCtx_;\n        var entries = this.activeObservations_.map(function(observation) {\n          return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n        });\n        this.callback_.call(ctx, entries, ctx);\n        this.clearActive();\n      };\n      ResizeObserverSPI2.prototype.clearActive = function() {\n        this.activeObservations_.splice(0);\n      };\n      ResizeObserverSPI2.prototype.hasActive = function() {\n        return this.activeObservations_.length > 0;\n      };\n      return ResizeObserverSPI2;\n    }();\n    observers = typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : new MapShim();\n    ResizeObserver = /** @class */\n    function() {\n      function ResizeObserver2(callback) {\n        if (!(this instanceof ResizeObserver2)) {\n          throw new TypeError(\"Cannot call a class as a function.\");\n        }\n        if (!arguments.length) {\n          throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        var controller = ResizeObserverController.getInstance();\n        var observer = new ResizeObserverSPI(callback, controller, this);\n        observers.set(this, observer);\n      }\n      return ResizeObserver2;\n    }();\n    [\n      \"observe\",\n      \"unobserve\",\n      \"disconnect\"\n    ].forEach(function(method) {\n      ResizeObserver.prototype[method] = function() {\n        var _a;\n        return (_a = observers.get(this))[method].apply(_a, arguments);\n      };\n    });\n    index = function() {\n      if (typeof global$1.ResizeObserver !== \"undefined\") {\n        return global$1.ResizeObserver;\n      }\n      return ResizeObserver;\n    }();\n    ResizeObserver_es_default = index;\n  }\n});\n\n// node_modules/react-slick/lib/inner-slider.js\nvar require_inner_slider = __commonJS({\n  \"node_modules/react-slick/lib/inner-slider.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.InnerSlider = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _initialState = _interopRequireDefault(require_initial_state());\n    var _lodash = _interopRequireDefault(require_lodash());\n    var _classnames = _interopRequireDefault(require_classnames());\n    var _innerSliderUtils = require_innerSliderUtils();\n    var _track = require_track();\n    var _dots = require_dots();\n    var _arrows = require_arrows();\n    var _resizeObserverPolyfill = _interopRequireDefault((init_ResizeObserver_es(), __toCommonJS(ResizeObserver_es_exports)));\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _objectWithoutProperties(source, excluded) {\n      if (source == null)\n        return {};\n      var target = _objectWithoutPropertiesLoose(source, excluded);\n      var key, i;\n      if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n          key = sourceSymbolKeys[i];\n          if (excluded.indexOf(key) >= 0)\n            continue;\n          if (!Object.prototype.propertyIsEnumerable.call(source, key))\n            continue;\n          target[key] = source[key];\n        }\n      }\n      return target;\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n      if (source == null)\n        return {};\n      var target = {};\n      var sourceKeys = Object.keys(source);\n      var key, i;\n      for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n          continue;\n        target[key] = source[key];\n      }\n      return target;\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var InnerSlider = function(_React$Component) {\n      _inherits(InnerSlider2, _React$Component);\n      var _super = _createSuper(InnerSlider2);\n      function InnerSlider2(props) {\n        var _this;\n        _classCallCheck(this, InnerSlider2);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"listRefHandler\", function(ref) {\n          return _this.list = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"trackRefHandler\", function(ref) {\n          return _this.track = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"adaptHeight\", function() {\n          if (_this.props.adaptiveHeight && _this.list) {\n            var elem = _this.list.querySelector('[data-index=\"'.concat(_this.state.currentSlide, '\"]'));\n            _this.list.style.height = (0, _innerSliderUtils.getHeight)(elem) + \"px\";\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function() {\n          _this.props.onInit && _this.props.onInit();\n          if (_this.props.lazyLoad) {\n            var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n            if (slidesToLoad.length > 0) {\n              _this.setState(function(prevState) {\n                return {\n                  lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n                };\n              });\n              if (_this.props.onLazyLoad) {\n                _this.props.onLazyLoad(slidesToLoad);\n              }\n            }\n          }\n          var spec = _objectSpread({\n            listRef: _this.list,\n            trackRef: _this.track\n          }, _this.props);\n          _this.updateState(spec, true, function() {\n            _this.adaptHeight();\n            _this.props.autoplay && _this.autoPlay(\"update\");\n          });\n          if (_this.props.lazyLoad === \"progressive\") {\n            _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);\n          }\n          _this.ro = new _resizeObserverPolyfill[\"default\"](function() {\n            if (_this.state.animating) {\n              _this.onWindowResized(false);\n              _this.callbackTimers.push(setTimeout(function() {\n                return _this.onWindowResized();\n              }, _this.props.speed));\n            } else {\n              _this.onWindowResized();\n            }\n          });\n          _this.ro.observe(_this.list);\n          document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(\".slick-slide\"), function(slide) {\n            slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;\n            slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;\n          });\n          if (window.addEventListener) {\n            window.addEventListener(\"resize\", _this.onWindowResized);\n          } else {\n            window.attachEvent(\"onresize\", _this.onWindowResized);\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentWillUnmount\", function() {\n          if (_this.animationEndCallback) {\n            clearTimeout(_this.animationEndCallback);\n          }\n          if (_this.lazyLoadTimer) {\n            clearInterval(_this.lazyLoadTimer);\n          }\n          if (_this.callbackTimers.length) {\n            _this.callbackTimers.forEach(function(timer) {\n              return clearTimeout(timer);\n            });\n            _this.callbackTimers = [];\n          }\n          if (window.addEventListener) {\n            window.removeEventListener(\"resize\", _this.onWindowResized);\n          } else {\n            window.detachEvent(\"onresize\", _this.onWindowResized);\n          }\n          if (_this.autoplayTimer) {\n            clearInterval(_this.autoplayTimer);\n          }\n          _this.ro.disconnect();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentDidUpdate\", function(prevProps) {\n          _this.checkImagesLoad();\n          _this.props.onReInit && _this.props.onReInit();\n          if (_this.props.lazyLoad) {\n            var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n            if (slidesToLoad.length > 0) {\n              _this.setState(function(prevState) {\n                return {\n                  lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n                };\n              });\n              if (_this.props.onLazyLoad) {\n                _this.props.onLazyLoad(slidesToLoad);\n              }\n            }\n          }\n          _this.adaptHeight();\n          var spec = _objectSpread(_objectSpread({\n            listRef: _this.list,\n            trackRef: _this.track\n          }, _this.props), _this.state);\n          var setTrackStyle = _this.didPropsChange(prevProps);\n          setTrackStyle && _this.updateState(spec, setTrackStyle, function() {\n            if (_this.state.currentSlide >= _react[\"default\"].Children.count(_this.props.children)) {\n              _this.changeSlide({\n                message: \"index\",\n                index: _react[\"default\"].Children.count(_this.props.children) - _this.props.slidesToShow,\n                currentSlide: _this.state.currentSlide\n              });\n            }\n            if (_this.props.autoplay) {\n              _this.autoPlay(\"update\");\n            } else {\n              _this.pause(\"paused\");\n            }\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onWindowResized\", function(setTrackStyle) {\n          if (_this.debouncedResize)\n            _this.debouncedResize.cancel();\n          _this.debouncedResize = (0, _lodash[\"default\"])(function() {\n            return _this.resizeWindow(setTrackStyle);\n          }, 50);\n          _this.debouncedResize();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"resizeWindow\", function() {\n          var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n          var isTrackMounted = Boolean(_this.track && _this.track.node);\n          if (!isTrackMounted)\n            return;\n          var spec = _objectSpread(_objectSpread({\n            listRef: _this.list,\n            trackRef: _this.track\n          }, _this.props), _this.state);\n          _this.updateState(spec, setTrackStyle, function() {\n            if (_this.props.autoplay)\n              _this.autoPlay(\"update\");\n            else\n              _this.pause(\"paused\");\n          });\n          _this.setState({\n            animating: false\n          });\n          clearTimeout(_this.animationEndCallback);\n          delete _this.animationEndCallback;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"updateState\", function(spec, setTrackStyle, callback) {\n          var updatedState = (0, _innerSliderUtils.initializedState)(spec);\n          spec = _objectSpread(_objectSpread(_objectSpread({}, spec), updatedState), {}, {\n            slideIndex: updatedState.currentSlide\n          });\n          var targetLeft = (0, _innerSliderUtils.getTrackLeft)(spec);\n          spec = _objectSpread(_objectSpread({}, spec), {}, {\n            left: targetLeft\n          });\n          var trackStyle = (0, _innerSliderUtils.getTrackCSS)(spec);\n          if (setTrackStyle || _react[\"default\"].Children.count(_this.props.children) !== _react[\"default\"].Children.count(spec.children)) {\n            updatedState[\"trackStyle\"] = trackStyle;\n          }\n          _this.setState(updatedState, callback);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"ssrInit\", function() {\n          if (_this.props.variableWidth) {\n            var _trackWidth = 0, _trackLeft = 0;\n            var childrenWidths = [];\n            var preClones = (0, _innerSliderUtils.getPreClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n              slideCount: _this.props.children.length\n            }));\n            var postClones = (0, _innerSliderUtils.getPostClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n              slideCount: _this.props.children.length\n            }));\n            _this.props.children.forEach(function(child) {\n              childrenWidths.push(child.props.style.width);\n              _trackWidth += child.props.style.width;\n            });\n            for (var i = 0; i < preClones; i++) {\n              _trackLeft += childrenWidths[childrenWidths.length - 1 - i];\n              _trackWidth += childrenWidths[childrenWidths.length - 1 - i];\n            }\n            for (var _i = 0; _i < postClones; _i++) {\n              _trackWidth += childrenWidths[_i];\n            }\n            for (var _i2 = 0; _i2 < _this.state.currentSlide; _i2++) {\n              _trackLeft += childrenWidths[_i2];\n            }\n            var _trackStyle = {\n              width: _trackWidth + \"px\",\n              left: -_trackLeft + \"px\"\n            };\n            if (_this.props.centerMode) {\n              var currentWidth = \"\".concat(childrenWidths[_this.state.currentSlide], \"px\");\n              _trackStyle.left = \"calc(\".concat(_trackStyle.left, \" + (100% - \").concat(currentWidth, \") / 2 ) \");\n            }\n            return {\n              trackStyle: _trackStyle\n            };\n          }\n          var childrenCount = _react[\"default\"].Children.count(_this.props.children);\n          var spec = _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n            slideCount: childrenCount\n          });\n          var slideCount = (0, _innerSliderUtils.getPreClones)(spec) + (0, _innerSliderUtils.getPostClones)(spec) + childrenCount;\n          var trackWidth = 100 / _this.props.slidesToShow * slideCount;\n          var slideWidth = 100 / slideCount;\n          var trackLeft = -slideWidth * ((0, _innerSliderUtils.getPreClones)(spec) + _this.state.currentSlide) * trackWidth / 100;\n          if (_this.props.centerMode) {\n            trackLeft += (100 - slideWidth * trackWidth / 100) / 2;\n          }\n          var trackStyle = {\n            width: trackWidth + \"%\",\n            left: trackLeft + \"%\"\n          };\n          return {\n            slideWidth: slideWidth + \"%\",\n            trackStyle\n          };\n        });\n        _defineProperty(_assertThisInitialized(_this), \"checkImagesLoad\", function() {\n          var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(\".slick-slide img\") || [];\n          var imagesCount = images.length, loadedCount = 0;\n          Array.prototype.forEach.call(images, function(image) {\n            var handler = function handler2() {\n              return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();\n            };\n            if (!image.onclick) {\n              image.onclick = function() {\n                return image.parentNode.focus();\n              };\n            } else {\n              var prevClickHandler = image.onclick;\n              image.onclick = function() {\n                prevClickHandler();\n                image.parentNode.focus();\n              };\n            }\n            if (!image.onload) {\n              if (_this.props.lazyLoad) {\n                image.onload = function() {\n                  _this.adaptHeight();\n                  _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));\n                };\n              } else {\n                image.onload = handler;\n                image.onerror = function() {\n                  handler();\n                  _this.props.onLazyLoadError && _this.props.onLazyLoadError();\n                };\n              }\n            }\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"progressiveLazyLoad\", function() {\n          var slidesToLoad = [];\n          var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n          for (var index2 = _this.state.currentSlide; index2 < _this.state.slideCount + (0, _innerSliderUtils.getPostClones)(spec); index2++) {\n            if (_this.state.lazyLoadedList.indexOf(index2) < 0) {\n              slidesToLoad.push(index2);\n              break;\n            }\n          }\n          for (var _index = _this.state.currentSlide - 1; _index >= -(0, _innerSliderUtils.getPreClones)(spec); _index--) {\n            if (_this.state.lazyLoadedList.indexOf(_index) < 0) {\n              slidesToLoad.push(_index);\n              break;\n            }\n          }\n          if (slidesToLoad.length > 0) {\n            _this.setState(function(state) {\n              return {\n                lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)\n              };\n            });\n            if (_this.props.onLazyLoad) {\n              _this.props.onLazyLoad(slidesToLoad);\n            }\n          } else {\n            if (_this.lazyLoadTimer) {\n              clearInterval(_this.lazyLoadTimer);\n              delete _this.lazyLoadTimer;\n            }\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slideHandler\", function(index2) {\n          var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n          var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;\n          var currentSlide = _this.state.currentSlide;\n          var _slideHandler = (0, _innerSliderUtils.slideHandler)(_objectSpread(_objectSpread(_objectSpread({\n            index: index2\n          }, _this.props), _this.state), {}, {\n            trackRef: _this.track,\n            useCSS: _this.props.useCSS && !dontAnimate\n          })), state = _slideHandler.state, nextState = _slideHandler.nextState;\n          if (!state)\n            return;\n          beforeChange && beforeChange(currentSlide, state.currentSlide);\n          var slidesToLoad = state.lazyLoadedList.filter(function(value) {\n            return _this.state.lazyLoadedList.indexOf(value) < 0;\n          });\n          onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);\n          if (!_this.props.waitForAnimate && _this.animationEndCallback) {\n            clearTimeout(_this.animationEndCallback);\n            afterChange && afterChange(currentSlide);\n            delete _this.animationEndCallback;\n          }\n          _this.setState(state, function() {\n            if (asNavFor && _this.asNavForIndex !== index2) {\n              _this.asNavForIndex = index2;\n              asNavFor.innerSlider.slideHandler(index2);\n            }\n            if (!nextState)\n              return;\n            _this.animationEndCallback = setTimeout(function() {\n              var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, [\"animating\"]);\n              _this.setState(firstBatch, function() {\n                _this.callbackTimers.push(setTimeout(function() {\n                  return _this.setState({\n                    animating\n                  });\n                }, 10));\n                afterChange && afterChange(state.currentSlide);\n                delete _this.animationEndCallback;\n              });\n            }, speed);\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"changeSlide\", function(options) {\n          var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n          var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n          var targetSlide = (0, _innerSliderUtils.changeSlide)(spec, options);\n          if (targetSlide !== 0 && !targetSlide)\n            return;\n          if (dontAnimate === true) {\n            _this.slideHandler(targetSlide, dontAnimate);\n          } else {\n            _this.slideHandler(targetSlide);\n          }\n          _this.props.autoplay && _this.autoPlay(\"update\");\n          if (_this.props.focusOnSelect) {\n            var nodes = _this.list.querySelectorAll(\".slick-current\");\n            nodes[0] && nodes[0].focus();\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"clickHandler\", function(e) {\n          if (_this.clickable === false) {\n            e.stopPropagation();\n            e.preventDefault();\n          }\n          _this.clickable = true;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"keyHandler\", function(e) {\n          var dir = (0, _innerSliderUtils.keyHandler)(e, _this.props.accessibility, _this.props.rtl);\n          dir !== \"\" && _this.changeSlide({\n            message: dir\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"selectHandler\", function(options) {\n          _this.changeSlide(options);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"disableBodyScroll\", function() {\n          var preventDefault = function preventDefault2(e) {\n            e = e || window.event;\n            if (e.preventDefault)\n              e.preventDefault();\n            e.returnValue = false;\n          };\n          window.ontouchmove = preventDefault;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"enableBodyScroll\", function() {\n          window.ontouchmove = null;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeStart\", function(e) {\n          if (_this.props.verticalSwiping) {\n            _this.disableBodyScroll();\n          }\n          var state = (0, _innerSliderUtils.swipeStart)(e, _this.props.swipe, _this.props.draggable);\n          state !== \"\" && _this.setState(state);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeMove\", function(e) {\n          var state = (0, _innerSliderUtils.swipeMove)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n            trackRef: _this.track,\n            listRef: _this.list,\n            slideIndex: _this.state.currentSlide\n          }));\n          if (!state)\n            return;\n          if (state[\"swiping\"]) {\n            _this.clickable = false;\n          }\n          _this.setState(state);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeEnd\", function(e) {\n          var state = (0, _innerSliderUtils.swipeEnd)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n            trackRef: _this.track,\n            listRef: _this.list,\n            slideIndex: _this.state.currentSlide\n          }));\n          if (!state)\n            return;\n          var triggerSlideHandler = state[\"triggerSlideHandler\"];\n          delete state[\"triggerSlideHandler\"];\n          _this.setState(state);\n          if (triggerSlideHandler === void 0)\n            return;\n          _this.slideHandler(triggerSlideHandler);\n          if (_this.props.verticalSwiping) {\n            _this.enableBodyScroll();\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"touchEnd\", function(e) {\n          _this.swipeEnd(e);\n          _this.clickable = true;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function() {\n          _this.callbackTimers.push(setTimeout(function() {\n            return _this.changeSlide({\n              message: \"previous\"\n            });\n          }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickNext\", function() {\n          _this.callbackTimers.push(setTimeout(function() {\n            return _this.changeSlide({\n              message: \"next\"\n            });\n          }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function(slide) {\n          var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n          slide = Number(slide);\n          if (isNaN(slide))\n            return \"\";\n          _this.callbackTimers.push(setTimeout(function() {\n            return _this.changeSlide({\n              message: \"index\",\n              index: slide,\n              currentSlide: _this.state.currentSlide\n            }, dontAnimate);\n          }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"play\", function() {\n          var nextIndex;\n          if (_this.props.rtl) {\n            nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;\n          } else {\n            if ((0, _innerSliderUtils.canGoNext)(_objectSpread(_objectSpread({}, _this.props), _this.state))) {\n              nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;\n            } else {\n              return false;\n            }\n          }\n          _this.slideHandler(nextIndex);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"autoPlay\", function(playType) {\n          if (_this.autoplayTimer) {\n            clearInterval(_this.autoplayTimer);\n          }\n          var autoplaying = _this.state.autoplaying;\n          if (playType === \"update\") {\n            if (autoplaying === \"hovered\" || autoplaying === \"focused\" || autoplaying === \"paused\") {\n              return;\n            }\n          } else if (playType === \"leave\") {\n            if (autoplaying === \"paused\" || autoplaying === \"focused\") {\n              return;\n            }\n          } else if (playType === \"blur\") {\n            if (autoplaying === \"paused\" || autoplaying === \"hovered\") {\n              return;\n            }\n          }\n          _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);\n          _this.setState({\n            autoplaying: \"playing\"\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"pause\", function(pauseType) {\n          if (_this.autoplayTimer) {\n            clearInterval(_this.autoplayTimer);\n            _this.autoplayTimer = null;\n          }\n          var autoplaying = _this.state.autoplaying;\n          if (pauseType === \"paused\") {\n            _this.setState({\n              autoplaying: \"paused\"\n            });\n          } else if (pauseType === \"focused\") {\n            if (autoplaying === \"hovered\" || autoplaying === \"playing\") {\n              _this.setState({\n                autoplaying: \"focused\"\n              });\n            }\n          } else {\n            if (autoplaying === \"playing\") {\n              _this.setState({\n                autoplaying: \"hovered\"\n              });\n            }\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDotsOver\", function() {\n          return _this.props.autoplay && _this.pause(\"hovered\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDotsLeave\", function() {\n          return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTrackOver\", function() {\n          return _this.props.autoplay && _this.pause(\"hovered\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTrackLeave\", function() {\n          return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSlideFocus\", function() {\n          return _this.props.autoplay && _this.pause(\"focused\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSlideBlur\", function() {\n          return _this.props.autoplay && _this.state.autoplaying === \"focused\" && _this.autoPlay(\"blur\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"render\", function() {\n          var className = (0, _classnames[\"default\"])(\"slick-slider\", _this.props.className, {\n            \"slick-vertical\": _this.props.vertical,\n            \"slick-initialized\": true\n          });\n          var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n          var trackProps = (0, _innerSliderUtils.extractObject)(spec, [\"fade\", \"cssEase\", \"speed\", \"infinite\", \"centerMode\", \"focusOnSelect\", \"currentSlide\", \"lazyLoad\", \"lazyLoadedList\", \"rtl\", \"slideWidth\", \"slideHeight\", \"listHeight\", \"vertical\", \"slidesToShow\", \"slidesToScroll\", \"slideCount\", \"trackStyle\", \"variableWidth\", \"unslick\", \"centerPadding\", \"targetSlide\", \"useCSS\"]);\n          var pauseOnHover = _this.props.pauseOnHover;\n          trackProps = _objectSpread(_objectSpread({}, trackProps), {}, {\n            onMouseEnter: pauseOnHover ? _this.onTrackOver : null,\n            onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,\n            onMouseOver: pauseOnHover ? _this.onTrackOver : null,\n            focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null\n          });\n          var dots;\n          if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {\n            var dotProps = (0, _innerSliderUtils.extractObject)(spec, [\"dotsClass\", \"slideCount\", \"slidesToShow\", \"currentSlide\", \"slidesToScroll\", \"clickHandler\", \"children\", \"customPaging\", \"infinite\", \"appendDots\"]);\n            var pauseOnDotsHover = _this.props.pauseOnDotsHover;\n            dotProps = _objectSpread(_objectSpread({}, dotProps), {}, {\n              clickHandler: _this.changeSlide,\n              onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,\n              onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,\n              onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null\n            });\n            dots = _react[\"default\"].createElement(_dots.Dots, dotProps);\n          }\n          var prevArrow, nextArrow;\n          var arrowProps = (0, _innerSliderUtils.extractObject)(spec, [\"infinite\", \"centerMode\", \"currentSlide\", \"slideCount\", \"slidesToShow\", \"prevArrow\", \"nextArrow\"]);\n          arrowProps.clickHandler = _this.changeSlide;\n          if (_this.props.arrows) {\n            prevArrow = _react[\"default\"].createElement(_arrows.PrevArrow, arrowProps);\n            nextArrow = _react[\"default\"].createElement(_arrows.NextArrow, arrowProps);\n          }\n          var verticalHeightStyle = null;\n          if (_this.props.vertical) {\n            verticalHeightStyle = {\n              height: _this.state.listHeight\n            };\n          }\n          var centerPaddingStyle = null;\n          if (_this.props.vertical === false) {\n            if (_this.props.centerMode === true) {\n              centerPaddingStyle = {\n                padding: \"0px \" + _this.props.centerPadding\n              };\n            }\n          } else {\n            if (_this.props.centerMode === true) {\n              centerPaddingStyle = {\n                padding: _this.props.centerPadding + \" 0px\"\n              };\n            }\n          }\n          var listStyle = _objectSpread(_objectSpread({}, verticalHeightStyle), centerPaddingStyle);\n          var touchMove = _this.props.touchMove;\n          var listProps = {\n            className: \"slick-list\",\n            style: listStyle,\n            onClick: _this.clickHandler,\n            onMouseDown: touchMove ? _this.swipeStart : null,\n            onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n            onMouseUp: touchMove ? _this.swipeEnd : null,\n            onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n            onTouchStart: touchMove ? _this.swipeStart : null,\n            onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n            onTouchEnd: touchMove ? _this.touchEnd : null,\n            onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n            onKeyDown: _this.props.accessibility ? _this.keyHandler : null\n          };\n          var innerSliderProps = {\n            className,\n            dir: \"ltr\",\n            style: _this.props.style\n          };\n          if (_this.props.unslick) {\n            listProps = {\n              className: \"slick-list\"\n            };\n            innerSliderProps = {\n              className\n            };\n          }\n          return _react[\"default\"].createElement(\"div\", innerSliderProps, !_this.props.unslick ? prevArrow : \"\", _react[\"default\"].createElement(\"div\", _extends({\n            ref: _this.listRefHandler\n          }, listProps), _react[\"default\"].createElement(_track.Track, _extends({\n            ref: _this.trackRefHandler\n          }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : \"\", !_this.props.unslick ? dots : \"\");\n        });\n        _this.list = null;\n        _this.track = null;\n        _this.state = _objectSpread(_objectSpread({}, _initialState[\"default\"]), {}, {\n          currentSlide: _this.props.initialSlide,\n          slideCount: _react[\"default\"].Children.count(_this.props.children)\n        });\n        _this.callbackTimers = [];\n        _this.clickable = true;\n        _this.debouncedResize = null;\n        var ssrState = _this.ssrInit();\n        _this.state = _objectSpread(_objectSpread({}, _this.state), ssrState);\n        return _this;\n      }\n      _createClass(InnerSlider2, [{\n        key: \"didPropsChange\",\n        value: function didPropsChange(prevProps) {\n          var setTrackStyle = false;\n          for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {\n            var key = _Object$keys[_i3];\n            if (!prevProps.hasOwnProperty(key)) {\n              setTrackStyle = true;\n              break;\n            }\n            if (_typeof(prevProps[key]) === \"object\" || typeof prevProps[key] === \"function\") {\n              continue;\n            }\n            if (prevProps[key] !== this.props[key]) {\n              setTrackStyle = true;\n              break;\n            }\n          }\n          return setTrackStyle || _react[\"default\"].Children.count(this.props.children) !== _react[\"default\"].Children.count(prevProps.children);\n        }\n      }]);\n      return InnerSlider2;\n    }(_react[\"default\"].Component);\n    exports.InnerSlider = InnerSlider;\n  }\n});\n\n// node_modules/string-convert/camel2hyphen.js\nvar require_camel2hyphen = __commonJS({\n  \"node_modules/string-convert/camel2hyphen.js\"(exports, module) {\n    var camel2hyphen = function(str) {\n      return str.replace(/[A-Z]/g, function(match) {\n        return \"-\" + match.toLowerCase();\n      }).toLowerCase();\n    };\n    module.exports = camel2hyphen;\n  }\n});\n\n// node_modules/json2mq/index.js\nvar require_json2mq = __commonJS({\n  \"node_modules/json2mq/index.js\"(exports, module) {\n    var camel2hyphen = require_camel2hyphen();\n    var isDimension = function(feature) {\n      var re = /[height|width]$/;\n      return re.test(feature);\n    };\n    var obj2mq = function(obj) {\n      var mq = \"\";\n      var features = Object.keys(obj);\n      features.forEach(function(feature, index2) {\n        var value = obj[feature];\n        feature = camel2hyphen(feature);\n        if (isDimension(feature) && typeof value === \"number\") {\n          value = value + \"px\";\n        }\n        if (value === true) {\n          mq += feature;\n        } else if (value === false) {\n          mq += \"not \" + feature;\n        } else {\n          mq += \"(\" + feature + \": \" + value + \")\";\n        }\n        if (index2 < features.length - 1) {\n          mq += \" and \";\n        }\n      });\n      return mq;\n    };\n    var json2mq = function(query) {\n      var mq = \"\";\n      if (typeof query === \"string\") {\n        return query;\n      }\n      if (query instanceof Array) {\n        query.forEach(function(q, index2) {\n          mq += obj2mq(q);\n          if (index2 < query.length - 1) {\n            mq += \", \";\n          }\n        });\n        return mq;\n      }\n      return obj2mq(query);\n    };\n    module.exports = json2mq;\n  }\n});\n\n// node_modules/react-slick/lib/default-props.js\nvar require_default_props = __commonJS({\n  \"node_modules/react-slick/lib/default-props.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _react = _interopRequireDefault(require_react());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var defaultProps = {\n      accessibility: true,\n      adaptiveHeight: false,\n      afterChange: null,\n      appendDots: function appendDots(dots) {\n        return _react[\"default\"].createElement(\"ul\", {\n          style: {\n            display: \"block\"\n          }\n        }, dots);\n      },\n      arrows: true,\n      autoplay: false,\n      autoplaySpeed: 3e3,\n      beforeChange: null,\n      centerMode: false,\n      centerPadding: \"50px\",\n      className: \"\",\n      cssEase: \"ease\",\n      customPaging: function customPaging(i) {\n        return _react[\"default\"].createElement(\"button\", null, i + 1);\n      },\n      dots: false,\n      dotsClass: \"slick-dots\",\n      draggable: true,\n      easing: \"linear\",\n      edgeFriction: 0.35,\n      fade: false,\n      focusOnSelect: false,\n      infinite: true,\n      initialSlide: 0,\n      lazyLoad: null,\n      nextArrow: null,\n      onEdge: null,\n      onInit: null,\n      onLazyLoadError: null,\n      onReInit: null,\n      pauseOnDotsHover: false,\n      pauseOnFocus: false,\n      pauseOnHover: true,\n      prevArrow: null,\n      responsive: null,\n      rows: 1,\n      rtl: false,\n      slide: \"div\",\n      slidesPerRow: 1,\n      slidesToScroll: 1,\n      slidesToShow: 1,\n      speed: 500,\n      swipe: true,\n      swipeEvent: null,\n      swipeToSlide: false,\n      touchMove: true,\n      touchThreshold: 5,\n      useCSS: true,\n      useTransform: true,\n      variableWidth: false,\n      vertical: false,\n      waitForAnimate: true\n    };\n    var _default = defaultProps;\n    exports[\"default\"] = _default;\n  }\n});\n\n// node_modules/enquire.js/src/QueryHandler.js\nvar require_QueryHandler = __commonJS({\n  \"node_modules/enquire.js/src/QueryHandler.js\"(exports, module) {\n    function QueryHandler(options) {\n      this.options = options;\n      !options.deferSetup && this.setup();\n    }\n    QueryHandler.prototype = {\n      constructor: QueryHandler,\n      /**\n       * coordinates setup of the handler\n       *\n       * @function\n       */\n      setup: function() {\n        if (this.options.setup) {\n          this.options.setup();\n        }\n        this.initialised = true;\n      },\n      /**\n       * coordinates setup and triggering of the handler\n       *\n       * @function\n       */\n      on: function() {\n        !this.initialised && this.setup();\n        this.options.match && this.options.match();\n      },\n      /**\n       * coordinates the unmatch event for the handler\n       *\n       * @function\n       */\n      off: function() {\n        this.options.unmatch && this.options.unmatch();\n      },\n      /**\n       * called when a handler is to be destroyed.\n       * delegates to the destroy or unmatch callbacks, depending on availability.\n       *\n       * @function\n       */\n      destroy: function() {\n        this.options.destroy ? this.options.destroy() : this.off();\n      },\n      /**\n       * determines equality by reference.\n       * if object is supplied compare options, if function, compare match callback\n       *\n       * @function\n       * @param {object || function} [target] the target for comparison\n       */\n      equals: function(target) {\n        return this.options === target || this.options.match === target;\n      }\n    };\n    module.exports = QueryHandler;\n  }\n});\n\n// node_modules/enquire.js/src/Util.js\nvar require_Util = __commonJS({\n  \"node_modules/enquire.js/src/Util.js\"(exports, module) {\n    function each(collection, fn) {\n      var i = 0, length = collection.length, cont;\n      for (i; i < length; i++) {\n        cont = fn(collection[i], i);\n        if (cont === false) {\n          break;\n        }\n      }\n    }\n    function isArray(target) {\n      return Object.prototype.toString.apply(target) === \"[object Array]\";\n    }\n    function isFunction(target) {\n      return typeof target === \"function\";\n    }\n    module.exports = {\n      isFunction,\n      isArray,\n      each\n    };\n  }\n});\n\n// node_modules/enquire.js/src/MediaQuery.js\nvar require_MediaQuery = __commonJS({\n  \"node_modules/enquire.js/src/MediaQuery.js\"(exports, module) {\n    var QueryHandler = require_QueryHandler();\n    var each = require_Util().each;\n    function MediaQuery(query, isUnconditional) {\n      this.query = query;\n      this.isUnconditional = isUnconditional;\n      this.handlers = [];\n      this.mql = window.matchMedia(query);\n      var self2 = this;\n      this.listener = function(mql) {\n        self2.mql = mql.currentTarget || mql;\n        self2.assess();\n      };\n      this.mql.addListener(this.listener);\n    }\n    MediaQuery.prototype = {\n      constuctor: MediaQuery,\n      /**\n       * add a handler for this query, triggering if already active\n       *\n       * @param {object} handler\n       * @param {function} handler.match callback for when query is activated\n       * @param {function} [handler.unmatch] callback for when query is deactivated\n       * @param {function} [handler.setup] callback for immediate execution when a query handler is registered\n       * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?\n       */\n      addHandler: function(handler) {\n        var qh = new QueryHandler(handler);\n        this.handlers.push(qh);\n        this.matches() && qh.on();\n      },\n      /**\n       * removes the given handler from the collection, and calls it's destroy methods\n       *\n       * @param {object || function} handler the handler to remove\n       */\n      removeHandler: function(handler) {\n        var handlers = this.handlers;\n        each(handlers, function(h, i) {\n          if (h.equals(handler)) {\n            h.destroy();\n            return !handlers.splice(i, 1);\n          }\n        });\n      },\n      /**\n       * Determine whether the media query should be considered a match\n       *\n       * @return {Boolean} true if media query can be considered a match, false otherwise\n       */\n      matches: function() {\n        return this.mql.matches || this.isUnconditional;\n      },\n      /**\n       * Clears all handlers and unbinds events\n       */\n      clear: function() {\n        each(this.handlers, function(handler) {\n          handler.destroy();\n        });\n        this.mql.removeListener(this.listener);\n        this.handlers.length = 0;\n      },\n      /*\n          * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match\n          */\n      assess: function() {\n        var action = this.matches() ? \"on\" : \"off\";\n        each(this.handlers, function(handler) {\n          handler[action]();\n        });\n      }\n    };\n    module.exports = MediaQuery;\n  }\n});\n\n// node_modules/enquire.js/src/MediaQueryDispatch.js\nvar require_MediaQueryDispatch = __commonJS({\n  \"node_modules/enquire.js/src/MediaQueryDispatch.js\"(exports, module) {\n    var MediaQuery = require_MediaQuery();\n    var Util = require_Util();\n    var each = Util.each;\n    var isFunction = Util.isFunction;\n    var isArray = Util.isArray;\n    function MediaQueryDispatch() {\n      if (!window.matchMedia) {\n        throw new Error(\"matchMedia not present, legacy browsers require a polyfill\");\n      }\n      this.queries = {};\n      this.browserIsIncapable = !window.matchMedia(\"only all\").matches;\n    }\n    MediaQueryDispatch.prototype = {\n      constructor: MediaQueryDispatch,\n      /**\n       * Registers a handler for the given media query\n       *\n       * @param {string} q the media query\n       * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers\n       * @param {function} options.match fired when query matched\n       * @param {function} [options.unmatch] fired when a query is no longer matched\n       * @param {function} [options.setup] fired when handler first triggered\n       * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched\n       * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers\n       */\n      register: function(q, options, shouldDegrade) {\n        var queries = this.queries, isUnconditional = shouldDegrade && this.browserIsIncapable;\n        if (!queries[q]) {\n          queries[q] = new MediaQuery(q, isUnconditional);\n        }\n        if (isFunction(options)) {\n          options = { match: options };\n        }\n        if (!isArray(options)) {\n          options = [options];\n        }\n        each(options, function(handler) {\n          if (isFunction(handler)) {\n            handler = { match: handler };\n          }\n          queries[q].addHandler(handler);\n        });\n        return this;\n      },\n      /**\n       * unregisters a query and all it's handlers, or a specific handler for a query\n       *\n       * @param {string} q the media query to target\n       * @param {object || function} [handler] specific handler to unregister\n       */\n      unregister: function(q, handler) {\n        var query = this.queries[q];\n        if (query) {\n          if (handler) {\n            query.removeHandler(handler);\n          } else {\n            query.clear();\n            delete this.queries[q];\n          }\n        }\n        return this;\n      }\n    };\n    module.exports = MediaQueryDispatch;\n  }\n});\n\n// node_modules/enquire.js/src/index.js\nvar require_src = __commonJS({\n  \"node_modules/enquire.js/src/index.js\"(exports, module) {\n    var MediaQueryDispatch = require_MediaQueryDispatch();\n    module.exports = new MediaQueryDispatch();\n  }\n});\n\n// node_modules/react-slick/lib/slider.js\nvar require_slider = __commonJS({\n  \"node_modules/react-slick/lib/slider.js\"(exports) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _innerSlider = require_inner_slider();\n    var _json2mq = _interopRequireDefault(require_json2mq());\n    var _defaultProps = _interopRequireDefault(require_default_props());\n    var _innerSliderUtils = require_innerSliderUtils();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var enquire = (0, _innerSliderUtils.canUseDOM)() && require_src();\n    var Slider = function(_React$Component) {\n      _inherits(Slider2, _React$Component);\n      var _super = _createSuper(Slider2);\n      function Slider2(props) {\n        var _this;\n        _classCallCheck(this, Slider2);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"innerSliderRefHandler\", function(ref) {\n          return _this.innerSlider = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function() {\n          return _this.innerSlider.slickPrev();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickNext\", function() {\n          return _this.innerSlider.slickNext();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function(slide) {\n          var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n          return _this.innerSlider.slickGoTo(slide, dontAnimate);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPause\", function() {\n          return _this.innerSlider.pause(\"paused\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPlay\", function() {\n          return _this.innerSlider.autoPlay(\"play\");\n        });\n        _this.state = {\n          breakpoint: null\n        };\n        _this._responsiveMediaHandlers = [];\n        return _this;\n      }\n      _createClass(Slider2, [{\n        key: \"media\",\n        value: function media(query, handler) {\n          enquire.register(query, handler);\n          this._responsiveMediaHandlers.push({\n            query,\n            handler\n          });\n        }\n        // handles responsive breakpoints\n      }, {\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          var _this2 = this;\n          if (this.props.responsive) {\n            var breakpoints = this.props.responsive.map(function(breakpt) {\n              return breakpt.breakpoint;\n            });\n            breakpoints.sort(function(x, y) {\n              return x - y;\n            });\n            breakpoints.forEach(function(breakpoint, index2) {\n              var bQuery;\n              if (index2 === 0) {\n                bQuery = (0, _json2mq[\"default\"])({\n                  minWidth: 0,\n                  maxWidth: breakpoint\n                });\n              } else {\n                bQuery = (0, _json2mq[\"default\"])({\n                  minWidth: breakpoints[index2 - 1] + 1,\n                  maxWidth: breakpoint\n                });\n              }\n              (0, _innerSliderUtils.canUseDOM)() && _this2.media(bQuery, function() {\n                _this2.setState({\n                  breakpoint\n                });\n              });\n            });\n            var query = (0, _json2mq[\"default\"])({\n              minWidth: breakpoints.slice(-1)[0]\n            });\n            (0, _innerSliderUtils.canUseDOM)() && this.media(query, function() {\n              _this2.setState({\n                breakpoint: null\n              });\n            });\n          }\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this._responsiveMediaHandlers.forEach(function(obj) {\n            enquire.unregister(obj.query, obj.handler);\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this3 = this;\n          var settings;\n          var newProps;\n          if (this.state.breakpoint) {\n            newProps = this.props.responsive.filter(function(resp) {\n              return resp.breakpoint === _this3.state.breakpoint;\n            });\n            settings = newProps[0].settings === \"unslick\" ? \"unslick\" : _objectSpread(_objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props), newProps[0].settings);\n          } else {\n            settings = _objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props);\n          }\n          if (settings.centerMode) {\n            if (settings.slidesToScroll > 1 && true) {\n              console.warn(\"slidesToScroll should be equal to 1 in centerMode, you are using \".concat(settings.slidesToScroll));\n            }\n            settings.slidesToScroll = 1;\n          }\n          if (settings.fade) {\n            if (settings.slidesToShow > 1 && true) {\n              console.warn(\"slidesToShow should be equal to 1 when fade is true, you're using \".concat(settings.slidesToShow));\n            }\n            if (settings.slidesToScroll > 1 && true) {\n              console.warn(\"slidesToScroll should be equal to 1 when fade is true, you're using \".concat(settings.slidesToScroll));\n            }\n            settings.slidesToShow = 1;\n            settings.slidesToScroll = 1;\n          }\n          var children = _react[\"default\"].Children.toArray(this.props.children);\n          children = children.filter(function(child) {\n            if (typeof child === \"string\") {\n              return !!child.trim();\n            }\n            return !!child;\n          });\n          if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {\n            console.warn(\"variableWidth is not supported in case of rows > 1 or slidesPerRow > 1\");\n            settings.variableWidth = false;\n          }\n          var newChildren = [];\n          var currentWidth = null;\n          for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {\n            var newSlide = [];\n            for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {\n              var row = [];\n              for (var k = j; k < j + settings.slidesPerRow; k += 1) {\n                if (settings.variableWidth && children[k].props.style) {\n                  currentWidth = children[k].props.style.width;\n                }\n                if (k >= children.length)\n                  break;\n                row.push(_react[\"default\"].cloneElement(children[k], {\n                  key: 100 * i + 10 * j + k,\n                  tabIndex: -1,\n                  style: {\n                    width: \"\".concat(100 / settings.slidesPerRow, \"%\"),\n                    display: \"inline-block\"\n                  }\n                }));\n              }\n              newSlide.push(_react[\"default\"].createElement(\"div\", {\n                key: 10 * i + j\n              }, row));\n            }\n            if (settings.variableWidth) {\n              newChildren.push(_react[\"default\"].createElement(\"div\", {\n                key: i,\n                style: {\n                  width: currentWidth\n                }\n              }, newSlide));\n            } else {\n              newChildren.push(_react[\"default\"].createElement(\"div\", {\n                key: i\n              }, newSlide));\n            }\n          }\n          if (settings === \"unslick\") {\n            var className = \"regular slider \" + (this.props.className || \"\");\n            return _react[\"default\"].createElement(\"div\", {\n              className\n            }, children);\n          } else if (newChildren.length <= settings.slidesToShow) {\n            settings.unslick = true;\n          }\n          return _react[\"default\"].createElement(_innerSlider.InnerSlider, _extends({\n            style: this.props.style,\n            ref: this.innerSliderRefHandler\n          }, settings), newChildren);\n        }\n      }]);\n      return Slider2;\n    }(_react[\"default\"].Component);\n    exports[\"default\"] = Slider;\n  }\n});\n\n// node_modules/react-slick/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/react-slick/lib/index.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _slider = _interopRequireDefault(require_slider());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var _default = _slider[\"default\"];\n    exports[\"default\"] = _default;\n  }\n});\nexport default require_lib();\n/*! Bundled license information:\n\nclassnames/index.js:\n  (*!\n  \tCopyright (c) 2018 Jed Watson.\n  \tLicensed under the MIT License (MIT), see\n  \thttp://jedwatson.github.io/classnames\n  *)\n*/\n//# sourceMappingURL=react-slick.js.map\n",
      "start": 1701766112771,
      "end": 1701766112803,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:react-swc",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1701766112803,
      "end": 1701766112803,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-ZGRSIX2Q.js?v=3c106fdb\";\nimport {\n  __commonJS,\n  __esm,\n  __export,\n  __toCommonJS\n} from \"/node_modules/.vite/deps/chunk-ROME4SDB.js?v=3c106fdb\";\n\n// node_modules/react-slick/lib/initial-state.js\nvar require_initial_state = __commonJS({\n  \"node_modules/react-slick/lib/initial-state.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var initialState = {\n      animating: false,\n      autoplaying: null,\n      currentDirection: 0,\n      currentLeft: null,\n      currentSlide: 0,\n      direction: 1,\n      dragging: false,\n      edgeDragged: false,\n      initialized: false,\n      lazyLoadedList: [],\n      listHeight: null,\n      listWidth: null,\n      scrolling: false,\n      slideCount: null,\n      slideHeight: null,\n      slideWidth: null,\n      swipeLeft: null,\n      swiped: false,\n      // used by swipeEvent. differentites between touch and swipe.\n      swiping: false,\n      touchObject: {\n        startX: 0,\n        startY: 0,\n        curX: 0,\n        curY: 0\n      },\n      trackStyle: {},\n      trackWidth: 0,\n      targetSlide: 0\n    };\n    var _default = initialState;\n    exports[\"default\"] = _default;\n  }\n});\n\n// node_modules/lodash.debounce/index.js\nvar require_lodash = __commonJS({\n  \"node_modules/lodash.debounce/index.js\"(exports, module) {\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    var NAN = 0 / 0;\n    var symbolTag = \"[object Symbol]\";\n    var reTrim = /^\\s+|\\s+$/g;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal || freeSelf || Function(\"return this\")();\n    var objectProto = Object.prototype;\n    var objectToString = objectProto.toString;\n    var nativeMax = Math.max;\n    var nativeMin = Math.min;\n    var now = function() {\n      return root.Date.now();\n    };\n    function debounce(func, wait, options) {\n      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n      if (typeof func != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n      }\n      function invokeFunc(time) {\n        var args = lastArgs, thisArg = lastThis;\n        lastArgs = lastThis = void 0;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n      function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = setTimeout(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n      }\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;\n        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;\n      }\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n      }\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n      function trailingEdge(time) {\n        timerId = void 0;\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = void 0;\n        return result;\n      }\n      function cancel() {\n        if (timerId !== void 0) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = void 0;\n      }\n      function flush() {\n        return timerId === void 0 ? result : trailingEdge(now());\n      }\n      function debounced() {\n        var time = now(), isInvoking = shouldInvoke(time);\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n          if (timerId === void 0) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === void 0) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == \"object\" || type == \"function\");\n    }\n    function isObjectLike(value) {\n      return !!value && typeof value == \"object\";\n    }\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, \"\");\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    module.exports = debounce;\n  }\n});\n\n// node_modules/classnames/index.js\nvar require_classnames = __commonJS({\n  \"node_modules/classnames/index.js\"(exports, module) {\n    (function() {\n      \"use strict\";\n      var hasOwn = {}.hasOwnProperty;\n      var nativeCodeString = \"[native code]\";\n      function classNames() {\n        var classes = [];\n        for (var i = 0; i < arguments.length; i++) {\n          var arg = arguments[i];\n          if (!arg)\n            continue;\n          var argType = typeof arg;\n          if (argType === \"string\" || argType === \"number\") {\n            classes.push(arg);\n          } else if (Array.isArray(arg)) {\n            if (arg.length) {\n              var inner = classNames.apply(null, arg);\n              if (inner) {\n                classes.push(inner);\n              }\n            }\n          } else if (argType === \"object\") {\n            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes(\"[native code]\")) {\n              classes.push(arg.toString());\n              continue;\n            }\n            for (var key in arg) {\n              if (hasOwn.call(arg, key) && arg[key]) {\n                classes.push(key);\n              }\n            }\n          }\n        }\n        return classes.join(\" \");\n      }\n      if (typeof module !== \"undefined\" && module.exports) {\n        classNames.default = classNames;\n        module.exports = classNames;\n      } else if (typeof define === \"function\" && typeof define.amd === \"object\" && define.amd) {\n        define(\"classnames\", [], function() {\n          return classNames;\n        });\n      } else {\n        window.classNames = classNames;\n      }\n    })();\n  }\n});\n\n// node_modules/react-slick/lib/utils/innerSliderUtils.js\nvar require_innerSliderUtils = __commonJS({\n  \"node_modules/react-slick/lib/utils/innerSliderUtils.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.checkSpecKeys = exports.checkNavigable = exports.changeSlide = exports.canUseDOM = exports.canGoNext = void 0;\n    exports.clamp = clamp;\n    exports.swipeStart = exports.swipeMove = exports.swipeEnd = exports.slidesOnRight = exports.slidesOnLeft = exports.slideHandler = exports.siblingDirection = exports.safePreventDefault = exports.lazyStartIndex = exports.lazySlidesOnRight = exports.lazySlidesOnLeft = exports.lazyEndIndex = exports.keyHandler = exports.initializedState = exports.getWidth = exports.getTrackLeft = exports.getTrackCSS = exports.getTrackAnimateCSS = exports.getTotalSlides = exports.getSwipeDirection = exports.getSlideCount = exports.getRequiredLazySlides = exports.getPreClones = exports.getPostClones = exports.getOnDemandLazySlides = exports.getNavigableIndexes = exports.getHeight = exports.extractObject = void 0;\n    var _react = _interopRequireDefault(require_react());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function clamp(number, lowerBound, upperBound) {\n      return Math.max(lowerBound, Math.min(number, upperBound));\n    }\n    var safePreventDefault = function safePreventDefault2(event) {\n      var passiveEvents = [\"onTouchStart\", \"onTouchMove\", \"onWheel\"];\n      if (!passiveEvents.includes(event._reactName)) {\n        event.preventDefault();\n      }\n    };\n    exports.safePreventDefault = safePreventDefault;\n    var getOnDemandLazySlides = function getOnDemandLazySlides2(spec) {\n      var onDemandSlides = [];\n      var startIndex = lazyStartIndex(spec);\n      var endIndex = lazyEndIndex(spec);\n      for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n        if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n          onDemandSlides.push(slideIndex);\n        }\n      }\n      return onDemandSlides;\n    };\n    exports.getOnDemandLazySlides = getOnDemandLazySlides;\n    var getRequiredLazySlides = function getRequiredLazySlides2(spec) {\n      var requiredSlides = [];\n      var startIndex = lazyStartIndex(spec);\n      var endIndex = lazyEndIndex(spec);\n      for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n        requiredSlides.push(slideIndex);\n      }\n      return requiredSlides;\n    };\n    exports.getRequiredLazySlides = getRequiredLazySlides;\n    var lazyStartIndex = function lazyStartIndex2(spec) {\n      return spec.currentSlide - lazySlidesOnLeft(spec);\n    };\n    exports.lazyStartIndex = lazyStartIndex;\n    var lazyEndIndex = function lazyEndIndex2(spec) {\n      return spec.currentSlide + lazySlidesOnRight(spec);\n    };\n    exports.lazyEndIndex = lazyEndIndex;\n    var lazySlidesOnLeft = function lazySlidesOnLeft2(spec) {\n      return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\n    };\n    exports.lazySlidesOnLeft = lazySlidesOnLeft;\n    var lazySlidesOnRight = function lazySlidesOnRight2(spec) {\n      return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n    };\n    exports.lazySlidesOnRight = lazySlidesOnRight;\n    var getWidth = function getWidth2(elem) {\n      return elem && elem.offsetWidth || 0;\n    };\n    exports.getWidth = getWidth;\n    var getHeight = function getHeight2(elem) {\n      return elem && elem.offsetHeight || 0;\n    };\n    exports.getHeight = getHeight;\n    var getSwipeDirection = function getSwipeDirection2(touchObject) {\n      var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      var xDist, yDist, r, swipeAngle;\n      xDist = touchObject.startX - touchObject.curX;\n      yDist = touchObject.startY - touchObject.curY;\n      r = Math.atan2(yDist, xDist);\n      swipeAngle = Math.round(r * 180 / Math.PI);\n      if (swipeAngle < 0) {\n        swipeAngle = 360 - Math.abs(swipeAngle);\n      }\n      if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n        return \"left\";\n      }\n      if (swipeAngle >= 135 && swipeAngle <= 225) {\n        return \"right\";\n      }\n      if (verticalSwiping === true) {\n        if (swipeAngle >= 35 && swipeAngle <= 135) {\n          return \"up\";\n        } else {\n          return \"down\";\n        }\n      }\n      return \"vertical\";\n    };\n    exports.getSwipeDirection = getSwipeDirection;\n    var canGoNext = function canGoNext2(spec) {\n      var canGo = true;\n      if (!spec.infinite) {\n        if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n          canGo = false;\n        } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n          canGo = false;\n        }\n      }\n      return canGo;\n    };\n    exports.canGoNext = canGoNext;\n    var extractObject = function extractObject2(spec, keys) {\n      var newObject = {};\n      keys.forEach(function(key) {\n        return newObject[key] = spec[key];\n      });\n      return newObject;\n    };\n    exports.extractObject = extractObject;\n    var initializedState = function initializedState2(spec) {\n      var slideCount = _react[\"default\"].Children.count(spec.children);\n      var listNode = spec.listRef;\n      var listWidth = Math.ceil(getWidth(listNode));\n      var trackNode = spec.trackRef && spec.trackRef.node;\n      var trackWidth = Math.ceil(getWidth(trackNode));\n      var slideWidth;\n      if (!spec.vertical) {\n        var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n        if (typeof spec.centerPadding === \"string\" && spec.centerPadding.slice(-1) === \"%\") {\n          centerPaddingAdj *= listWidth / 100;\n        }\n        slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n      } else {\n        slideWidth = listWidth;\n      }\n      var slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'));\n      var listHeight = slideHeight * spec.slidesToShow;\n      var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;\n      if (spec.rtl && spec.currentSlide === void 0) {\n        currentSlide = slideCount - 1 - spec.initialSlide;\n      }\n      var lazyLoadedList = spec.lazyLoadedList || [];\n      var slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n        currentSlide,\n        lazyLoadedList\n      }));\n      lazyLoadedList = lazyLoadedList.concat(slidesToLoad);\n      var state = {\n        slideCount,\n        slideWidth,\n        listWidth,\n        trackWidth,\n        currentSlide,\n        slideHeight,\n        listHeight,\n        lazyLoadedList\n      };\n      if (spec.autoplaying === null && spec.autoplay) {\n        state[\"autoplaying\"] = \"playing\";\n      }\n      return state;\n    };\n    exports.initializedState = initializedState;\n    var slideHandler = function slideHandler2(spec) {\n      var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;\n      var lazyLoadedList = spec.lazyLoadedList;\n      if (waitForAnimate && animating)\n        return {};\n      var animationSlide = index2, finalSlide, animationLeft, finalLeft;\n      var state = {}, nextState = {};\n      var targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);\n      if (fade) {\n        if (!infinite && (index2 < 0 || index2 >= slideCount))\n          return {};\n        if (index2 < 0) {\n          animationSlide = index2 + slideCount;\n        } else if (index2 >= slideCount) {\n          animationSlide = index2 - slideCount;\n        }\n        if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n          lazyLoadedList = lazyLoadedList.concat(animationSlide);\n        }\n        state = {\n          animating: true,\n          currentSlide: animationSlide,\n          lazyLoadedList,\n          targetSlide: animationSlide\n        };\n        nextState = {\n          animating: false,\n          targetSlide: animationSlide\n        };\n      } else {\n        finalSlide = animationSlide;\n        if (animationSlide < 0) {\n          finalSlide = animationSlide + slideCount;\n          if (!infinite)\n            finalSlide = 0;\n          else if (slideCount % slidesToScroll !== 0)\n            finalSlide = slideCount - slideCount % slidesToScroll;\n        } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n          animationSlide = finalSlide = currentSlide;\n        } else if (centerMode && animationSlide >= slideCount) {\n          animationSlide = infinite ? slideCount : slideCount - 1;\n          finalSlide = infinite ? 0 : slideCount - 1;\n        } else if (animationSlide >= slideCount) {\n          finalSlide = animationSlide - slideCount;\n          if (!infinite)\n            finalSlide = slideCount - slidesToShow;\n          else if (slideCount % slidesToScroll !== 0)\n            finalSlide = 0;\n        }\n        if (!infinite && animationSlide + slidesToShow >= slideCount) {\n          finalSlide = slideCount - slidesToShow;\n        }\n        animationLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n          slideIndex: animationSlide\n        }));\n        finalLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n          slideIndex: finalSlide\n        }));\n        if (!infinite) {\n          if (animationLeft === finalLeft)\n            animationSlide = finalSlide;\n          animationLeft = finalLeft;\n        }\n        if (lazyLoad) {\n          lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n            currentSlide: animationSlide\n          })));\n        }\n        if (!useCSS) {\n          state = {\n            currentSlide: finalSlide,\n            trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n              left: finalLeft\n            })),\n            lazyLoadedList,\n            targetSlide\n          };\n        } else {\n          state = {\n            animating: true,\n            currentSlide: finalSlide,\n            trackStyle: getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n              left: animationLeft\n            })),\n            lazyLoadedList,\n            targetSlide\n          };\n          nextState = {\n            animating: false,\n            currentSlide: finalSlide,\n            trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n              left: finalLeft\n            })),\n            swipeLeft: null,\n            targetSlide\n          };\n        }\n      }\n      return {\n        state,\n        nextState\n      };\n    };\n    exports.slideHandler = slideHandler;\n    var changeSlide = function changeSlide2(spec, options) {\n      var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;\n      var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;\n      unevenOffset = slideCount % slidesToScroll !== 0;\n      indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n      if (options.message === \"previous\") {\n        slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n        targetSlide = currentSlide - slideOffset;\n        if (lazyLoad && !infinite) {\n          previousInt = currentSlide - slideOffset;\n          targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n        }\n        if (!infinite) {\n          targetSlide = previousTargetSlide - slidesToScroll;\n        }\n      } else if (options.message === \"next\") {\n        slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n        targetSlide = currentSlide + slideOffset;\n        if (lazyLoad && !infinite) {\n          targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n        }\n        if (!infinite) {\n          targetSlide = previousTargetSlide + slidesToScroll;\n        }\n      } else if (options.message === \"dots\") {\n        targetSlide = options.index * options.slidesToScroll;\n      } else if (options.message === \"children\") {\n        targetSlide = options.index;\n        if (infinite) {\n          var direction = siblingDirection(_objectSpread(_objectSpread({}, spec), {}, {\n            targetSlide\n          }));\n          if (targetSlide > options.currentSlide && direction === \"left\") {\n            targetSlide = targetSlide - slideCount;\n          } else if (targetSlide < options.currentSlide && direction === \"right\") {\n            targetSlide = targetSlide + slideCount;\n          }\n        }\n      } else if (options.message === \"index\") {\n        targetSlide = Number(options.index);\n      }\n      return targetSlide;\n    };\n    exports.changeSlide = changeSlide;\n    var keyHandler = function keyHandler2(e, accessibility, rtl) {\n      if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility)\n        return \"\";\n      if (e.keyCode === 37)\n        return rtl ? \"next\" : \"previous\";\n      if (e.keyCode === 39)\n        return rtl ? \"previous\" : \"next\";\n      return \"\";\n    };\n    exports.keyHandler = keyHandler;\n    var swipeStart = function swipeStart2(e, swipe, draggable) {\n      e.target.tagName === \"IMG\" && safePreventDefault(e);\n      if (!swipe || !draggable && e.type.indexOf(\"mouse\") !== -1)\n        return \"\";\n      return {\n        dragging: true,\n        touchObject: {\n          startX: e.touches ? e.touches[0].pageX : e.clientX,\n          startY: e.touches ? e.touches[0].pageY : e.clientY,\n          curX: e.touches ? e.touches[0].pageX : e.clientX,\n          curY: e.touches ? e.touches[0].pageY : e.clientY\n        }\n      };\n    };\n    exports.swipeStart = swipeStart;\n    var swipeMove = function swipeMove2(e, spec) {\n      var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;\n      if (scrolling)\n        return;\n      if (animating)\n        return safePreventDefault(e);\n      if (vertical && swipeToSlide && verticalSwiping)\n        safePreventDefault(e);\n      var swipeLeft, state = {};\n      var curLeft = getTrackLeft(spec);\n      touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n      touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n      touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n      var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n      if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n        return {\n          scrolling: true\n        };\n      }\n      if (verticalSwiping)\n        touchObject.swipeLength = verticalSwipeLength;\n      var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n      if (verticalSwiping)\n        positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n      var dotCount = Math.ceil(slideCount / slidesToScroll);\n      var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n      var touchSwipeLength = touchObject.swipeLength;\n      if (!infinite) {\n        if (currentSlide === 0 && (swipeDirection === \"right\" || swipeDirection === \"down\") || currentSlide + 1 >= dotCount && (swipeDirection === \"left\" || swipeDirection === \"up\") || !canGoNext(spec) && (swipeDirection === \"left\" || swipeDirection === \"up\")) {\n          touchSwipeLength = touchObject.swipeLength * edgeFriction;\n          if (edgeDragged === false && onEdge) {\n            onEdge(swipeDirection);\n            state[\"edgeDragged\"] = true;\n          }\n        }\n      }\n      if (!swiped && swipeEvent) {\n        swipeEvent(swipeDirection);\n        state[\"swiped\"] = true;\n      }\n      if (!vertical) {\n        if (!rtl) {\n          swipeLeft = curLeft + touchSwipeLength * positionOffset;\n        } else {\n          swipeLeft = curLeft - touchSwipeLength * positionOffset;\n        }\n      } else {\n        swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n      }\n      if (verticalSwiping) {\n        swipeLeft = curLeft + touchSwipeLength * positionOffset;\n      }\n      state = _objectSpread(_objectSpread({}, state), {}, {\n        touchObject,\n        swipeLeft,\n        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: swipeLeft\n        }))\n      });\n      if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n        return state;\n      }\n      if (touchObject.swipeLength > 10) {\n        state[\"swiping\"] = true;\n        safePreventDefault(e);\n      }\n      return state;\n    };\n    exports.swipeMove = swipeMove;\n    var swipeEnd = function swipeEnd2(e, spec) {\n      var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;\n      if (!dragging) {\n        if (swipe)\n          safePreventDefault(e);\n        return {};\n      }\n      var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n      var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);\n      var state = {\n        dragging: false,\n        edgeDragged: false,\n        scrolling: false,\n        swiping: false,\n        swiped: false,\n        swipeLeft: null,\n        touchObject: {}\n      };\n      if (scrolling) {\n        return state;\n      }\n      if (!touchObject.swipeLength) {\n        return state;\n      }\n      if (touchObject.swipeLength > minSwipe) {\n        safePreventDefault(e);\n        if (onSwipe) {\n          onSwipe(swipeDirection);\n        }\n        var slideCount, newSlide;\n        var activeSlide = infinite ? currentSlide : targetSlide;\n        switch (swipeDirection) {\n          case \"left\":\n          case \"up\":\n            newSlide = activeSlide + getSlideCount(spec);\n            slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n            state[\"currentDirection\"] = 0;\n            break;\n          case \"right\":\n          case \"down\":\n            newSlide = activeSlide - getSlideCount(spec);\n            slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n            state[\"currentDirection\"] = 1;\n            break;\n          default:\n            slideCount = activeSlide;\n        }\n        state[\"triggerSlideHandler\"] = slideCount;\n      } else {\n        var currentLeft = getTrackLeft(spec);\n        state[\"trackStyle\"] = getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: currentLeft\n        }));\n      }\n      return state;\n    };\n    exports.swipeEnd = swipeEnd;\n    var getNavigableIndexes = function getNavigableIndexes2(spec) {\n      var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n      var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n      var counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n      var indexes = [];\n      while (breakpoint < max) {\n        indexes.push(breakpoint);\n        breakpoint = counter + spec.slidesToScroll;\n        counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n      }\n      return indexes;\n    };\n    exports.getNavigableIndexes = getNavigableIndexes;\n    var checkNavigable = function checkNavigable2(spec, index2) {\n      var navigables = getNavigableIndexes(spec);\n      var prevNavigable = 0;\n      if (index2 > navigables[navigables.length - 1]) {\n        index2 = navigables[navigables.length - 1];\n      } else {\n        for (var n in navigables) {\n          if (index2 < navigables[n]) {\n            index2 = prevNavigable;\n            break;\n          }\n          prevNavigable = navigables[n];\n        }\n      }\n      return index2;\n    };\n    exports.checkNavigable = checkNavigable;\n    var getSlideCount = function getSlideCount2(spec) {\n      var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n      if (spec.swipeToSlide) {\n        var swipedSlide;\n        var slickList = spec.listRef;\n        var slides = slickList.querySelectorAll && slickList.querySelectorAll(\".slick-slide\") || [];\n        Array.from(slides).every(function(slide) {\n          if (!spec.vertical) {\n            if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n              swipedSlide = slide;\n              return false;\n            }\n          } else {\n            if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n              swipedSlide = slide;\n              return false;\n            }\n          }\n          return true;\n        });\n        if (!swipedSlide) {\n          return 0;\n        }\n        var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n        var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n        return slidesTraversed;\n      } else {\n        return spec.slidesToScroll;\n      }\n    };\n    exports.getSlideCount = getSlideCount;\n    var checkSpecKeys = function checkSpecKeys2(spec, keysArray) {\n      return keysArray.reduce(function(value, key) {\n        return value && spec.hasOwnProperty(key);\n      }, true) ? null : console.error(\"Keys Missing:\", spec);\n    };\n    exports.checkSpecKeys = checkSpecKeys;\n    var getTrackCSS = function getTrackCSS2(spec) {\n      checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\"]);\n      var trackWidth, trackHeight;\n      var trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n      if (!spec.vertical) {\n        trackWidth = getTotalSlides(spec) * spec.slideWidth;\n      } else {\n        trackHeight = trackChildren * spec.slideHeight;\n      }\n      var style = {\n        opacity: 1,\n        transition: \"\",\n        WebkitTransition: \"\"\n      };\n      if (spec.useTransform) {\n        var WebkitTransform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n        var transform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n        var msTransform = !spec.vertical ? \"translateX(\" + spec.left + \"px)\" : \"translateY(\" + spec.left + \"px)\";\n        style = _objectSpread(_objectSpread({}, style), {}, {\n          WebkitTransform,\n          transform,\n          msTransform\n        });\n      } else {\n        if (spec.vertical) {\n          style[\"top\"] = spec.left;\n        } else {\n          style[\"left\"] = spec.left;\n        }\n      }\n      if (spec.fade)\n        style = {\n          opacity: 1\n        };\n      if (trackWidth)\n        style.width = trackWidth;\n      if (trackHeight)\n        style.height = trackHeight;\n      if (window && !window.addEventListener && window.attachEvent) {\n        if (!spec.vertical) {\n          style.marginLeft = spec.left + \"px\";\n        } else {\n          style.marginTop = spec.left + \"px\";\n        }\n      }\n      return style;\n    };\n    exports.getTrackCSS = getTrackCSS;\n    var getTrackAnimateCSS = function getTrackAnimateCSS2(spec) {\n      checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\", \"speed\", \"cssEase\"]);\n      var style = getTrackCSS(spec);\n      if (spec.useTransform) {\n        style.WebkitTransition = \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase;\n        style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase;\n      } else {\n        if (spec.vertical) {\n          style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase;\n        } else {\n          style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase;\n        }\n      }\n      return style;\n    };\n    exports.getTrackAnimateCSS = getTrackAnimateCSS;\n    var getTrackLeft = function getTrackLeft2(spec) {\n      if (spec.unslick) {\n        return 0;\n      }\n      checkSpecKeys(spec, [\"slideIndex\", \"trackRef\", \"infinite\", \"centerMode\", \"slideCount\", \"slidesToShow\", \"slidesToScroll\", \"slideWidth\", \"listWidth\", \"variableWidth\", \"slideHeight\"]);\n      var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;\n      var slideOffset = 0;\n      var targetLeft;\n      var targetSlide;\n      var verticalOffset = 0;\n      if (fade || spec.slideCount === 1) {\n        return 0;\n      }\n      var slidesToOffset = 0;\n      if (infinite) {\n        slidesToOffset = -getPreClones(spec);\n        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n          slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n        }\n        if (centerMode) {\n          slidesToOffset += parseInt(slidesToShow / 2);\n        }\n      } else {\n        if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n          slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n        }\n        if (centerMode) {\n          slidesToOffset = parseInt(slidesToShow / 2);\n        }\n      }\n      slideOffset = slidesToOffset * slideWidth;\n      verticalOffset = slidesToOffset * slideHeight;\n      if (!vertical) {\n        targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n      } else {\n        targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n      }\n      if (variableWidth === true) {\n        var targetSlideIndex;\n        var trackElem = trackRef && trackRef.node;\n        targetSlideIndex = slideIndex + getPreClones(spec);\n        targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n        targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n        if (centerMode === true) {\n          targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n          targetSlide = trackElem && trackElem.children[targetSlideIndex];\n          targetLeft = 0;\n          for (var slide = 0; slide < targetSlideIndex; slide++) {\n            targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n          }\n          targetLeft -= parseInt(spec.centerPadding);\n          targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n        }\n      }\n      return targetLeft;\n    };\n    exports.getTrackLeft = getTrackLeft;\n    var getPreClones = function getPreClones2(spec) {\n      if (spec.unslick || !spec.infinite) {\n        return 0;\n      }\n      if (spec.variableWidth) {\n        return spec.slideCount;\n      }\n      return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n    };\n    exports.getPreClones = getPreClones;\n    var getPostClones = function getPostClones2(spec) {\n      if (spec.unslick || !spec.infinite) {\n        return 0;\n      }\n      return spec.slideCount;\n    };\n    exports.getPostClones = getPostClones;\n    var getTotalSlides = function getTotalSlides2(spec) {\n      return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\n    };\n    exports.getTotalSlides = getTotalSlides;\n    var siblingDirection = function siblingDirection2(spec) {\n      if (spec.targetSlide > spec.currentSlide) {\n        if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n          return \"left\";\n        }\n        return \"right\";\n      } else {\n        if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n          return \"right\";\n        }\n        return \"left\";\n      }\n    };\n    exports.siblingDirection = siblingDirection;\n    var slidesOnRight = function slidesOnRight2(_ref) {\n      var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;\n      if (centerMode) {\n        var right = (slidesToShow - 1) / 2 + 1;\n        if (parseInt(centerPadding) > 0)\n          right += 1;\n        if (rtl && slidesToShow % 2 === 0)\n          right += 1;\n        return right;\n      }\n      if (rtl) {\n        return 0;\n      }\n      return slidesToShow - 1;\n    };\n    exports.slidesOnRight = slidesOnRight;\n    var slidesOnLeft = function slidesOnLeft2(_ref2) {\n      var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;\n      if (centerMode) {\n        var left = (slidesToShow - 1) / 2 + 1;\n        if (parseInt(centerPadding) > 0)\n          left += 1;\n        if (!rtl && slidesToShow % 2 === 0)\n          left += 1;\n        return left;\n      }\n      if (rtl) {\n        return slidesToShow - 1;\n      }\n      return 0;\n    };\n    exports.slidesOnLeft = slidesOnLeft;\n    var canUseDOM = function canUseDOM2() {\n      return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n    };\n    exports.canUseDOM = canUseDOM;\n  }\n});\n\n// node_modules/react-slick/lib/track.js\nvar require_track = __commonJS({\n  \"node_modules/react-slick/lib/track.js\"(exports) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.Track = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _classnames = _interopRequireDefault(require_classnames());\n    var _innerSliderUtils = require_innerSliderUtils();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var getSlideClasses = function getSlideClasses2(spec) {\n      var slickActive, slickCenter, slickCloned;\n      var centerOffset, index2;\n      if (spec.rtl) {\n        index2 = spec.slideCount - 1 - spec.index;\n      } else {\n        index2 = spec.index;\n      }\n      slickCloned = index2 < 0 || index2 >= spec.slideCount;\n      if (spec.centerMode) {\n        centerOffset = Math.floor(spec.slidesToShow / 2);\n        slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;\n        if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {\n          slickActive = true;\n        }\n      } else {\n        slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;\n      }\n      var focusedSlide;\n      if (spec.targetSlide < 0) {\n        focusedSlide = spec.targetSlide + spec.slideCount;\n      } else if (spec.targetSlide >= spec.slideCount) {\n        focusedSlide = spec.targetSlide - spec.slideCount;\n      } else {\n        focusedSlide = spec.targetSlide;\n      }\n      var slickCurrent = index2 === focusedSlide;\n      return {\n        \"slick-slide\": true,\n        \"slick-active\": slickActive,\n        \"slick-center\": slickCenter,\n        \"slick-cloned\": slickCloned,\n        \"slick-current\": slickCurrent\n        // dubious in case of RTL\n      };\n    };\n    var getSlideStyle = function getSlideStyle2(spec) {\n      var style = {};\n      if (spec.variableWidth === void 0 || spec.variableWidth === false) {\n        style.width = spec.slideWidth;\n      }\n      if (spec.fade) {\n        style.position = \"relative\";\n        if (spec.vertical) {\n          style.top = -spec.index * parseInt(spec.slideHeight);\n        } else {\n          style.left = -spec.index * parseInt(spec.slideWidth);\n        }\n        style.opacity = spec.currentSlide === spec.index ? 1 : 0;\n        if (spec.useCSS) {\n          style.transition = \"opacity \" + spec.speed + \"ms \" + spec.cssEase + \", visibility \" + spec.speed + \"ms \" + spec.cssEase;\n        }\n      }\n      return style;\n    };\n    var getKey = function getKey2(child, fallbackKey) {\n      return child.key || fallbackKey;\n    };\n    var renderSlides = function renderSlides2(spec) {\n      var key;\n      var slides = [];\n      var preCloneSlides = [];\n      var postCloneSlides = [];\n      var childrenCount = _react[\"default\"].Children.count(spec.children);\n      var startIndex = (0, _innerSliderUtils.lazyStartIndex)(spec);\n      var endIndex = (0, _innerSliderUtils.lazyEndIndex)(spec);\n      _react[\"default\"].Children.forEach(spec.children, function(elem, index2) {\n        var child;\n        var childOnClickOptions = {\n          message: \"children\",\n          index: index2,\n          slidesToScroll: spec.slidesToScroll,\n          currentSlide: spec.currentSlide\n        };\n        if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {\n          child = elem;\n        } else {\n          child = _react[\"default\"].createElement(\"div\", null);\n        }\n        var childStyle = getSlideStyle(_objectSpread(_objectSpread({}, spec), {}, {\n          index: index2\n        }));\n        var slideClass = child.props.className || \"\";\n        var slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n          index: index2\n        }));\n        slides.push(_react[\"default\"].cloneElement(child, {\n          key: \"original\" + getKey(child, index2),\n          \"data-index\": index2,\n          className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n          tabIndex: \"-1\",\n          \"aria-hidden\": !slideClasses[\"slick-active\"],\n          style: _objectSpread(_objectSpread({\n            outline: \"none\"\n          }, child.props.style || {}), childStyle),\n          onClick: function onClick(e) {\n            child.props && child.props.onClick && child.props.onClick(e);\n            if (spec.focusOnSelect) {\n              spec.focusOnSelect(childOnClickOptions);\n            }\n          }\n        }));\n        if (spec.infinite && spec.fade === false) {\n          var preCloneNo = childrenCount - index2;\n          if (preCloneNo <= (0, _innerSliderUtils.getPreClones)(spec) && childrenCount !== spec.slidesToShow) {\n            key = -preCloneNo;\n            if (key >= startIndex) {\n              child = elem;\n            }\n            slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n              index: key\n            }));\n            preCloneSlides.push(_react[\"default\"].cloneElement(child, {\n              key: \"precloned\" + getKey(child, key),\n              \"data-index\": key,\n              tabIndex: \"-1\",\n              className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n              \"aria-hidden\": !slideClasses[\"slick-active\"],\n              style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n              onClick: function onClick(e) {\n                child.props && child.props.onClick && child.props.onClick(e);\n                if (spec.focusOnSelect) {\n                  spec.focusOnSelect(childOnClickOptions);\n                }\n              }\n            }));\n          }\n          if (childrenCount !== spec.slidesToShow) {\n            key = childrenCount + index2;\n            if (key < endIndex) {\n              child = elem;\n            }\n            slideClasses = getSlideClasses(_objectSpread(_objectSpread({}, spec), {}, {\n              index: key\n            }));\n            postCloneSlides.push(_react[\"default\"].cloneElement(child, {\n              key: \"postcloned\" + getKey(child, key),\n              \"data-index\": key,\n              tabIndex: \"-1\",\n              className: (0, _classnames[\"default\"])(slideClasses, slideClass),\n              \"aria-hidden\": !slideClasses[\"slick-active\"],\n              style: _objectSpread(_objectSpread({}, child.props.style || {}), childStyle),\n              onClick: function onClick(e) {\n                child.props && child.props.onClick && child.props.onClick(e);\n                if (spec.focusOnSelect) {\n                  spec.focusOnSelect(childOnClickOptions);\n                }\n              }\n            }));\n          }\n        }\n      });\n      if (spec.rtl) {\n        return preCloneSlides.concat(slides, postCloneSlides).reverse();\n      } else {\n        return preCloneSlides.concat(slides, postCloneSlides);\n      }\n    };\n    var Track = function(_React$PureComponent) {\n      _inherits(Track2, _React$PureComponent);\n      var _super = _createSuper(Track2);\n      function Track2() {\n        var _this;\n        _classCallCheck(this, Track2);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        _this = _super.call.apply(_super, [this].concat(args));\n        _defineProperty(_assertThisInitialized(_this), \"node\", null);\n        _defineProperty(_assertThisInitialized(_this), \"handleRef\", function(ref) {\n          _this.node = ref;\n        });\n        return _this;\n      }\n      _createClass(Track2, [{\n        key: \"render\",\n        value: function render() {\n          var slides = renderSlides(this.props);\n          var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;\n          var mouseEvents = {\n            onMouseEnter,\n            onMouseOver,\n            onMouseLeave\n          };\n          return _react[\"default\"].createElement(\"div\", _extends({\n            ref: this.handleRef,\n            className: \"slick-track\",\n            style: this.props.trackStyle\n          }, mouseEvents), slides);\n        }\n      }]);\n      return Track2;\n    }(_react[\"default\"].PureComponent);\n    exports.Track = Track;\n  }\n});\n\n// node_modules/react-slick/lib/dots.js\nvar require_dots = __commonJS({\n  \"node_modules/react-slick/lib/dots.js\"(exports) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.Dots = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _classnames = _interopRequireDefault(require_classnames());\n    var _innerSliderUtils = require_innerSliderUtils();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    var getDotCount = function getDotCount2(spec) {\n      var dots;\n      if (spec.infinite) {\n        dots = Math.ceil(spec.slideCount / spec.slidesToScroll);\n      } else {\n        dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;\n      }\n      return dots;\n    };\n    var Dots = function(_React$PureComponent) {\n      _inherits(Dots2, _React$PureComponent);\n      var _super = _createSuper(Dots2);\n      function Dots2() {\n        _classCallCheck(this, Dots2);\n        return _super.apply(this, arguments);\n      }\n      _createClass(Dots2, [{\n        key: \"clickHandler\",\n        value: function clickHandler(options, e) {\n          e.preventDefault();\n          this.props.clickHandler(options);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;\n          var dotCount = getDotCount({\n            slideCount,\n            slidesToScroll,\n            slidesToShow,\n            infinite\n          });\n          var mouseEvents = {\n            onMouseEnter,\n            onMouseOver,\n            onMouseLeave\n          };\n          var dots = [];\n          for (var i = 0; i < dotCount; i++) {\n            var _rightBound = (i + 1) * slidesToScroll - 1;\n            var rightBound = infinite ? _rightBound : (0, _innerSliderUtils.clamp)(_rightBound, 0, slideCount - 1);\n            var _leftBound = rightBound - (slidesToScroll - 1);\n            var leftBound = infinite ? _leftBound : (0, _innerSliderUtils.clamp)(_leftBound, 0, slideCount - 1);\n            var className = (0, _classnames[\"default\"])({\n              \"slick-active\": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound\n            });\n            var dotOptions = {\n              message: \"dots\",\n              index: i,\n              slidesToScroll,\n              currentSlide\n            };\n            var onClick = this.clickHandler.bind(this, dotOptions);\n            dots = dots.concat(_react[\"default\"].createElement(\"li\", {\n              key: i,\n              className\n            }, _react[\"default\"].cloneElement(this.props.customPaging(i), {\n              onClick\n            })));\n          }\n          return _react[\"default\"].cloneElement(this.props.appendDots(dots), _objectSpread({\n            className: this.props.dotsClass\n          }, mouseEvents));\n        }\n      }]);\n      return Dots2;\n    }(_react[\"default\"].PureComponent);\n    exports.Dots = Dots;\n  }\n});\n\n// node_modules/react-slick/lib/arrows.js\nvar require_arrows = __commonJS({\n  \"node_modules/react-slick/lib/arrows.js\"(exports) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.PrevArrow = exports.NextArrow = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _classnames = _interopRequireDefault(require_classnames());\n    var _innerSliderUtils = require_innerSliderUtils();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    var PrevArrow = function(_React$PureComponent) {\n      _inherits(PrevArrow2, _React$PureComponent);\n      var _super = _createSuper(PrevArrow2);\n      function PrevArrow2() {\n        _classCallCheck(this, PrevArrow2);\n        return _super.apply(this, arguments);\n      }\n      _createClass(PrevArrow2, [{\n        key: \"clickHandler\",\n        value: function clickHandler(options, e) {\n          if (e) {\n            e.preventDefault();\n          }\n          this.props.clickHandler(options, e);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var prevClasses = {\n            \"slick-arrow\": true,\n            \"slick-prev\": true\n          };\n          var prevHandler = this.clickHandler.bind(this, {\n            message: \"previous\"\n          });\n          if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {\n            prevClasses[\"slick-disabled\"] = true;\n            prevHandler = null;\n          }\n          var prevArrowProps = {\n            key: \"0\",\n            \"data-role\": \"none\",\n            className: (0, _classnames[\"default\"])(prevClasses),\n            style: {\n              display: \"block\"\n            },\n            onClick: prevHandler\n          };\n          var customProps = {\n            currentSlide: this.props.currentSlide,\n            slideCount: this.props.slideCount\n          };\n          var prevArrow;\n          if (this.props.prevArrow) {\n            prevArrow = _react[\"default\"].cloneElement(this.props.prevArrow, _objectSpread(_objectSpread({}, prevArrowProps), customProps));\n          } else {\n            prevArrow = _react[\"default\"].createElement(\"button\", _extends({\n              key: \"0\",\n              type: \"button\"\n            }, prevArrowProps), \" \", \"Previous\");\n          }\n          return prevArrow;\n        }\n      }]);\n      return PrevArrow2;\n    }(_react[\"default\"].PureComponent);\n    exports.PrevArrow = PrevArrow;\n    var NextArrow = function(_React$PureComponent2) {\n      _inherits(NextArrow2, _React$PureComponent2);\n      var _super2 = _createSuper(NextArrow2);\n      function NextArrow2() {\n        _classCallCheck(this, NextArrow2);\n        return _super2.apply(this, arguments);\n      }\n      _createClass(NextArrow2, [{\n        key: \"clickHandler\",\n        value: function clickHandler(options, e) {\n          if (e) {\n            e.preventDefault();\n          }\n          this.props.clickHandler(options, e);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var nextClasses = {\n            \"slick-arrow\": true,\n            \"slick-next\": true\n          };\n          var nextHandler = this.clickHandler.bind(this, {\n            message: \"next\"\n          });\n          if (!(0, _innerSliderUtils.canGoNext)(this.props)) {\n            nextClasses[\"slick-disabled\"] = true;\n            nextHandler = null;\n          }\n          var nextArrowProps = {\n            key: \"1\",\n            \"data-role\": \"none\",\n            className: (0, _classnames[\"default\"])(nextClasses),\n            style: {\n              display: \"block\"\n            },\n            onClick: nextHandler\n          };\n          var customProps = {\n            currentSlide: this.props.currentSlide,\n            slideCount: this.props.slideCount\n          };\n          var nextArrow;\n          if (this.props.nextArrow) {\n            nextArrow = _react[\"default\"].cloneElement(this.props.nextArrow, _objectSpread(_objectSpread({}, nextArrowProps), customProps));\n          } else {\n            nextArrow = _react[\"default\"].createElement(\"button\", _extends({\n              key: \"1\",\n              type: \"button\"\n            }, nextArrowProps), \" \", \"Next\");\n          }\n          return nextArrow;\n        }\n      }]);\n      return NextArrow2;\n    }(_react[\"default\"].PureComponent);\n    exports.NextArrow = NextArrow;\n  }\n});\n\n// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\nvar ResizeObserver_es_exports = {};\n__export(ResizeObserver_es_exports, {\n  default: () => ResizeObserver_es_default\n});\nfunction throttle(callback, delay) {\n  var leadingCall = false, trailingCall = false, lastCallTime = 0;\n  function resolvePending() {\n    if (leadingCall) {\n      leadingCall = false;\n      callback();\n    }\n    if (trailingCall) {\n      proxy();\n    }\n  }\n  function timeoutCallback() {\n    requestAnimationFrame$1(resolvePending);\n  }\n  function proxy() {\n    var timeStamp = Date.now();\n    if (leadingCall) {\n      if (timeStamp - lastCallTime < trailingTimeout) {\n        return;\n      }\n      trailingCall = true;\n    } else {\n      leadingCall = true;\n      trailingCall = false;\n      setTimeout(timeoutCallback, delay);\n    }\n    lastCallTime = timeStamp;\n  }\n  return proxy;\n}\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\nfunction getBordersSize(styles) {\n  var positions = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positions[_i - 1] = arguments[_i];\n  }\n  return positions.reduce(function(size, position) {\n    var value = styles[\"border-\" + position + \"-width\"];\n    return size + toFloat(value);\n  }, 0);\n}\nfunction getPaddings(styles) {\n  var positions = [\"top\", \"right\", \"bottom\", \"left\"];\n  var paddings = {};\n  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n    var position = positions_1[_i];\n    var value = styles[\"padding-\" + position];\n    paddings[position] = toFloat(value);\n  }\n  return paddings;\n}\nfunction getSVGContentRect(target) {\n  var bbox = target.getBBox();\n  return createRectInit(0, 0, bbox.width, bbox.height);\n}\nfunction getHTMLElementContentRect(target) {\n  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\n  if (!clientWidth && !clientHeight) {\n    return emptyRect;\n  }\n  var styles = getWindowOf(target).getComputedStyle(target);\n  var paddings = getPaddings(styles);\n  var horizPad = paddings.left + paddings.right;\n  var vertPad = paddings.top + paddings.bottom;\n  var width = toFloat(styles.width), height = toFloat(styles.height);\n  if (styles.boxSizing === \"border-box\") {\n    if (Math.round(width + horizPad) !== clientWidth) {\n      width -= getBordersSize(styles, \"left\", \"right\") + horizPad;\n    }\n    if (Math.round(height + vertPad) !== clientHeight) {\n      height -= getBordersSize(styles, \"top\", \"bottom\") + vertPad;\n    }\n  }\n  if (!isDocumentElement(target)) {\n    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n    var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n    if (Math.abs(vertScrollbar) !== 1) {\n      width -= vertScrollbar;\n    }\n    if (Math.abs(horizScrollbar) !== 1) {\n      height -= horizScrollbar;\n    }\n  }\n  return createRectInit(paddings.left, paddings.top, width, height);\n}\nfunction isDocumentElement(target) {\n  return target === getWindowOf(target).document.documentElement;\n}\nfunction getContentRect(target) {\n  if (!isBrowser) {\n    return emptyRect;\n  }\n  if (isSVGGraphicsElement(target)) {\n    return getSVGContentRect(target);\n  }\n  return getHTMLElementContentRect(target);\n}\nfunction createReadOnlyRect(_a) {\n  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n  var Constr = typeof DOMRectReadOnly !== \"undefined\" ? DOMRectReadOnly : Object;\n  var rect = Object.create(Constr.prototype);\n  defineConfigurable(rect, {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: height + y,\n    left: x\n  });\n  return rect;\n}\nfunction createRectInit(x, y, width, height) {\n  return { x, y, width, height };\n}\nvar MapShim, isBrowser, global$1, requestAnimationFrame$1, trailingTimeout, REFRESH_DELAY, transitionKeys, mutationObserverSupported, ResizeObserverController, defineConfigurable, getWindowOf, emptyRect, isSVGGraphicsElement, ResizeObservation, ResizeObserverEntry, ResizeObserverSPI, observers, ResizeObserver, index, ResizeObserver_es_default;\nvar init_ResizeObserver_es = __esm({\n  \"node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"() {\n    MapShim = function() {\n      if (typeof Map !== \"undefined\") {\n        return Map;\n      }\n      function getIndex(arr, key) {\n        var result = -1;\n        arr.some(function(entry, index2) {\n          if (entry[0] === key) {\n            result = index2;\n            return true;\n          }\n          return false;\n        });\n        return result;\n      }\n      return (\n        /** @class */\n        function() {\n          function class_1() {\n            this.__entries__ = [];\n          }\n          Object.defineProperty(class_1.prototype, \"size\", {\n            /**\n             * @returns {boolean}\n             */\n            get: function() {\n              return this.__entries__.length;\n            },\n            enumerable: true,\n            configurable: true\n          });\n          class_1.prototype.get = function(key) {\n            var index2 = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index2];\n            return entry && entry[1];\n          };\n          class_1.prototype.set = function(key, value) {\n            var index2 = getIndex(this.__entries__, key);\n            if (~index2) {\n              this.__entries__[index2][1] = value;\n            } else {\n              this.__entries__.push([key, value]);\n            }\n          };\n          class_1.prototype.delete = function(key) {\n            var entries = this.__entries__;\n            var index2 = getIndex(entries, key);\n            if (~index2) {\n              entries.splice(index2, 1);\n            }\n          };\n          class_1.prototype.has = function(key) {\n            return !!~getIndex(this.__entries__, key);\n          };\n          class_1.prototype.clear = function() {\n            this.__entries__.splice(0);\n          };\n          class_1.prototype.forEach = function(callback, ctx) {\n            if (ctx === void 0) {\n              ctx = null;\n            }\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n              var entry = _a[_i];\n              callback.call(ctx, entry[1], entry[0]);\n            }\n          };\n          return class_1;\n        }()\n      );\n    }();\n    isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.document === document;\n    global$1 = function() {\n      if (typeof global !== \"undefined\" && global.Math === Math) {\n        return global;\n      }\n      if (typeof self !== \"undefined\" && self.Math === Math) {\n        return self;\n      }\n      if (typeof window !== \"undefined\" && window.Math === Math) {\n        return window;\n      }\n      return Function(\"return this\")();\n    }();\n    requestAnimationFrame$1 = function() {\n      if (typeof requestAnimationFrame === \"function\") {\n        return requestAnimationFrame.bind(global$1);\n      }\n      return function(callback) {\n        return setTimeout(function() {\n          return callback(Date.now());\n        }, 1e3 / 60);\n      };\n    }();\n    trailingTimeout = 2;\n    REFRESH_DELAY = 20;\n    transitionKeys = [\"top\", \"right\", \"bottom\", \"left\", \"width\", \"height\", \"size\", \"weight\"];\n    mutationObserverSupported = typeof MutationObserver !== \"undefined\";\n    ResizeObserverController = /** @class */\n    function() {\n      function ResizeObserverController2() {\n        this.connected_ = false;\n        this.mutationEventsAdded_ = false;\n        this.mutationsObserver_ = null;\n        this.observers_ = [];\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n      }\n      ResizeObserverController2.prototype.addObserver = function(observer) {\n        if (!~this.observers_.indexOf(observer)) {\n          this.observers_.push(observer);\n        }\n        if (!this.connected_) {\n          this.connect_();\n        }\n      };\n      ResizeObserverController2.prototype.removeObserver = function(observer) {\n        var observers2 = this.observers_;\n        var index2 = observers2.indexOf(observer);\n        if (~index2) {\n          observers2.splice(index2, 1);\n        }\n        if (!observers2.length && this.connected_) {\n          this.disconnect_();\n        }\n      };\n      ResizeObserverController2.prototype.refresh = function() {\n        var changesDetected = this.updateObservers_();\n        if (changesDetected) {\n          this.refresh();\n        }\n      };\n      ResizeObserverController2.prototype.updateObservers_ = function() {\n        var activeObservers = this.observers_.filter(function(observer) {\n          return observer.gatherActive(), observer.hasActive();\n        });\n        activeObservers.forEach(function(observer) {\n          return observer.broadcastActive();\n        });\n        return activeObservers.length > 0;\n      };\n      ResizeObserverController2.prototype.connect_ = function() {\n        if (!isBrowser || this.connected_) {\n          return;\n        }\n        document.addEventListener(\"transitionend\", this.onTransitionEnd_);\n        window.addEventListener(\"resize\", this.refresh);\n        if (mutationObserverSupported) {\n          this.mutationsObserver_ = new MutationObserver(this.refresh);\n          this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n          });\n        } else {\n          document.addEventListener(\"DOMSubtreeModified\", this.refresh);\n          this.mutationEventsAdded_ = true;\n        }\n        this.connected_ = true;\n      };\n      ResizeObserverController2.prototype.disconnect_ = function() {\n        if (!isBrowser || !this.connected_) {\n          return;\n        }\n        document.removeEventListener(\"transitionend\", this.onTransitionEnd_);\n        window.removeEventListener(\"resize\", this.refresh);\n        if (this.mutationsObserver_) {\n          this.mutationsObserver_.disconnect();\n        }\n        if (this.mutationEventsAdded_) {\n          document.removeEventListener(\"DOMSubtreeModified\", this.refresh);\n        }\n        this.mutationsObserver_ = null;\n        this.mutationEventsAdded_ = false;\n        this.connected_ = false;\n      };\n      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {\n        var _b = _a.propertyName, propertyName = _b === void 0 ? \"\" : _b;\n        var isReflowProperty = transitionKeys.some(function(key) {\n          return !!~propertyName.indexOf(key);\n        });\n        if (isReflowProperty) {\n          this.refresh();\n        }\n      };\n      ResizeObserverController2.getInstance = function() {\n        if (!this.instance_) {\n          this.instance_ = new ResizeObserverController2();\n        }\n        return this.instance_;\n      };\n      ResizeObserverController2.instance_ = null;\n      return ResizeObserverController2;\n    }();\n    defineConfigurable = function(target, props) {\n      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n        var key = _a[_i];\n        Object.defineProperty(target, key, {\n          value: props[key],\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n      }\n      return target;\n    };\n    getWindowOf = function(target) {\n      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n      return ownerGlobal || global$1;\n    };\n    emptyRect = createRectInit(0, 0, 0, 0);\n    isSVGGraphicsElement = function() {\n      if (typeof SVGGraphicsElement !== \"undefined\") {\n        return function(target) {\n          return target instanceof getWindowOf(target).SVGGraphicsElement;\n        };\n      }\n      return function(target) {\n        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === \"function\";\n      };\n    }();\n    ResizeObservation = /** @class */\n    function() {\n      function ResizeObservation2(target) {\n        this.broadcastWidth = 0;\n        this.broadcastHeight = 0;\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\n        this.target = target;\n      }\n      ResizeObservation2.prototype.isActive = function() {\n        var rect = getContentRect(this.target);\n        this.contentRect_ = rect;\n        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n      };\n      ResizeObservation2.prototype.broadcastRect = function() {\n        var rect = this.contentRect_;\n        this.broadcastWidth = rect.width;\n        this.broadcastHeight = rect.height;\n        return rect;\n      };\n      return ResizeObservation2;\n    }();\n    ResizeObserverEntry = /** @class */\n    function() {\n      function ResizeObserverEntry2(target, rectInit) {\n        var contentRect = createReadOnlyRect(rectInit);\n        defineConfigurable(this, { target, contentRect });\n      }\n      return ResizeObserverEntry2;\n    }();\n    ResizeObserverSPI = /** @class */\n    function() {\n      function ResizeObserverSPI2(callback, controller, callbackCtx) {\n        this.activeObservations_ = [];\n        this.observations_ = new MapShim();\n        if (typeof callback !== \"function\") {\n          throw new TypeError(\"The callback provided as parameter 1 is not a function.\");\n        }\n        this.callback_ = callback;\n        this.controller_ = controller;\n        this.callbackCtx_ = callbackCtx;\n      }\n      ResizeObserverSPI2.prototype.observe = function(target) {\n        if (!arguments.length) {\n          throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        if (typeof Element === \"undefined\" || !(Element instanceof Object)) {\n          return;\n        }\n        if (!(target instanceof getWindowOf(target).Element)) {\n          throw new TypeError('parameter 1 is not of type \"Element\".');\n        }\n        var observations = this.observations_;\n        if (observations.has(target)) {\n          return;\n        }\n        observations.set(target, new ResizeObservation(target));\n        this.controller_.addObserver(this);\n        this.controller_.refresh();\n      };\n      ResizeObserverSPI2.prototype.unobserve = function(target) {\n        if (!arguments.length) {\n          throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        if (typeof Element === \"undefined\" || !(Element instanceof Object)) {\n          return;\n        }\n        if (!(target instanceof getWindowOf(target).Element)) {\n          throw new TypeError('parameter 1 is not of type \"Element\".');\n        }\n        var observations = this.observations_;\n        if (!observations.has(target)) {\n          return;\n        }\n        observations.delete(target);\n        if (!observations.size) {\n          this.controller_.removeObserver(this);\n        }\n      };\n      ResizeObserverSPI2.prototype.disconnect = function() {\n        this.clearActive();\n        this.observations_.clear();\n        this.controller_.removeObserver(this);\n      };\n      ResizeObserverSPI2.prototype.gatherActive = function() {\n        var _this = this;\n        this.clearActive();\n        this.observations_.forEach(function(observation) {\n          if (observation.isActive()) {\n            _this.activeObservations_.push(observation);\n          }\n        });\n      };\n      ResizeObserverSPI2.prototype.broadcastActive = function() {\n        if (!this.hasActive()) {\n          return;\n        }\n        var ctx = this.callbackCtx_;\n        var entries = this.activeObservations_.map(function(observation) {\n          return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n        });\n        this.callback_.call(ctx, entries, ctx);\n        this.clearActive();\n      };\n      ResizeObserverSPI2.prototype.clearActive = function() {\n        this.activeObservations_.splice(0);\n      };\n      ResizeObserverSPI2.prototype.hasActive = function() {\n        return this.activeObservations_.length > 0;\n      };\n      return ResizeObserverSPI2;\n    }();\n    observers = typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : new MapShim();\n    ResizeObserver = /** @class */\n    function() {\n      function ResizeObserver2(callback) {\n        if (!(this instanceof ResizeObserver2)) {\n          throw new TypeError(\"Cannot call a class as a function.\");\n        }\n        if (!arguments.length) {\n          throw new TypeError(\"1 argument required, but only 0 present.\");\n        }\n        var controller = ResizeObserverController.getInstance();\n        var observer = new ResizeObserverSPI(callback, controller, this);\n        observers.set(this, observer);\n      }\n      return ResizeObserver2;\n    }();\n    [\n      \"observe\",\n      \"unobserve\",\n      \"disconnect\"\n    ].forEach(function(method) {\n      ResizeObserver.prototype[method] = function() {\n        var _a;\n        return (_a = observers.get(this))[method].apply(_a, arguments);\n      };\n    });\n    index = function() {\n      if (typeof global$1.ResizeObserver !== \"undefined\") {\n        return global$1.ResizeObserver;\n      }\n      return ResizeObserver;\n    }();\n    ResizeObserver_es_default = index;\n  }\n});\n\n// node_modules/react-slick/lib/inner-slider.js\nvar require_inner_slider = __commonJS({\n  \"node_modules/react-slick/lib/inner-slider.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.InnerSlider = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _initialState = _interopRequireDefault(require_initial_state());\n    var _lodash = _interopRequireDefault(require_lodash());\n    var _classnames = _interopRequireDefault(require_classnames());\n    var _innerSliderUtils = require_innerSliderUtils();\n    var _track = require_track();\n    var _dots = require_dots();\n    var _arrows = require_arrows();\n    var _resizeObserverPolyfill = _interopRequireDefault((init_ResizeObserver_es(), __toCommonJS(ResizeObserver_es_exports)));\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function _objectWithoutProperties(source, excluded) {\n      if (source == null)\n        return {};\n      var target = _objectWithoutPropertiesLoose(source, excluded);\n      var key, i;\n      if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for (i = 0; i < sourceSymbolKeys.length; i++) {\n          key = sourceSymbolKeys[i];\n          if (excluded.indexOf(key) >= 0)\n            continue;\n          if (!Object.prototype.propertyIsEnumerable.call(source, key))\n            continue;\n          target[key] = source[key];\n        }\n      }\n      return target;\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n      if (source == null)\n        return {};\n      var target = {};\n      var sourceKeys = Object.keys(source);\n      var key, i;\n      for (i = 0; i < sourceKeys.length; i++) {\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0)\n          continue;\n        target[key] = source[key];\n      }\n      return target;\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var InnerSlider = function(_React$Component) {\n      _inherits(InnerSlider2, _React$Component);\n      var _super = _createSuper(InnerSlider2);\n      function InnerSlider2(props) {\n        var _this;\n        _classCallCheck(this, InnerSlider2);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"listRefHandler\", function(ref) {\n          return _this.list = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"trackRefHandler\", function(ref) {\n          return _this.track = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"adaptHeight\", function() {\n          if (_this.props.adaptiveHeight && _this.list) {\n            var elem = _this.list.querySelector('[data-index=\"'.concat(_this.state.currentSlide, '\"]'));\n            _this.list.style.height = (0, _innerSliderUtils.getHeight)(elem) + \"px\";\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function() {\n          _this.props.onInit && _this.props.onInit();\n          if (_this.props.lazyLoad) {\n            var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n            if (slidesToLoad.length > 0) {\n              _this.setState(function(prevState) {\n                return {\n                  lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n                };\n              });\n              if (_this.props.onLazyLoad) {\n                _this.props.onLazyLoad(slidesToLoad);\n              }\n            }\n          }\n          var spec = _objectSpread({\n            listRef: _this.list,\n            trackRef: _this.track\n          }, _this.props);\n          _this.updateState(spec, true, function() {\n            _this.adaptHeight();\n            _this.props.autoplay && _this.autoPlay(\"update\");\n          });\n          if (_this.props.lazyLoad === \"progressive\") {\n            _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);\n          }\n          _this.ro = new _resizeObserverPolyfill[\"default\"](function() {\n            if (_this.state.animating) {\n              _this.onWindowResized(false);\n              _this.callbackTimers.push(setTimeout(function() {\n                return _this.onWindowResized();\n              }, _this.props.speed));\n            } else {\n              _this.onWindowResized();\n            }\n          });\n          _this.ro.observe(_this.list);\n          document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(\".slick-slide\"), function(slide) {\n            slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;\n            slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;\n          });\n          if (window.addEventListener) {\n            window.addEventListener(\"resize\", _this.onWindowResized);\n          } else {\n            window.attachEvent(\"onresize\", _this.onWindowResized);\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentWillUnmount\", function() {\n          if (_this.animationEndCallback) {\n            clearTimeout(_this.animationEndCallback);\n          }\n          if (_this.lazyLoadTimer) {\n            clearInterval(_this.lazyLoadTimer);\n          }\n          if (_this.callbackTimers.length) {\n            _this.callbackTimers.forEach(function(timer) {\n              return clearTimeout(timer);\n            });\n            _this.callbackTimers = [];\n          }\n          if (window.addEventListener) {\n            window.removeEventListener(\"resize\", _this.onWindowResized);\n          } else {\n            window.detachEvent(\"onresize\", _this.onWindowResized);\n          }\n          if (_this.autoplayTimer) {\n            clearInterval(_this.autoplayTimer);\n          }\n          _this.ro.disconnect();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"componentDidUpdate\", function(prevProps) {\n          _this.checkImagesLoad();\n          _this.props.onReInit && _this.props.onReInit();\n          if (_this.props.lazyLoad) {\n            var slidesToLoad = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, _this.props), _this.state));\n            if (slidesToLoad.length > 0) {\n              _this.setState(function(prevState) {\n                return {\n                  lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n                };\n              });\n              if (_this.props.onLazyLoad) {\n                _this.props.onLazyLoad(slidesToLoad);\n              }\n            }\n          }\n          _this.adaptHeight();\n          var spec = _objectSpread(_objectSpread({\n            listRef: _this.list,\n            trackRef: _this.track\n          }, _this.props), _this.state);\n          var setTrackStyle = _this.didPropsChange(prevProps);\n          setTrackStyle && _this.updateState(spec, setTrackStyle, function() {\n            if (_this.state.currentSlide >= _react[\"default\"].Children.count(_this.props.children)) {\n              _this.changeSlide({\n                message: \"index\",\n                index: _react[\"default\"].Children.count(_this.props.children) - _this.props.slidesToShow,\n                currentSlide: _this.state.currentSlide\n              });\n            }\n            if (_this.props.autoplay) {\n              _this.autoPlay(\"update\");\n            } else {\n              _this.pause(\"paused\");\n            }\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onWindowResized\", function(setTrackStyle) {\n          if (_this.debouncedResize)\n            _this.debouncedResize.cancel();\n          _this.debouncedResize = (0, _lodash[\"default\"])(function() {\n            return _this.resizeWindow(setTrackStyle);\n          }, 50);\n          _this.debouncedResize();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"resizeWindow\", function() {\n          var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n          var isTrackMounted = Boolean(_this.track && _this.track.node);\n          if (!isTrackMounted)\n            return;\n          var spec = _objectSpread(_objectSpread({\n            listRef: _this.list,\n            trackRef: _this.track\n          }, _this.props), _this.state);\n          _this.updateState(spec, setTrackStyle, function() {\n            if (_this.props.autoplay)\n              _this.autoPlay(\"update\");\n            else\n              _this.pause(\"paused\");\n          });\n          _this.setState({\n            animating: false\n          });\n          clearTimeout(_this.animationEndCallback);\n          delete _this.animationEndCallback;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"updateState\", function(spec, setTrackStyle, callback) {\n          var updatedState = (0, _innerSliderUtils.initializedState)(spec);\n          spec = _objectSpread(_objectSpread(_objectSpread({}, spec), updatedState), {}, {\n            slideIndex: updatedState.currentSlide\n          });\n          var targetLeft = (0, _innerSliderUtils.getTrackLeft)(spec);\n          spec = _objectSpread(_objectSpread({}, spec), {}, {\n            left: targetLeft\n          });\n          var trackStyle = (0, _innerSliderUtils.getTrackCSS)(spec);\n          if (setTrackStyle || _react[\"default\"].Children.count(_this.props.children) !== _react[\"default\"].Children.count(spec.children)) {\n            updatedState[\"trackStyle\"] = trackStyle;\n          }\n          _this.setState(updatedState, callback);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"ssrInit\", function() {\n          if (_this.props.variableWidth) {\n            var _trackWidth = 0, _trackLeft = 0;\n            var childrenWidths = [];\n            var preClones = (0, _innerSliderUtils.getPreClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n              slideCount: _this.props.children.length\n            }));\n            var postClones = (0, _innerSliderUtils.getPostClones)(_objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n              slideCount: _this.props.children.length\n            }));\n            _this.props.children.forEach(function(child) {\n              childrenWidths.push(child.props.style.width);\n              _trackWidth += child.props.style.width;\n            });\n            for (var i = 0; i < preClones; i++) {\n              _trackLeft += childrenWidths[childrenWidths.length - 1 - i];\n              _trackWidth += childrenWidths[childrenWidths.length - 1 - i];\n            }\n            for (var _i = 0; _i < postClones; _i++) {\n              _trackWidth += childrenWidths[_i];\n            }\n            for (var _i2 = 0; _i2 < _this.state.currentSlide; _i2++) {\n              _trackLeft += childrenWidths[_i2];\n            }\n            var _trackStyle = {\n              width: _trackWidth + \"px\",\n              left: -_trackLeft + \"px\"\n            };\n            if (_this.props.centerMode) {\n              var currentWidth = \"\".concat(childrenWidths[_this.state.currentSlide], \"px\");\n              _trackStyle.left = \"calc(\".concat(_trackStyle.left, \" + (100% - \").concat(currentWidth, \") / 2 ) \");\n            }\n            return {\n              trackStyle: _trackStyle\n            };\n          }\n          var childrenCount = _react[\"default\"].Children.count(_this.props.children);\n          var spec = _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n            slideCount: childrenCount\n          });\n          var slideCount = (0, _innerSliderUtils.getPreClones)(spec) + (0, _innerSliderUtils.getPostClones)(spec) + childrenCount;\n          var trackWidth = 100 / _this.props.slidesToShow * slideCount;\n          var slideWidth = 100 / slideCount;\n          var trackLeft = -slideWidth * ((0, _innerSliderUtils.getPreClones)(spec) + _this.state.currentSlide) * trackWidth / 100;\n          if (_this.props.centerMode) {\n            trackLeft += (100 - slideWidth * trackWidth / 100) / 2;\n          }\n          var trackStyle = {\n            width: trackWidth + \"%\",\n            left: trackLeft + \"%\"\n          };\n          return {\n            slideWidth: slideWidth + \"%\",\n            trackStyle\n          };\n        });\n        _defineProperty(_assertThisInitialized(_this), \"checkImagesLoad\", function() {\n          var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(\".slick-slide img\") || [];\n          var imagesCount = images.length, loadedCount = 0;\n          Array.prototype.forEach.call(images, function(image) {\n            var handler = function handler2() {\n              return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();\n            };\n            if (!image.onclick) {\n              image.onclick = function() {\n                return image.parentNode.focus();\n              };\n            } else {\n              var prevClickHandler = image.onclick;\n              image.onclick = function() {\n                prevClickHandler();\n                image.parentNode.focus();\n              };\n            }\n            if (!image.onload) {\n              if (_this.props.lazyLoad) {\n                image.onload = function() {\n                  _this.adaptHeight();\n                  _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));\n                };\n              } else {\n                image.onload = handler;\n                image.onerror = function() {\n                  handler();\n                  _this.props.onLazyLoadError && _this.props.onLazyLoadError();\n                };\n              }\n            }\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"progressiveLazyLoad\", function() {\n          var slidesToLoad = [];\n          var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n          for (var index2 = _this.state.currentSlide; index2 < _this.state.slideCount + (0, _innerSliderUtils.getPostClones)(spec); index2++) {\n            if (_this.state.lazyLoadedList.indexOf(index2) < 0) {\n              slidesToLoad.push(index2);\n              break;\n            }\n          }\n          for (var _index = _this.state.currentSlide - 1; _index >= -(0, _innerSliderUtils.getPreClones)(spec); _index--) {\n            if (_this.state.lazyLoadedList.indexOf(_index) < 0) {\n              slidesToLoad.push(_index);\n              break;\n            }\n          }\n          if (slidesToLoad.length > 0) {\n            _this.setState(function(state) {\n              return {\n                lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)\n              };\n            });\n            if (_this.props.onLazyLoad) {\n              _this.props.onLazyLoad(slidesToLoad);\n            }\n          } else {\n            if (_this.lazyLoadTimer) {\n              clearInterval(_this.lazyLoadTimer);\n              delete _this.lazyLoadTimer;\n            }\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slideHandler\", function(index2) {\n          var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n          var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;\n          var currentSlide = _this.state.currentSlide;\n          var _slideHandler = (0, _innerSliderUtils.slideHandler)(_objectSpread(_objectSpread(_objectSpread({\n            index: index2\n          }, _this.props), _this.state), {}, {\n            trackRef: _this.track,\n            useCSS: _this.props.useCSS && !dontAnimate\n          })), state = _slideHandler.state, nextState = _slideHandler.nextState;\n          if (!state)\n            return;\n          beforeChange && beforeChange(currentSlide, state.currentSlide);\n          var slidesToLoad = state.lazyLoadedList.filter(function(value) {\n            return _this.state.lazyLoadedList.indexOf(value) < 0;\n          });\n          onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);\n          if (!_this.props.waitForAnimate && _this.animationEndCallback) {\n            clearTimeout(_this.animationEndCallback);\n            afterChange && afterChange(currentSlide);\n            delete _this.animationEndCallback;\n          }\n          _this.setState(state, function() {\n            if (asNavFor && _this.asNavForIndex !== index2) {\n              _this.asNavForIndex = index2;\n              asNavFor.innerSlider.slideHandler(index2);\n            }\n            if (!nextState)\n              return;\n            _this.animationEndCallback = setTimeout(function() {\n              var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, [\"animating\"]);\n              _this.setState(firstBatch, function() {\n                _this.callbackTimers.push(setTimeout(function() {\n                  return _this.setState({\n                    animating\n                  });\n                }, 10));\n                afterChange && afterChange(state.currentSlide);\n                delete _this.animationEndCallback;\n              });\n            }, speed);\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"changeSlide\", function(options) {\n          var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n          var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n          var targetSlide = (0, _innerSliderUtils.changeSlide)(spec, options);\n          if (targetSlide !== 0 && !targetSlide)\n            return;\n          if (dontAnimate === true) {\n            _this.slideHandler(targetSlide, dontAnimate);\n          } else {\n            _this.slideHandler(targetSlide);\n          }\n          _this.props.autoplay && _this.autoPlay(\"update\");\n          if (_this.props.focusOnSelect) {\n            var nodes = _this.list.querySelectorAll(\".slick-current\");\n            nodes[0] && nodes[0].focus();\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"clickHandler\", function(e) {\n          if (_this.clickable === false) {\n            e.stopPropagation();\n            e.preventDefault();\n          }\n          _this.clickable = true;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"keyHandler\", function(e) {\n          var dir = (0, _innerSliderUtils.keyHandler)(e, _this.props.accessibility, _this.props.rtl);\n          dir !== \"\" && _this.changeSlide({\n            message: dir\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"selectHandler\", function(options) {\n          _this.changeSlide(options);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"disableBodyScroll\", function() {\n          var preventDefault = function preventDefault2(e) {\n            e = e || window.event;\n            if (e.preventDefault)\n              e.preventDefault();\n            e.returnValue = false;\n          };\n          window.ontouchmove = preventDefault;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"enableBodyScroll\", function() {\n          window.ontouchmove = null;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeStart\", function(e) {\n          if (_this.props.verticalSwiping) {\n            _this.disableBodyScroll();\n          }\n          var state = (0, _innerSliderUtils.swipeStart)(e, _this.props.swipe, _this.props.draggable);\n          state !== \"\" && _this.setState(state);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeMove\", function(e) {\n          var state = (0, _innerSliderUtils.swipeMove)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n            trackRef: _this.track,\n            listRef: _this.list,\n            slideIndex: _this.state.currentSlide\n          }));\n          if (!state)\n            return;\n          if (state[\"swiping\"]) {\n            _this.clickable = false;\n          }\n          _this.setState(state);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"swipeEnd\", function(e) {\n          var state = (0, _innerSliderUtils.swipeEnd)(e, _objectSpread(_objectSpread(_objectSpread({}, _this.props), _this.state), {}, {\n            trackRef: _this.track,\n            listRef: _this.list,\n            slideIndex: _this.state.currentSlide\n          }));\n          if (!state)\n            return;\n          var triggerSlideHandler = state[\"triggerSlideHandler\"];\n          delete state[\"triggerSlideHandler\"];\n          _this.setState(state);\n          if (triggerSlideHandler === void 0)\n            return;\n          _this.slideHandler(triggerSlideHandler);\n          if (_this.props.verticalSwiping) {\n            _this.enableBodyScroll();\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"touchEnd\", function(e) {\n          _this.swipeEnd(e);\n          _this.clickable = true;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function() {\n          _this.callbackTimers.push(setTimeout(function() {\n            return _this.changeSlide({\n              message: \"previous\"\n            });\n          }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickNext\", function() {\n          _this.callbackTimers.push(setTimeout(function() {\n            return _this.changeSlide({\n              message: \"next\"\n            });\n          }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function(slide) {\n          var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n          slide = Number(slide);\n          if (isNaN(slide))\n            return \"\";\n          _this.callbackTimers.push(setTimeout(function() {\n            return _this.changeSlide({\n              message: \"index\",\n              index: slide,\n              currentSlide: _this.state.currentSlide\n            }, dontAnimate);\n          }, 0));\n        });\n        _defineProperty(_assertThisInitialized(_this), \"play\", function() {\n          var nextIndex;\n          if (_this.props.rtl) {\n            nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;\n          } else {\n            if ((0, _innerSliderUtils.canGoNext)(_objectSpread(_objectSpread({}, _this.props), _this.state))) {\n              nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;\n            } else {\n              return false;\n            }\n          }\n          _this.slideHandler(nextIndex);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"autoPlay\", function(playType) {\n          if (_this.autoplayTimer) {\n            clearInterval(_this.autoplayTimer);\n          }\n          var autoplaying = _this.state.autoplaying;\n          if (playType === \"update\") {\n            if (autoplaying === \"hovered\" || autoplaying === \"focused\" || autoplaying === \"paused\") {\n              return;\n            }\n          } else if (playType === \"leave\") {\n            if (autoplaying === \"paused\" || autoplaying === \"focused\") {\n              return;\n            }\n          } else if (playType === \"blur\") {\n            if (autoplaying === \"paused\" || autoplaying === \"hovered\") {\n              return;\n            }\n          }\n          _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);\n          _this.setState({\n            autoplaying: \"playing\"\n          });\n        });\n        _defineProperty(_assertThisInitialized(_this), \"pause\", function(pauseType) {\n          if (_this.autoplayTimer) {\n            clearInterval(_this.autoplayTimer);\n            _this.autoplayTimer = null;\n          }\n          var autoplaying = _this.state.autoplaying;\n          if (pauseType === \"paused\") {\n            _this.setState({\n              autoplaying: \"paused\"\n            });\n          } else if (pauseType === \"focused\") {\n            if (autoplaying === \"hovered\" || autoplaying === \"playing\") {\n              _this.setState({\n                autoplaying: \"focused\"\n              });\n            }\n          } else {\n            if (autoplaying === \"playing\") {\n              _this.setState({\n                autoplaying: \"hovered\"\n              });\n            }\n          }\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDotsOver\", function() {\n          return _this.props.autoplay && _this.pause(\"hovered\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onDotsLeave\", function() {\n          return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTrackOver\", function() {\n          return _this.props.autoplay && _this.pause(\"hovered\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onTrackLeave\", function() {\n          return _this.props.autoplay && _this.state.autoplaying === \"hovered\" && _this.autoPlay(\"leave\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSlideFocus\", function() {\n          return _this.props.autoplay && _this.pause(\"focused\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"onSlideBlur\", function() {\n          return _this.props.autoplay && _this.state.autoplaying === \"focused\" && _this.autoPlay(\"blur\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"render\", function() {\n          var className = (0, _classnames[\"default\"])(\"slick-slider\", _this.props.className, {\n            \"slick-vertical\": _this.props.vertical,\n            \"slick-initialized\": true\n          });\n          var spec = _objectSpread(_objectSpread({}, _this.props), _this.state);\n          var trackProps = (0, _innerSliderUtils.extractObject)(spec, [\"fade\", \"cssEase\", \"speed\", \"infinite\", \"centerMode\", \"focusOnSelect\", \"currentSlide\", \"lazyLoad\", \"lazyLoadedList\", \"rtl\", \"slideWidth\", \"slideHeight\", \"listHeight\", \"vertical\", \"slidesToShow\", \"slidesToScroll\", \"slideCount\", \"trackStyle\", \"variableWidth\", \"unslick\", \"centerPadding\", \"targetSlide\", \"useCSS\"]);\n          var pauseOnHover = _this.props.pauseOnHover;\n          trackProps = _objectSpread(_objectSpread({}, trackProps), {}, {\n            onMouseEnter: pauseOnHover ? _this.onTrackOver : null,\n            onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,\n            onMouseOver: pauseOnHover ? _this.onTrackOver : null,\n            focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null\n          });\n          var dots;\n          if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {\n            var dotProps = (0, _innerSliderUtils.extractObject)(spec, [\"dotsClass\", \"slideCount\", \"slidesToShow\", \"currentSlide\", \"slidesToScroll\", \"clickHandler\", \"children\", \"customPaging\", \"infinite\", \"appendDots\"]);\n            var pauseOnDotsHover = _this.props.pauseOnDotsHover;\n            dotProps = _objectSpread(_objectSpread({}, dotProps), {}, {\n              clickHandler: _this.changeSlide,\n              onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,\n              onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,\n              onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null\n            });\n            dots = _react[\"default\"].createElement(_dots.Dots, dotProps);\n          }\n          var prevArrow, nextArrow;\n          var arrowProps = (0, _innerSliderUtils.extractObject)(spec, [\"infinite\", \"centerMode\", \"currentSlide\", \"slideCount\", \"slidesToShow\", \"prevArrow\", \"nextArrow\"]);\n          arrowProps.clickHandler = _this.changeSlide;\n          if (_this.props.arrows) {\n            prevArrow = _react[\"default\"].createElement(_arrows.PrevArrow, arrowProps);\n            nextArrow = _react[\"default\"].createElement(_arrows.NextArrow, arrowProps);\n          }\n          var verticalHeightStyle = null;\n          if (_this.props.vertical) {\n            verticalHeightStyle = {\n              height: _this.state.listHeight\n            };\n          }\n          var centerPaddingStyle = null;\n          if (_this.props.vertical === false) {\n            if (_this.props.centerMode === true) {\n              centerPaddingStyle = {\n                padding: \"0px \" + _this.props.centerPadding\n              };\n            }\n          } else {\n            if (_this.props.centerMode === true) {\n              centerPaddingStyle = {\n                padding: _this.props.centerPadding + \" 0px\"\n              };\n            }\n          }\n          var listStyle = _objectSpread(_objectSpread({}, verticalHeightStyle), centerPaddingStyle);\n          var touchMove = _this.props.touchMove;\n          var listProps = {\n            className: \"slick-list\",\n            style: listStyle,\n            onClick: _this.clickHandler,\n            onMouseDown: touchMove ? _this.swipeStart : null,\n            onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n            onMouseUp: touchMove ? _this.swipeEnd : null,\n            onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n            onTouchStart: touchMove ? _this.swipeStart : null,\n            onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,\n            onTouchEnd: touchMove ? _this.touchEnd : null,\n            onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,\n            onKeyDown: _this.props.accessibility ? _this.keyHandler : null\n          };\n          var innerSliderProps = {\n            className,\n            dir: \"ltr\",\n            style: _this.props.style\n          };\n          if (_this.props.unslick) {\n            listProps = {\n              className: \"slick-list\"\n            };\n            innerSliderProps = {\n              className\n            };\n          }\n          return _react[\"default\"].createElement(\"div\", innerSliderProps, !_this.props.unslick ? prevArrow : \"\", _react[\"default\"].createElement(\"div\", _extends({\n            ref: _this.listRefHandler\n          }, listProps), _react[\"default\"].createElement(_track.Track, _extends({\n            ref: _this.trackRefHandler\n          }, trackProps), _this.props.children)), !_this.props.unslick ? nextArrow : \"\", !_this.props.unslick ? dots : \"\");\n        });\n        _this.list = null;\n        _this.track = null;\n        _this.state = _objectSpread(_objectSpread({}, _initialState[\"default\"]), {}, {\n          currentSlide: _this.props.initialSlide,\n          slideCount: _react[\"default\"].Children.count(_this.props.children)\n        });\n        _this.callbackTimers = [];\n        _this.clickable = true;\n        _this.debouncedResize = null;\n        var ssrState = _this.ssrInit();\n        _this.state = _objectSpread(_objectSpread({}, _this.state), ssrState);\n        return _this;\n      }\n      _createClass(InnerSlider2, [{\n        key: \"didPropsChange\",\n        value: function didPropsChange(prevProps) {\n          var setTrackStyle = false;\n          for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {\n            var key = _Object$keys[_i3];\n            if (!prevProps.hasOwnProperty(key)) {\n              setTrackStyle = true;\n              break;\n            }\n            if (_typeof(prevProps[key]) === \"object\" || typeof prevProps[key] === \"function\") {\n              continue;\n            }\n            if (prevProps[key] !== this.props[key]) {\n              setTrackStyle = true;\n              break;\n            }\n          }\n          return setTrackStyle || _react[\"default\"].Children.count(this.props.children) !== _react[\"default\"].Children.count(prevProps.children);\n        }\n      }]);\n      return InnerSlider2;\n    }(_react[\"default\"].Component);\n    exports.InnerSlider = InnerSlider;\n  }\n});\n\n// node_modules/string-convert/camel2hyphen.js\nvar require_camel2hyphen = __commonJS({\n  \"node_modules/string-convert/camel2hyphen.js\"(exports, module) {\n    var camel2hyphen = function(str) {\n      return str.replace(/[A-Z]/g, function(match) {\n        return \"-\" + match.toLowerCase();\n      }).toLowerCase();\n    };\n    module.exports = camel2hyphen;\n  }\n});\n\n// node_modules/json2mq/index.js\nvar require_json2mq = __commonJS({\n  \"node_modules/json2mq/index.js\"(exports, module) {\n    var camel2hyphen = require_camel2hyphen();\n    var isDimension = function(feature) {\n      var re = /[height|width]$/;\n      return re.test(feature);\n    };\n    var obj2mq = function(obj) {\n      var mq = \"\";\n      var features = Object.keys(obj);\n      features.forEach(function(feature, index2) {\n        var value = obj[feature];\n        feature = camel2hyphen(feature);\n        if (isDimension(feature) && typeof value === \"number\") {\n          value = value + \"px\";\n        }\n        if (value === true) {\n          mq += feature;\n        } else if (value === false) {\n          mq += \"not \" + feature;\n        } else {\n          mq += \"(\" + feature + \": \" + value + \")\";\n        }\n        if (index2 < features.length - 1) {\n          mq += \" and \";\n        }\n      });\n      return mq;\n    };\n    var json2mq = function(query) {\n      var mq = \"\";\n      if (typeof query === \"string\") {\n        return query;\n      }\n      if (query instanceof Array) {\n        query.forEach(function(q, index2) {\n          mq += obj2mq(q);\n          if (index2 < query.length - 1) {\n            mq += \", \";\n          }\n        });\n        return mq;\n      }\n      return obj2mq(query);\n    };\n    module.exports = json2mq;\n  }\n});\n\n// node_modules/react-slick/lib/default-props.js\nvar require_default_props = __commonJS({\n  \"node_modules/react-slick/lib/default-props.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _react = _interopRequireDefault(require_react());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var defaultProps = {\n      accessibility: true,\n      adaptiveHeight: false,\n      afterChange: null,\n      appendDots: function appendDots(dots) {\n        return _react[\"default\"].createElement(\"ul\", {\n          style: {\n            display: \"block\"\n          }\n        }, dots);\n      },\n      arrows: true,\n      autoplay: false,\n      autoplaySpeed: 3e3,\n      beforeChange: null,\n      centerMode: false,\n      centerPadding: \"50px\",\n      className: \"\",\n      cssEase: \"ease\",\n      customPaging: function customPaging(i) {\n        return _react[\"default\"].createElement(\"button\", null, i + 1);\n      },\n      dots: false,\n      dotsClass: \"slick-dots\",\n      draggable: true,\n      easing: \"linear\",\n      edgeFriction: 0.35,\n      fade: false,\n      focusOnSelect: false,\n      infinite: true,\n      initialSlide: 0,\n      lazyLoad: null,\n      nextArrow: null,\n      onEdge: null,\n      onInit: null,\n      onLazyLoadError: null,\n      onReInit: null,\n      pauseOnDotsHover: false,\n      pauseOnFocus: false,\n      pauseOnHover: true,\n      prevArrow: null,\n      responsive: null,\n      rows: 1,\n      rtl: false,\n      slide: \"div\",\n      slidesPerRow: 1,\n      slidesToScroll: 1,\n      slidesToShow: 1,\n      speed: 500,\n      swipe: true,\n      swipeEvent: null,\n      swipeToSlide: false,\n      touchMove: true,\n      touchThreshold: 5,\n      useCSS: true,\n      useTransform: true,\n      variableWidth: false,\n      vertical: false,\n      waitForAnimate: true\n    };\n    var _default = defaultProps;\n    exports[\"default\"] = _default;\n  }\n});\n\n// node_modules/enquire.js/src/QueryHandler.js\nvar require_QueryHandler = __commonJS({\n  \"node_modules/enquire.js/src/QueryHandler.js\"(exports, module) {\n    function QueryHandler(options) {\n      this.options = options;\n      !options.deferSetup && this.setup();\n    }\n    QueryHandler.prototype = {\n      constructor: QueryHandler,\n      /**\n       * coordinates setup of the handler\n       *\n       * @function\n       */\n      setup: function() {\n        if (this.options.setup) {\n          this.options.setup();\n        }\n        this.initialised = true;\n      },\n      /**\n       * coordinates setup and triggering of the handler\n       *\n       * @function\n       */\n      on: function() {\n        !this.initialised && this.setup();\n        this.options.match && this.options.match();\n      },\n      /**\n       * coordinates the unmatch event for the handler\n       *\n       * @function\n       */\n      off: function() {\n        this.options.unmatch && this.options.unmatch();\n      },\n      /**\n       * called when a handler is to be destroyed.\n       * delegates to the destroy or unmatch callbacks, depending on availability.\n       *\n       * @function\n       */\n      destroy: function() {\n        this.options.destroy ? this.options.destroy() : this.off();\n      },\n      /**\n       * determines equality by reference.\n       * if object is supplied compare options, if function, compare match callback\n       *\n       * @function\n       * @param {object || function} [target] the target for comparison\n       */\n      equals: function(target) {\n        return this.options === target || this.options.match === target;\n      }\n    };\n    module.exports = QueryHandler;\n  }\n});\n\n// node_modules/enquire.js/src/Util.js\nvar require_Util = __commonJS({\n  \"node_modules/enquire.js/src/Util.js\"(exports, module) {\n    function each(collection, fn) {\n      var i = 0, length = collection.length, cont;\n      for (i; i < length; i++) {\n        cont = fn(collection[i], i);\n        if (cont === false) {\n          break;\n        }\n      }\n    }\n    function isArray(target) {\n      return Object.prototype.toString.apply(target) === \"[object Array]\";\n    }\n    function isFunction(target) {\n      return typeof target === \"function\";\n    }\n    module.exports = {\n      isFunction,\n      isArray,\n      each\n    };\n  }\n});\n\n// node_modules/enquire.js/src/MediaQuery.js\nvar require_MediaQuery = __commonJS({\n  \"node_modules/enquire.js/src/MediaQuery.js\"(exports, module) {\n    var QueryHandler = require_QueryHandler();\n    var each = require_Util().each;\n    function MediaQuery(query, isUnconditional) {\n      this.query = query;\n      this.isUnconditional = isUnconditional;\n      this.handlers = [];\n      this.mql = window.matchMedia(query);\n      var self2 = this;\n      this.listener = function(mql) {\n        self2.mql = mql.currentTarget || mql;\n        self2.assess();\n      };\n      this.mql.addListener(this.listener);\n    }\n    MediaQuery.prototype = {\n      constuctor: MediaQuery,\n      /**\n       * add a handler for this query, triggering if already active\n       *\n       * @param {object} handler\n       * @param {function} handler.match callback for when query is activated\n       * @param {function} [handler.unmatch] callback for when query is deactivated\n       * @param {function} [handler.setup] callback for immediate execution when a query handler is registered\n       * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?\n       */\n      addHandler: function(handler) {\n        var qh = new QueryHandler(handler);\n        this.handlers.push(qh);\n        this.matches() && qh.on();\n      },\n      /**\n       * removes the given handler from the collection, and calls it's destroy methods\n       *\n       * @param {object || function} handler the handler to remove\n       */\n      removeHandler: function(handler) {\n        var handlers = this.handlers;\n        each(handlers, function(h, i) {\n          if (h.equals(handler)) {\n            h.destroy();\n            return !handlers.splice(i, 1);\n          }\n        });\n      },\n      /**\n       * Determine whether the media query should be considered a match\n       *\n       * @return {Boolean} true if media query can be considered a match, false otherwise\n       */\n      matches: function() {\n        return this.mql.matches || this.isUnconditional;\n      },\n      /**\n       * Clears all handlers and unbinds events\n       */\n      clear: function() {\n        each(this.handlers, function(handler) {\n          handler.destroy();\n        });\n        this.mql.removeListener(this.listener);\n        this.handlers.length = 0;\n      },\n      /*\n          * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match\n          */\n      assess: function() {\n        var action = this.matches() ? \"on\" : \"off\";\n        each(this.handlers, function(handler) {\n          handler[action]();\n        });\n      }\n    };\n    module.exports = MediaQuery;\n  }\n});\n\n// node_modules/enquire.js/src/MediaQueryDispatch.js\nvar require_MediaQueryDispatch = __commonJS({\n  \"node_modules/enquire.js/src/MediaQueryDispatch.js\"(exports, module) {\n    var MediaQuery = require_MediaQuery();\n    var Util = require_Util();\n    var each = Util.each;\n    var isFunction = Util.isFunction;\n    var isArray = Util.isArray;\n    function MediaQueryDispatch() {\n      if (!window.matchMedia) {\n        throw new Error(\"matchMedia not present, legacy browsers require a polyfill\");\n      }\n      this.queries = {};\n      this.browserIsIncapable = !window.matchMedia(\"only all\").matches;\n    }\n    MediaQueryDispatch.prototype = {\n      constructor: MediaQueryDispatch,\n      /**\n       * Registers a handler for the given media query\n       *\n       * @param {string} q the media query\n       * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers\n       * @param {function} options.match fired when query matched\n       * @param {function} [options.unmatch] fired when a query is no longer matched\n       * @param {function} [options.setup] fired when handler first triggered\n       * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched\n       * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers\n       */\n      register: function(q, options, shouldDegrade) {\n        var queries = this.queries, isUnconditional = shouldDegrade && this.browserIsIncapable;\n        if (!queries[q]) {\n          queries[q] = new MediaQuery(q, isUnconditional);\n        }\n        if (isFunction(options)) {\n          options = { match: options };\n        }\n        if (!isArray(options)) {\n          options = [options];\n        }\n        each(options, function(handler) {\n          if (isFunction(handler)) {\n            handler = { match: handler };\n          }\n          queries[q].addHandler(handler);\n        });\n        return this;\n      },\n      /**\n       * unregisters a query and all it's handlers, or a specific handler for a query\n       *\n       * @param {string} q the media query to target\n       * @param {object || function} [handler] specific handler to unregister\n       */\n      unregister: function(q, handler) {\n        var query = this.queries[q];\n        if (query) {\n          if (handler) {\n            query.removeHandler(handler);\n          } else {\n            query.clear();\n            delete this.queries[q];\n          }\n        }\n        return this;\n      }\n    };\n    module.exports = MediaQueryDispatch;\n  }\n});\n\n// node_modules/enquire.js/src/index.js\nvar require_src = __commonJS({\n  \"node_modules/enquire.js/src/index.js\"(exports, module) {\n    var MediaQueryDispatch = require_MediaQueryDispatch();\n    module.exports = new MediaQueryDispatch();\n  }\n});\n\n// node_modules/react-slick/lib/slider.js\nvar require_slider = __commonJS({\n  \"node_modules/react-slick/lib/slider.js\"(exports) {\n    \"use strict\";\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj2) {\n        return typeof obj2;\n      } : function(obj2) {\n        return obj2 && \"function\" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _react = _interopRequireDefault(require_react());\n    var _innerSlider = require_inner_slider();\n    var _json2mq = _interopRequireDefault(require_json2mq());\n    var _defaultProps = _interopRequireDefault(require_default_props());\n    var _innerSliderUtils = require_innerSliderUtils();\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    function _extends() {\n      _extends = Object.assign || function(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      };\n      return _extends.apply(this, arguments);\n    }\n    function ownKeys(object, enumerableOnly) {\n      var keys = Object.keys(object);\n      if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n      }\n      return keys;\n    }\n    function _objectSpread(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n      return target;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor)\n          descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps)\n        _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps)\n        _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", { writable: false });\n      return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });\n      Object.defineProperty(subClass, \"prototype\", { writable: false });\n      if (superClass)\n        _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {\n        o2.__proto__ = p2;\n        return o2;\n      };\n      return _setPrototypeOf(o, p);\n    }\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n          result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n    function _possibleConstructorReturn(self2, call) {\n      if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n      } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n      }\n      return _assertThisInitialized(self2);\n    }\n    function _assertThisInitialized(self2) {\n      if (self2 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n      return self2;\n    }\n    function _isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct)\n        return false;\n      if (Reflect.construct.sham)\n        return false;\n      if (typeof Proxy === \"function\")\n        return true;\n      try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n        }));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      };\n      return _getPrototypeOf(o);\n    }\n    function _defineProperty(obj, key, value) {\n      if (key in obj) {\n        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    var enquire = (0, _innerSliderUtils.canUseDOM)() && require_src();\n    var Slider = function(_React$Component) {\n      _inherits(Slider2, _React$Component);\n      var _super = _createSuper(Slider2);\n      function Slider2(props) {\n        var _this;\n        _classCallCheck(this, Slider2);\n        _this = _super.call(this, props);\n        _defineProperty(_assertThisInitialized(_this), \"innerSliderRefHandler\", function(ref) {\n          return _this.innerSlider = ref;\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPrev\", function() {\n          return _this.innerSlider.slickPrev();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickNext\", function() {\n          return _this.innerSlider.slickNext();\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickGoTo\", function(slide) {\n          var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n          return _this.innerSlider.slickGoTo(slide, dontAnimate);\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPause\", function() {\n          return _this.innerSlider.pause(\"paused\");\n        });\n        _defineProperty(_assertThisInitialized(_this), \"slickPlay\", function() {\n          return _this.innerSlider.autoPlay(\"play\");\n        });\n        _this.state = {\n          breakpoint: null\n        };\n        _this._responsiveMediaHandlers = [];\n        return _this;\n      }\n      _createClass(Slider2, [{\n        key: \"media\",\n        value: function media(query, handler) {\n          enquire.register(query, handler);\n          this._responsiveMediaHandlers.push({\n            query,\n            handler\n          });\n        }\n        // handles responsive breakpoints\n      }, {\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          var _this2 = this;\n          if (this.props.responsive) {\n            var breakpoints = this.props.responsive.map(function(breakpt) {\n              return breakpt.breakpoint;\n            });\n            breakpoints.sort(function(x, y) {\n              return x - y;\n            });\n            breakpoints.forEach(function(breakpoint, index2) {\n              var bQuery;\n              if (index2 === 0) {\n                bQuery = (0, _json2mq[\"default\"])({\n                  minWidth: 0,\n                  maxWidth: breakpoint\n                });\n              } else {\n                bQuery = (0, _json2mq[\"default\"])({\n                  minWidth: breakpoints[index2 - 1] + 1,\n                  maxWidth: breakpoint\n                });\n              }\n              (0, _innerSliderUtils.canUseDOM)() && _this2.media(bQuery, function() {\n                _this2.setState({\n                  breakpoint\n                });\n              });\n            });\n            var query = (0, _json2mq[\"default\"])({\n              minWidth: breakpoints.slice(-1)[0]\n            });\n            (0, _innerSliderUtils.canUseDOM)() && this.media(query, function() {\n              _this2.setState({\n                breakpoint: null\n              });\n            });\n          }\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this._responsiveMediaHandlers.forEach(function(obj) {\n            enquire.unregister(obj.query, obj.handler);\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _this3 = this;\n          var settings;\n          var newProps;\n          if (this.state.breakpoint) {\n            newProps = this.props.responsive.filter(function(resp) {\n              return resp.breakpoint === _this3.state.breakpoint;\n            });\n            settings = newProps[0].settings === \"unslick\" ? \"unslick\" : _objectSpread(_objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props), newProps[0].settings);\n          } else {\n            settings = _objectSpread(_objectSpread({}, _defaultProps[\"default\"]), this.props);\n          }\n          if (settings.centerMode) {\n            if (settings.slidesToScroll > 1 && true) {\n              console.warn(\"slidesToScroll should be equal to 1 in centerMode, you are using \".concat(settings.slidesToScroll));\n            }\n            settings.slidesToScroll = 1;\n          }\n          if (settings.fade) {\n            if (settings.slidesToShow > 1 && true) {\n              console.warn(\"slidesToShow should be equal to 1 when fade is true, you're using \".concat(settings.slidesToShow));\n            }\n            if (settings.slidesToScroll > 1 && true) {\n              console.warn(\"slidesToScroll should be equal to 1 when fade is true, you're using \".concat(settings.slidesToScroll));\n            }\n            settings.slidesToShow = 1;\n            settings.slidesToScroll = 1;\n          }\n          var children = _react[\"default\"].Children.toArray(this.props.children);\n          children = children.filter(function(child) {\n            if (typeof child === \"string\") {\n              return !!child.trim();\n            }\n            return !!child;\n          });\n          if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {\n            console.warn(\"variableWidth is not supported in case of rows > 1 or slidesPerRow > 1\");\n            settings.variableWidth = false;\n          }\n          var newChildren = [];\n          var currentWidth = null;\n          for (var i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {\n            var newSlide = [];\n            for (var j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {\n              var row = [];\n              for (var k = j; k < j + settings.slidesPerRow; k += 1) {\n                if (settings.variableWidth && children[k].props.style) {\n                  currentWidth = children[k].props.style.width;\n                }\n                if (k >= children.length)\n                  break;\n                row.push(_react[\"default\"].cloneElement(children[k], {\n                  key: 100 * i + 10 * j + k,\n                  tabIndex: -1,\n                  style: {\n                    width: \"\".concat(100 / settings.slidesPerRow, \"%\"),\n                    display: \"inline-block\"\n                  }\n                }));\n              }\n              newSlide.push(_react[\"default\"].createElement(\"div\", {\n                key: 10 * i + j\n              }, row));\n            }\n            if (settings.variableWidth) {\n              newChildren.push(_react[\"default\"].createElement(\"div\", {\n                key: i,\n                style: {\n                  width: currentWidth\n                }\n              }, newSlide));\n            } else {\n              newChildren.push(_react[\"default\"].createElement(\"div\", {\n                key: i\n              }, newSlide));\n            }\n          }\n          if (settings === \"unslick\") {\n            var className = \"regular slider \" + (this.props.className || \"\");\n            return _react[\"default\"].createElement(\"div\", {\n              className\n            }, children);\n          } else if (newChildren.length <= settings.slidesToShow) {\n            settings.unslick = true;\n          }\n          return _react[\"default\"].createElement(_innerSlider.InnerSlider, _extends({\n            style: this.props.style,\n            ref: this.innerSliderRefHandler\n          }, settings), newChildren);\n        }\n      }]);\n      return Slider2;\n    }(_react[\"default\"].Component);\n    exports[\"default\"] = Slider;\n  }\n});\n\n// node_modules/react-slick/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/react-slick/lib/index.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = void 0;\n    var _slider = _interopRequireDefault(require_slider());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var _default = _slider[\"default\"];\n    exports[\"default\"] = _default;\n  }\n});\nexport default require_lib();\n/*! Bundled license information:\n\nclassnames/index.js:\n  (*!\n  \tCopyright (c) 2018 Jed Watson.\n  \tLicensed under the MIT License (MIT), see\n  \thttp://jedwatson.github.io/classnames\n  *)\n*/\n//# sourceMappingURL=react-slick.js.map\n",
      "start": 1701766112803,
      "end": 1701766112805,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
