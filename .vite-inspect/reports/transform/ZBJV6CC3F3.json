{
  "resolvedId": "C:/Users/ryan.wong/Desktop/dev/TourneyPro_v2/node_modules/.vite/deps/chunk-B7GYBXJM.js?v=c929456e",
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "// node_modules/@firebase/util/dist/index.esm2017.js\nvar stringToByteArray$1 = function(str) {\n  const out = [];\n  let p = 0;\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = c >> 6 | 192;\n      out[p++] = c & 63 | 128;\n    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {\n      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);\n      out[p++] = c >> 18 | 240;\n      out[p++] = c >> 12 & 63 | 128;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    } else {\n      out[p++] = c >> 12 | 224;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    }\n  }\n  return out;\n};\nvar byteArrayToString = function(bytes) {\n  const out = [];\n  let pos = 0, c = 0;\n  while (pos < bytes.length) {\n    const c1 = bytes[pos++];\n    if (c1 < 128) {\n      out[c++] = String.fromCharCode(c1);\n    } else if (c1 > 191 && c1 < 224) {\n      const c2 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n    } else if (c1 > 239 && c1 < 365) {\n      const c2 = bytes[pos++];\n      const c3 = bytes[pos++];\n      const c4 = bytes[pos++];\n      const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;\n      out[c++] = String.fromCharCode(55296 + (u >> 10));\n      out[c++] = String.fromCharCode(56320 + (u & 1023));\n    } else {\n      const c2 = bytes[pos++];\n      const c3 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n    }\n  }\n  return out.join(\"\");\n};\nvar base64 = {\n  /**\n   * Maps bytes to characters.\n   */\n  byteToCharMap_: null,\n  /**\n   * Maps characters to bytes.\n   */\n  charToByteMap_: null,\n  /**\n   * Maps bytes to websafe characters.\n   * @private\n   */\n  byteToCharMapWebSafe_: null,\n  /**\n   * Maps websafe characters to bytes.\n   * @private\n   */\n  charToByteMapWebSafe_: null,\n  /**\n   * Our default alphabet, shared between\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n   */\n  ENCODED_VALS_BASE: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n  /**\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + \"+/=\";\n  },\n  /**\n   * Our websafe alphabet.\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + \"-_.\";\n  },\n  /**\n   * Whether this browser supports the atob and btoa functions. This extension\n   * started at Mozilla but is now implemented by many browsers. We use the\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\n   * but still allowing the standard per-browser compilations.\n   *\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === \"function\",\n  /**\n   * Base64-encode an array of bytes.\n   *\n   * @param input An array of bytes (numbers with\n   *     value in [0, 255]) to encode.\n   * @param webSafe Boolean indicating we should use the\n   *     alternative alphabet.\n   * @return The base64 encoded string.\n   */\n  encodeByteArray(input, webSafe) {\n    if (!Array.isArray(input)) {\n      throw Error(\"encodeByteArray takes an array as a parameter\");\n    }\n    this.init_();\n    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n    const output = [];\n    for (let i = 0; i < input.length; i += 3) {\n      const byte1 = input[i];\n      const haveByte2 = i + 1 < input.length;\n      const byte2 = haveByte2 ? input[i + 1] : 0;\n      const haveByte3 = i + 2 < input.length;\n      const byte3 = haveByte3 ? input[i + 2] : 0;\n      const outByte1 = byte1 >> 2;\n      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;\n      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;\n      let outByte4 = byte3 & 63;\n      if (!haveByte3) {\n        outByte4 = 64;\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n    }\n    return output.join(\"\");\n  },\n  /**\n   * Base64-encode a string.\n   *\n   * @param input A string to encode.\n   * @param webSafe If true, we should use the\n   *     alternative alphabet.\n   * @return The base64 encoded string.\n   */\n  encodeString(input, webSafe) {\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return btoa(input);\n    }\n    return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n  },\n  /**\n   * Base64-decode a string.\n   *\n   * @param input to decode.\n   * @param webSafe True if we should use the\n   *     alternative alphabet.\n   * @return string representing the decoded value.\n   */\n  decodeString(input, webSafe) {\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return atob(input);\n    }\n    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n  },\n  /**\n   * Base64-decode a string.\n   *\n   * In base-64 decoding, groups of four characters are converted into three\n   * bytes.  If the encoder did not apply padding, the input length may not\n   * be a multiple of 4.\n   *\n   * In this case, the last group will have fewer than 4 characters, and\n   * padding will be inferred.  If the group has one or two characters, it decodes\n   * to one byte.  If the group has three characters, it decodes to two bytes.\n   *\n   * @param input Input to decode.\n   * @param webSafe True if we should use the web-safe alphabet.\n   * @return bytes representing the decoded value.\n   */\n  decodeStringToByteArray(input, webSafe) {\n    this.init_();\n    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n    const output = [];\n    for (let i = 0; i < input.length; ) {\n      const byte1 = charToByteMap[input.charAt(i++)];\n      const haveByte2 = i < input.length;\n      const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n      const haveByte3 = i < input.length;\n      const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      const haveByte4 = i < input.length;\n      const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw new DecodeBase64StringError();\n      }\n      const outByte1 = byte1 << 2 | byte2 >> 4;\n      output.push(outByte1);\n      if (byte3 !== 64) {\n        const outByte2 = byte2 << 4 & 240 | byte3 >> 2;\n        output.push(outByte2);\n        if (byte4 !== 64) {\n          const outByte3 = byte3 << 6 & 192 | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n    return output;\n  },\n  /**\n   * Lazy static initialization function. Called before\n   * accessing any of the static map variables.\n   * @private\n   */\n  init_() {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {};\n      for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\nvar DecodeBase64StringError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"DecodeBase64StringError\";\n  }\n};\nvar base64Encode = function(str) {\n  const utf8Bytes = stringToByteArray$1(str);\n  return base64.encodeByteArray(utf8Bytes, true);\n};\nvar base64urlEncodeWithoutPadding = function(str) {\n  return base64Encode(str).replace(/\\./g, \"\");\n};\nvar base64Decode = function(str) {\n  try {\n    return base64.decodeString(str, true);\n  } catch (e) {\n    console.error(\"base64Decode failed: \", e);\n  }\n  return null;\n};\nfunction getGlobal() {\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"Unable to locate global object.\");\n}\nvar getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\nvar getDefaultsFromEnvVariable = () => {\n  if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n    return;\n  }\n  const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n  if (defaultsJsonString) {\n    return JSON.parse(defaultsJsonString);\n  }\n};\nvar getDefaultsFromCookie = () => {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n  let match;\n  try {\n    match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n  } catch (e) {\n    return;\n  }\n  const decoded = match && base64Decode(match[1]);\n  return decoded && JSON.parse(decoded);\n};\nvar getDefaults = () => {\n  try {\n    return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();\n  } catch (e) {\n    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n    return;\n  }\n};\nvar getDefaultEmulatorHost = (productName) => {\n  var _a, _b;\n  return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];\n};\nvar getDefaultAppConfig = () => {\n  var _a;\n  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;\n};\nvar getExperimentalSetting = (name2) => {\n  var _a;\n  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name2}`];\n};\nvar Deferred = class {\n  constructor() {\n    this.reject = () => {\n    };\n    this.resolve = () => {\n    };\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n  /**\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\n   */\n  wrapCallback(callback) {\n    return (error, value) => {\n      if (error) {\n        this.reject(error);\n      } else {\n        this.resolve(value);\n      }\n      if (typeof callback === \"function\") {\n        this.promise.catch(() => {\n        });\n        if (callback.length === 1) {\n          callback(error);\n        } else {\n          callback(error, value);\n        }\n      }\n    };\n  }\n};\nfunction getUA() {\n  if (typeof navigator !== \"undefined\" && typeof navigator[\"userAgent\"] === \"string\") {\n    return navigator[\"userAgent\"];\n  } else {\n    return \"\";\n  }\n}\nfunction isMobileCordova() {\n  return typeof window !== \"undefined\" && // @ts-ignore Setting up an broadly applicable index signature for Window\n  // just to deal with this case would probably be a bad idea.\n  !!(window[\"cordova\"] || window[\"phonegap\"] || window[\"PhoneGap\"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());\n}\nfunction isBrowserExtension() {\n  const runtime = typeof chrome === \"object\" ? chrome.runtime : typeof browser === \"object\" ? browser.runtime : void 0;\n  return typeof runtime === \"object\" && runtime.id !== void 0;\n}\nfunction isReactNative() {\n  return typeof navigator === \"object\" && navigator[\"product\"] === \"ReactNative\";\n}\nfunction isIE() {\n  const ua = getUA();\n  return ua.indexOf(\"MSIE \") >= 0 || ua.indexOf(\"Trident/\") >= 0;\n}\nfunction isIndexedDBAvailable() {\n  try {\n    return typeof indexedDB === \"object\";\n  } catch (e) {\n    return false;\n  }\n}\nfunction validateIndexedDBOpenable() {\n  return new Promise((resolve, reject) => {\n    try {\n      let preExist = true;\n      const DB_CHECK_NAME = \"validate-browser-context-for-indexeddb-analytics-module\";\n      const request = self.indexedDB.open(DB_CHECK_NAME);\n      request.onsuccess = () => {\n        request.result.close();\n        if (!preExist) {\n          self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n        }\n        resolve(true);\n      };\n      request.onupgradeneeded = () => {\n        preExist = false;\n      };\n      request.onerror = () => {\n        var _a;\n        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || \"\");\n      };\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nvar ERROR_NAME = \"FirebaseError\";\nvar FirebaseError = class _FirebaseError extends Error {\n  constructor(code, message, customData) {\n    super(message);\n    this.code = code;\n    this.customData = customData;\n    this.name = ERROR_NAME;\n    Object.setPrototypeOf(this, _FirebaseError.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ErrorFactory.prototype.create);\n    }\n  }\n};\nvar ErrorFactory = class {\n  constructor(service, serviceName, errors) {\n    this.service = service;\n    this.serviceName = serviceName;\n    this.errors = errors;\n  }\n  create(code, ...data) {\n    const customData = data[0] || {};\n    const fullCode = `${this.service}/${code}`;\n    const template = this.errors[code];\n    const message = template ? replaceTemplate(template, customData) : \"Error\";\n    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n    const error = new FirebaseError(fullCode, fullMessage, customData);\n    return error;\n  }\n};\nfunction replaceTemplate(template, data) {\n  return template.replace(PATTERN, (_, key) => {\n    const value = data[key];\n    return value != null ? String(value) : `<${key}?>`;\n  });\n}\nvar PATTERN = /\\{\\$([^}]+)}/g;\nfunction isEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  for (const k of aKeys) {\n    if (!bKeys.includes(k)) {\n      return false;\n    }\n    const aProp = a[k];\n    const bProp = b[k];\n    if (isObject(aProp) && isObject(bProp)) {\n      if (!deepEqual(aProp, bProp)) {\n        return false;\n      }\n    } else if (aProp !== bProp) {\n      return false;\n    }\n  }\n  for (const k of bKeys) {\n    if (!aKeys.includes(k)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isObject(thing) {\n  return thing !== null && typeof thing === \"object\";\n}\nfunction querystring(querystringParams) {\n  const params = [];\n  for (const [key, value] of Object.entries(querystringParams)) {\n    if (Array.isArray(value)) {\n      value.forEach((arrayVal) => {\n        params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(arrayVal));\n      });\n    } else {\n      params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n    }\n  }\n  return params.length ? \"&\" + params.join(\"&\") : \"\";\n}\nfunction querystringDecode(querystring2) {\n  const obj = {};\n  const tokens = querystring2.replace(/^\\?/, \"\").split(\"&\");\n  tokens.forEach((token) => {\n    if (token) {\n      const [key, value] = token.split(\"=\");\n      obj[decodeURIComponent(key)] = decodeURIComponent(value);\n    }\n  });\n  return obj;\n}\nfunction extractQuerystring(url) {\n  const queryStart = url.indexOf(\"?\");\n  if (!queryStart) {\n    return \"\";\n  }\n  const fragmentStart = url.indexOf(\"#\", queryStart);\n  return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);\n}\nfunction createSubscribe(executor, onNoObservers) {\n  const proxy = new ObserverProxy(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\nvar ObserverProxy = class {\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor, onNoObservers) {\n    this.observers = [];\n    this.unsubscribes = [];\n    this.observerCount = 0;\n    this.task = Promise.resolve();\n    this.finalized = false;\n    this.onNoObservers = onNoObservers;\n    this.task.then(() => {\n      executor(this);\n    }).catch((e) => {\n      this.error(e);\n    });\n  }\n  next(value) {\n    this.forEachObserver((observer) => {\n      observer.next(value);\n    });\n  }\n  error(error) {\n    this.forEachObserver((observer) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n  complete() {\n    this.forEachObserver((observer) => {\n      observer.complete();\n    });\n    this.close();\n  }\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(nextOrObserver, error, complete) {\n    let observer;\n    if (nextOrObserver === void 0 && error === void 0 && complete === void 0) {\n      throw new Error(\"Missing Observer.\");\n    }\n    if (implementsAnyMethods(nextOrObserver, [\n      \"next\",\n      \"error\",\n      \"complete\"\n    ])) {\n      observer = nextOrObserver;\n    } else {\n      observer = {\n        next: nextOrObserver,\n        error,\n        complete\n      };\n    }\n    if (observer.next === void 0) {\n      observer.next = noop;\n    }\n    if (observer.error === void 0) {\n      observer.error = noop;\n    }\n    if (observer.complete === void 0) {\n      observer.complete = noop;\n    }\n    const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n        }\n        return;\n      });\n    }\n    this.observers.push(observer);\n    return unsub;\n  }\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  unsubscribeOne(i) {\n    if (this.observers === void 0 || this.observers[i] === void 0) {\n      return;\n    }\n    delete this.observers[i];\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== void 0) {\n      this.onNoObservers(this);\n    }\n  }\n  forEachObserver(fn) {\n    if (this.finalized) {\n      return;\n    }\n    for (let i = 0; i < this.observers.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  sendOne(i, fn) {\n    this.task.then(() => {\n      if (this.observers !== void 0 && this.observers[i] !== void 0) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          if (typeof console !== \"undefined\" && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n  close(err) {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== void 0) {\n      this.finalError = err;\n    }\n    this.task.then(() => {\n      this.observers = void 0;\n      this.onNoObservers = void 0;\n    });\n  }\n};\nfunction implementsAnyMethods(obj, methods) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return false;\n  }\n  for (const method of methods) {\n    if (method in obj && typeof obj[method] === \"function\") {\n      return true;\n    }\n  }\n  return false;\n}\nfunction noop() {\n}\nvar MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;\nfunction getModularInstance(service) {\n  if (service && service._delegate) {\n    return service._delegate;\n  } else {\n    return service;\n  }\n}\n\n// node_modules/@firebase/component/dist/esm/index.esm2017.js\nvar Component = class {\n  /**\n   *\n   * @param name The public service name, e.g. app, auth, firestore, database\n   * @param instanceFactory Service factory responsible for creating the public interface\n   * @param type whether the service provided by the component is public or private\n   */\n  constructor(name2, instanceFactory, type) {\n    this.name = name2;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\";\n    this.onInstanceCreated = null;\n  }\n  setInstantiationMode(mode) {\n    this.instantiationMode = mode;\n    return this;\n  }\n  setMultipleInstances(multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  }\n  setServiceProps(props) {\n    this.serviceProps = props;\n    return this;\n  }\n  setInstanceCreatedCallback(callback) {\n    this.onInstanceCreated = callback;\n    return this;\n  }\n};\nvar DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\nvar Provider = class {\n  constructor(name2, container) {\n    this.name = name2;\n    this.container = container;\n    this.component = null;\n    this.instances = /* @__PURE__ */ new Map();\n    this.instancesDeferred = /* @__PURE__ */ new Map();\n    this.instancesOptions = /* @__PURE__ */ new Map();\n    this.onInitCallbacks = /* @__PURE__ */ new Map();\n  }\n  /**\n   * @param identifier A provider can provide mulitple instances of a service\n   * if this.component.multipleInstances is true.\n   */\n  get(identifier) {\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      const deferred = new Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        try {\n          const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {\n        }\n      }\n    }\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  }\n  getImmediate(options) {\n    var _a;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n    const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      if (optional) {\n        return null;\n      } else {\n        throw Error(`Service ${this.name} is not available`);\n      }\n    }\n  }\n  getComponent() {\n    return this.component;\n  }\n  setComponent(component) {\n    if (component.name !== this.name) {\n      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n    }\n    if (this.component) {\n      throw Error(`Component for ${this.name} has already been provided`);\n    }\n    this.component = component;\n    if (!this.shouldAutoInitialize()) {\n      return;\n    }\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n      } catch (e) {\n      }\n    }\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n      try {\n        const instance = this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n        instanceDeferred.resolve(instance);\n      } catch (e) {\n      }\n    }\n  }\n  clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  }\n  // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n  async delete() {\n    const services = Array.from(this.instances.values());\n    await Promise.all([\n      ...services.filter((service) => \"INTERNAL\" in service).map((service) => service.INTERNAL.delete()),\n      ...services.filter((service) => \"_delete\" in service).map((service) => service._delete())\n    ]);\n  }\n  isComponentSet() {\n    return this.component != null;\n  }\n  isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instances.has(identifier);\n  }\n  getOptions(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instancesOptions.get(identifier) || {};\n  }\n  initialize(opts = {}) {\n    const { options = {} } = opts;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n    }\n    if (!this.isComponentSet()) {\n      throw Error(`Component ${this.name} has not been registered yet`);\n    }\n    const instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options\n    });\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n      if (normalizedIdentifier === normalizedDeferredIdentifier) {\n        instanceDeferred.resolve(instance);\n      }\n    }\n    return instance;\n  }\n  /**\n   *\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n   *\n   * @param identifier An optional instance identifier\n   * @returns a function to unregister the callback\n   */\n  onInit(callback, identifier) {\n    var _a;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Set();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n    const existingInstance = this.instances.get(normalizedIdentifier);\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n    return () => {\n      existingCallbacks.delete(callback);\n    };\n  }\n  /**\n   * Invoke onInit callbacks synchronously\n   * @param instance the service instance`\n   */\n  invokeOnInitCallbacks(instance, identifier) {\n    const callbacks = this.onInitCallbacks.get(identifier);\n    if (!callbacks) {\n      return;\n    }\n    for (const callback of callbacks) {\n      try {\n        callback(instance, identifier);\n      } catch (_a) {\n      }\n    }\n  }\n  getOrInitializeService({ instanceIdentifier, options = {} }) {\n    let instance = this.instances.get(instanceIdentifier);\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n        } catch (_a) {\n        }\n      }\n    }\n    return instance || null;\n  }\n  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier;\n    }\n  }\n  shouldAutoInitialize() {\n    return !!this.component && this.component.instantiationMode !== \"EXPLICIT\";\n  }\n};\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;\n}\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\";\n}\nvar ComponentContainer = class {\n  constructor(name2) {\n    this.name = name2;\n    this.providers = /* @__PURE__ */ new Map();\n  }\n  /**\n   *\n   * @param component Component being added\n   * @param overwrite When a component with the same name has already been registered,\n   * if overwrite is true: overwrite the existing component with the new component and create a new\n   * provider with the new component. It can be useful in tests where you want to use different mocks\n   * for different tests.\n   * if overwrite is false: throw an exception\n   */\n  addComponent(component) {\n    const provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n    }\n    provider.setComponent(component);\n  }\n  addOrOverwriteComponent(component) {\n    const provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      this.providers.delete(component.name);\n    }\n    this.addComponent(component);\n  }\n  /**\n   * getProvider provides a type safe interface where it can only be called with a field name\n   * present in NameServiceMapping interface.\n   *\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\n   * themselves.\n   */\n  getProvider(name2) {\n    if (this.providers.has(name2)) {\n      return this.providers.get(name2);\n    }\n    const provider = new Provider(name2, this);\n    this.providers.set(name2, provider);\n    return provider;\n  }\n  getProviders() {\n    return Array.from(this.providers.values());\n  }\n};\n\n// node_modules/@firebase/logger/dist/esm/index.esm2017.js\nvar instances = [];\nvar LogLevel;\n(function(LogLevel2) {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"VERBOSE\"] = 1] = \"VERBOSE\";\n  LogLevel2[LogLevel2[\"INFO\"] = 2] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 3] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 4] = \"ERROR\";\n  LogLevel2[LogLevel2[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nvar levelStringToEnum = {\n  \"debug\": LogLevel.DEBUG,\n  \"verbose\": LogLevel.VERBOSE,\n  \"info\": LogLevel.INFO,\n  \"warn\": LogLevel.WARN,\n  \"error\": LogLevel.ERROR,\n  \"silent\": LogLevel.SILENT\n};\nvar defaultLogLevel = LogLevel.INFO;\nvar ConsoleMethod = {\n  [LogLevel.DEBUG]: \"log\",\n  [LogLevel.VERBOSE]: \"log\",\n  [LogLevel.INFO]: \"info\",\n  [LogLevel.WARN]: \"warn\",\n  [LogLevel.ERROR]: \"error\"\n};\nvar defaultLogHandler = (instance, logType, ...args) => {\n  if (logType < instance.logLevel) {\n    return;\n  }\n  const now = (/* @__PURE__ */ new Date()).toISOString();\n  const method = ConsoleMethod[logType];\n  if (method) {\n    console[method](`[${now}]  ${instance.name}:`, ...args);\n  } else {\n    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n  }\n};\nvar Logger = class {\n  /**\n   * Gives you an instance of a Logger to capture messages according to\n   * Firebase's logging scheme.\n   *\n   * @param name The name that the logs will be associated with\n   */\n  constructor(name2) {\n    this.name = name2;\n    this._logLevel = defaultLogLevel;\n    this._logHandler = defaultLogHandler;\n    this._userLogHandler = null;\n    instances.push(this);\n  }\n  get logLevel() {\n    return this._logLevel;\n  }\n  set logLevel(val) {\n    if (!(val in LogLevel)) {\n      throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n    }\n    this._logLevel = val;\n  }\n  // Workaround for setter/getter having to be the same type.\n  setLogLevel(val) {\n    this._logLevel = typeof val === \"string\" ? levelStringToEnum[val] : val;\n  }\n  get logHandler() {\n    return this._logHandler;\n  }\n  set logHandler(val) {\n    if (typeof val !== \"function\") {\n      throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n    }\n    this._logHandler = val;\n  }\n  get userLogHandler() {\n    return this._userLogHandler;\n  }\n  set userLogHandler(val) {\n    this._userLogHandler = val;\n  }\n  /**\n   * The functions below are all based on the `console` interface\n   */\n  debug(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n    this._logHandler(this, LogLevel.DEBUG, ...args);\n  }\n  log(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n    this._logHandler(this, LogLevel.VERBOSE, ...args);\n  }\n  info(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n    this._logHandler(this, LogLevel.INFO, ...args);\n  }\n  warn(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n    this._logHandler(this, LogLevel.WARN, ...args);\n  }\n  error(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n    this._logHandler(this, LogLevel.ERROR, ...args);\n  }\n};\nfunction setLogLevel(level) {\n  instances.forEach((inst) => {\n    inst.setLogLevel(level);\n  });\n}\nfunction setUserLogHandler(logCallback, options) {\n  for (const instance of instances) {\n    let customLogLevel = null;\n    if (options && options.level) {\n      customLogLevel = levelStringToEnum[options.level];\n    }\n    if (logCallback === null) {\n      instance.userLogHandler = null;\n    } else {\n      instance.userLogHandler = (instance2, level, ...args) => {\n        const message = args.map((arg) => {\n          if (arg == null) {\n            return null;\n          } else if (typeof arg === \"string\") {\n            return arg;\n          } else if (typeof arg === \"number\" || typeof arg === \"boolean\") {\n            return arg.toString();\n          } else if (arg instanceof Error) {\n            return arg.message;\n          } else {\n            try {\n              return JSON.stringify(arg);\n            } catch (ignored) {\n              return null;\n            }\n          }\n        }).filter((arg) => arg).join(\" \");\n        if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance2.logLevel)) {\n          logCallback({\n            level: LogLevel[level].toLowerCase(),\n            message,\n            args,\n            type: instance2.name\n          });\n        }\n      };\n    }\n  }\n}\n\n// node_modules/idb/build/wrap-idb-value.js\nvar instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\nvar idbProxyableTypes;\nvar cursorAdvanceMethods;\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [\n    IDBDatabase,\n    IDBObjectStore,\n    IDBIndex,\n    IDBCursor,\n    IDBTransaction\n  ]);\n}\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [\n    IDBCursor.prototype.advance,\n    IDBCursor.prototype.continue,\n    IDBCursor.prototype.continuePrimaryKey\n  ]);\n}\nvar cursorRequestMap = /* @__PURE__ */ new WeakMap();\nvar transactionDoneMap = /* @__PURE__ */ new WeakMap();\nvar transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();\nvar transformCache = /* @__PURE__ */ new WeakMap();\nvar reverseTransformCache = /* @__PURE__ */ new WeakMap();\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener(\"success\", success);\n      request.removeEventListener(\"error\", error);\n    };\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener(\"success\", success);\n    request.addEventListener(\"error\", error);\n  });\n  promise.then((value) => {\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    }\n  }).catch(() => {\n  });\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  if (transactionDoneMap.has(tx))\n    return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener(\"complete\", complete);\n      tx.removeEventListener(\"error\", error);\n      tx.removeEventListener(\"abort\", error);\n    };\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n    const error = () => {\n      reject(tx.error || new DOMException(\"AbortError\", \"AbortError\"));\n      unlisten();\n    };\n    tx.addEventListener(\"complete\", complete);\n    tx.addEventListener(\"error\", error);\n    tx.addEventListener(\"abort\", error);\n  });\n  transactionDoneMap.set(tx, done);\n}\nvar idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      if (prop === \"done\")\n        return transactionDoneMap.get(target);\n      if (prop === \"objectStoreNames\") {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      }\n      if (prop === \"store\") {\n        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    return wrap(target[prop]);\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === \"done\" || prop === \"store\")) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  if (func === IDBDatabase.prototype.transaction && !(\"objectStoreNames\" in IDBTransaction.prototype)) {\n    return function(storeNames, ...args) {\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  }\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function(...args) {\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n  return function(...args) {\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === \"function\")\n    return wrapFunction(value);\n  if (value instanceof IDBTransaction)\n    cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes()))\n    return new Proxy(value, idbProxyTraps);\n  return value;\n}\nfunction wrap(value) {\n  if (value instanceof IDBRequest)\n    return promisifyRequest(value);\n  if (transformCache.has(value))\n    return transformCache.get(value);\n  const newValue = transformCachableValue(value);\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nvar unwrap = (value) => reverseTransformCache.get(value);\n\n// node_modules/idb/build/index.js\nfunction openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {\n  const request = indexedDB.open(name2, version2);\n  const openPromise = wrap(request);\n  if (upgrade) {\n    request.addEventListener(\"upgradeneeded\", (event) => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n    });\n  }\n  if (blocked) {\n    request.addEventListener(\"blocked\", (event) => blocked(\n      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n      event.oldVersion,\n      event.newVersion,\n      event\n    ));\n  }\n  openPromise.then((db) => {\n    if (terminated)\n      db.addEventListener(\"close\", () => terminated());\n    if (blocking) {\n      db.addEventListener(\"versionchange\", (event) => blocking(event.oldVersion, event.newVersion, event));\n    }\n  }).catch(() => {\n  });\n  return openPromise;\n}\nvar readMethods = [\"get\", \"getKey\", \"getAll\", \"getAllKeys\", \"count\"];\nvar writeMethods = [\"put\", \"add\", \"delete\", \"clear\"];\nvar cachedMethods = /* @__PURE__ */ new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === \"string\")) {\n    return;\n  }\n  if (cachedMethods.get(prop))\n    return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, \"\");\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))\n  ) {\n    return;\n  }\n  const method = async function(storeName, ...args) {\n    const tx = this.transaction(storeName, isWrite ? \"readwrite\" : \"readonly\");\n    let target2 = tx.store;\n    if (useIndex)\n      target2 = target2.index(args.shift());\n    return (await Promise.all([\n      target2[targetFuncName](...args),\n      isWrite && tx.done\n    ]))[0];\n  };\n  cachedMethods.set(prop, method);\n  return method;\n}\nreplaceTraps((oldTraps) => ({\n  ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\n\n// node_modules/@firebase/app/dist/esm/index.esm2017.js\nvar PlatformLoggerServiceImpl = class {\n  constructor(container) {\n    this.container = container;\n  }\n  // In initial implementation, this will be called by installations on\n  // auth token refresh, and installations will send this string.\n  getPlatformInfoString() {\n    const providers = this.container.getProviders();\n    return providers.map((provider) => {\n      if (isVersionServiceProvider(provider)) {\n        const service = provider.getImmediate();\n        return `${service.library}/${service.version}`;\n      } else {\n        return null;\n      }\n    }).filter((logString) => logString).join(\" \");\n  }\n};\nfunction isVersionServiceProvider(provider) {\n  const component = provider.getComponent();\n  return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\";\n}\nvar name$o = \"@firebase/app\";\nvar version$1 = \"0.9.23\";\nvar logger = new Logger(\"@firebase/app\");\nvar name$n = \"@firebase/app-compat\";\nvar name$m = \"@firebase/analytics-compat\";\nvar name$l = \"@firebase/analytics\";\nvar name$k = \"@firebase/app-check-compat\";\nvar name$j = \"@firebase/app-check\";\nvar name$i = \"@firebase/auth\";\nvar name$h = \"@firebase/auth-compat\";\nvar name$g = \"@firebase/database\";\nvar name$f = \"@firebase/database-compat\";\nvar name$e = \"@firebase/functions\";\nvar name$d = \"@firebase/functions-compat\";\nvar name$c = \"@firebase/installations\";\nvar name$b = \"@firebase/installations-compat\";\nvar name$a = \"@firebase/messaging\";\nvar name$9 = \"@firebase/messaging-compat\";\nvar name$8 = \"@firebase/performance\";\nvar name$7 = \"@firebase/performance-compat\";\nvar name$6 = \"@firebase/remote-config\";\nvar name$5 = \"@firebase/remote-config-compat\";\nvar name$4 = \"@firebase/storage\";\nvar name$3 = \"@firebase/storage-compat\";\nvar name$2 = \"@firebase/firestore\";\nvar name$1 = \"@firebase/firestore-compat\";\nvar name = \"firebase\";\nvar version = \"10.6.0\";\nvar DEFAULT_ENTRY_NAME2 = \"[DEFAULT]\";\nvar PLATFORM_LOG_STRING = {\n  [name$o]: \"fire-core\",\n  [name$n]: \"fire-core-compat\",\n  [name$l]: \"fire-analytics\",\n  [name$m]: \"fire-analytics-compat\",\n  [name$j]: \"fire-app-check\",\n  [name$k]: \"fire-app-check-compat\",\n  [name$i]: \"fire-auth\",\n  [name$h]: \"fire-auth-compat\",\n  [name$g]: \"fire-rtdb\",\n  [name$f]: \"fire-rtdb-compat\",\n  [name$e]: \"fire-fn\",\n  [name$d]: \"fire-fn-compat\",\n  [name$c]: \"fire-iid\",\n  [name$b]: \"fire-iid-compat\",\n  [name$a]: \"fire-fcm\",\n  [name$9]: \"fire-fcm-compat\",\n  [name$8]: \"fire-perf\",\n  [name$7]: \"fire-perf-compat\",\n  [name$6]: \"fire-rc\",\n  [name$5]: \"fire-rc-compat\",\n  [name$4]: \"fire-gcs\",\n  [name$3]: \"fire-gcs-compat\",\n  [name$2]: \"fire-fst\",\n  [name$1]: \"fire-fst-compat\",\n  \"fire-js\": \"fire-js\",\n  [name]: \"fire-js-all\"\n};\nvar _apps = /* @__PURE__ */ new Map();\nvar _components = /* @__PURE__ */ new Map();\nfunction _addComponent(app, component) {\n  try {\n    app.container.addComponent(component);\n  } catch (e) {\n    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n  }\n}\nfunction _addOrOverwriteComponent(app, component) {\n  app.container.addOrOverwriteComponent(component);\n}\nfunction _registerComponent(component) {\n  const componentName = component.name;\n  if (_components.has(componentName)) {\n    logger.debug(`There were multiple attempts to register component ${componentName}.`);\n    return false;\n  }\n  _components.set(componentName, component);\n  for (const app of _apps.values()) {\n    _addComponent(app, component);\n  }\n  return true;\n}\nfunction _getProvider(app, name2) {\n  const heartbeatController = app.container.getProvider(\"heartbeat\").getImmediate({ optional: true });\n  if (heartbeatController) {\n    void heartbeatController.triggerHeartbeat();\n  }\n  return app.container.getProvider(name2);\n}\nfunction _removeServiceInstance(app, name2, instanceIdentifier = DEFAULT_ENTRY_NAME2) {\n  _getProvider(app, name2).clearInstance(instanceIdentifier);\n}\nfunction _clearComponents() {\n  _components.clear();\n}\nvar ERRORS = {\n  [\n    \"no-app\"\n    /* AppError.NO_APP */\n  ]: \"No Firebase App '{$appName}' has been created - call initializeApp() first\",\n  [\n    \"bad-app-name\"\n    /* AppError.BAD_APP_NAME */\n  ]: \"Illegal App name: '{$appName}\",\n  [\n    \"duplicate-app\"\n    /* AppError.DUPLICATE_APP */\n  ]: \"Firebase App named '{$appName}' already exists with different options or config\",\n  [\n    \"app-deleted\"\n    /* AppError.APP_DELETED */\n  ]: \"Firebase App named '{$appName}' already deleted\",\n  [\n    \"no-options\"\n    /* AppError.NO_OPTIONS */\n  ]: \"Need to provide options, when not being deployed to hosting via source.\",\n  [\n    \"invalid-app-argument\"\n    /* AppError.INVALID_APP_ARGUMENT */\n  ]: \"firebase.{$appName}() takes either no argument or a Firebase App instance.\",\n  [\n    \"invalid-log-argument\"\n    /* AppError.INVALID_LOG_ARGUMENT */\n  ]: \"First argument to `onLog` must be null or a function.\",\n  [\n    \"idb-open\"\n    /* AppError.IDB_OPEN */\n  ]: \"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.\",\n  [\n    \"idb-get\"\n    /* AppError.IDB_GET */\n  ]: \"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.\",\n  [\n    \"idb-set\"\n    /* AppError.IDB_WRITE */\n  ]: \"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.\",\n  [\n    \"idb-delete\"\n    /* AppError.IDB_DELETE */\n  ]: \"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.\"\n};\nvar ERROR_FACTORY = new ErrorFactory(\"app\", \"Firebase\", ERRORS);\nvar FirebaseAppImpl = class {\n  constructor(options, config, container) {\n    this._isDeleted = false;\n    this._options = Object.assign({}, options);\n    this._config = Object.assign({}, config);\n    this._name = config.name;\n    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n    this._container = container;\n    this.container.addComponent(new Component(\n      \"app\",\n      () => this,\n      \"PUBLIC\"\n      /* ComponentType.PUBLIC */\n    ));\n  }\n  get automaticDataCollectionEnabled() {\n    this.checkDestroyed();\n    return this._automaticDataCollectionEnabled;\n  }\n  set automaticDataCollectionEnabled(val) {\n    this.checkDestroyed();\n    this._automaticDataCollectionEnabled = val;\n  }\n  get name() {\n    this.checkDestroyed();\n    return this._name;\n  }\n  get options() {\n    this.checkDestroyed();\n    return this._options;\n  }\n  get config() {\n    this.checkDestroyed();\n    return this._config;\n  }\n  get container() {\n    return this._container;\n  }\n  get isDeleted() {\n    return this._isDeleted;\n  }\n  set isDeleted(val) {\n    this._isDeleted = val;\n  }\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  checkDestroyed() {\n    if (this.isDeleted) {\n      throw ERROR_FACTORY.create(\"app-deleted\", { appName: this._name });\n    }\n  }\n};\nvar SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n  let options = _options;\n  if (typeof rawConfig !== \"object\") {\n    const name3 = rawConfig;\n    rawConfig = { name: name3 };\n  }\n  const config = Object.assign({ name: DEFAULT_ENTRY_NAME2, automaticDataCollectionEnabled: false }, rawConfig);\n  const name2 = config.name;\n  if (typeof name2 !== \"string\" || !name2) {\n    throw ERROR_FACTORY.create(\"bad-app-name\", {\n      appName: String(name2)\n    });\n  }\n  options || (options = getDefaultAppConfig());\n  if (!options) {\n    throw ERROR_FACTORY.create(\n      \"no-options\"\n      /* AppError.NO_OPTIONS */\n    );\n  }\n  const existingApp = _apps.get(name2);\n  if (existingApp) {\n    if (deepEqual(options, existingApp.options) && deepEqual(config, existingApp.config)) {\n      return existingApp;\n    } else {\n      throw ERROR_FACTORY.create(\"duplicate-app\", { appName: name2 });\n    }\n  }\n  const container = new ComponentContainer(name2);\n  for (const component of _components.values()) {\n    container.addComponent(component);\n  }\n  const newApp = new FirebaseAppImpl(options, config, container);\n  _apps.set(name2, newApp);\n  return newApp;\n}\nfunction getApp(name2 = DEFAULT_ENTRY_NAME2) {\n  const app = _apps.get(name2);\n  if (!app && name2 === DEFAULT_ENTRY_NAME2 && getDefaultAppConfig()) {\n    return initializeApp();\n  }\n  if (!app) {\n    throw ERROR_FACTORY.create(\"no-app\", { appName: name2 });\n  }\n  return app;\n}\nfunction getApps() {\n  return Array.from(_apps.values());\n}\nasync function deleteApp(app) {\n  const name2 = app.name;\n  if (_apps.has(name2)) {\n    _apps.delete(name2);\n    await Promise.all(app.container.getProviders().map((provider) => provider.delete()));\n    app.isDeleted = true;\n  }\n}\nfunction registerVersion(libraryKeyOrName, version2, variant) {\n  var _a;\n  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n  if (variant) {\n    library += `-${variant}`;\n  }\n  const libraryMismatch = library.match(/\\s|\\//);\n  const versionMismatch = version2.match(/\\s|\\//);\n  if (libraryMismatch || versionMismatch) {\n    const warning = [\n      `Unable to register library \"${library}\" with version \"${version2}\":`\n    ];\n    if (libraryMismatch) {\n      warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n    }\n    if (libraryMismatch && versionMismatch) {\n      warning.push(\"and\");\n    }\n    if (versionMismatch) {\n      warning.push(`version name \"${version2}\" contains illegal characters (whitespace or \"/\")`);\n    }\n    logger.warn(warning.join(\" \"));\n    return;\n  }\n  _registerComponent(new Component(\n    `${library}-version`,\n    () => ({ library, version: version2 }),\n    \"VERSION\"\n    /* ComponentType.VERSION */\n  ));\n}\nfunction onLog(logCallback, options) {\n  if (logCallback !== null && typeof logCallback !== \"function\") {\n    throw ERROR_FACTORY.create(\n      \"invalid-log-argument\"\n      /* AppError.INVALID_LOG_ARGUMENT */\n    );\n  }\n  setUserLogHandler(logCallback, options);\n}\nfunction setLogLevel2(logLevel) {\n  setLogLevel(logLevel);\n}\nvar DB_NAME = \"firebase-heartbeat-database\";\nvar DB_VERSION = 1;\nvar STORE_NAME = \"firebase-heartbeat-store\";\nvar dbPromise = null;\nfunction getDbPromise() {\n  if (!dbPromise) {\n    dbPromise = openDB(DB_NAME, DB_VERSION, {\n      upgrade: (db, oldVersion) => {\n        switch (oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME);\n        }\n      }\n    }).catch((e) => {\n      throw ERROR_FACTORY.create(\"idb-open\", {\n        originalErrorMessage: e.message\n      });\n    });\n  }\n  return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n  try {\n    const db = await getDbPromise();\n    const result = await db.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app));\n    return result;\n  } catch (e) {\n    if (e instanceof FirebaseError) {\n      logger.warn(e.message);\n    } else {\n      const idbGetError = ERROR_FACTORY.create(\"idb-get\", {\n        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n      });\n      logger.warn(idbGetError.message);\n    }\n  }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n  try {\n    const db = await getDbPromise();\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const objectStore = tx.objectStore(STORE_NAME);\n    await objectStore.put(heartbeatObject, computeKey(app));\n    await tx.done;\n  } catch (e) {\n    if (e instanceof FirebaseError) {\n      logger.warn(e.message);\n    } else {\n      const idbGetError = ERROR_FACTORY.create(\"idb-set\", {\n        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n      });\n      logger.warn(idbGetError.message);\n    }\n  }\n}\nfunction computeKey(app) {\n  return `${app.name}!${app.options.appId}`;\n}\nvar MAX_HEADER_BYTES = 1024;\nvar STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3;\nvar HeartbeatServiceImpl = class {\n  constructor(container) {\n    this.container = container;\n    this._heartbeatsCache = null;\n    const app = this.container.getProvider(\"app\").getImmediate();\n    this._storage = new HeartbeatStorageImpl(app);\n    this._heartbeatsCachePromise = this._storage.read().then((result) => {\n      this._heartbeatsCache = result;\n      return result;\n    });\n  }\n  /**\n   * Called to report a heartbeat. The function will generate\n   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n   * to IndexedDB.\n   * Note that we only store one heartbeat per day. So if a heartbeat for today is\n   * already logged, subsequent calls to this function in the same day will be ignored.\n   */\n  async triggerHeartbeat() {\n    var _a;\n    const platformLogger = this.container.getProvider(\"platform-logger\").getImmediate();\n    const agent = platformLogger.getPlatformInfoString();\n    const date = getUTCDateString();\n    if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n      this._heartbeatsCache = await this._heartbeatsCachePromise;\n    }\n    if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {\n      return;\n    } else {\n      this._heartbeatsCache.heartbeats.push({ date, agent });\n    }\n    this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat) => {\n      const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n      const now = Date.now();\n      return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n    });\n    return this._storage.overwrite(this._heartbeatsCache);\n  }\n  /**\n   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n   * It also clears all heartbeats from memory as well as in IndexedDB.\n   *\n   * NOTE: Consuming product SDKs should not send the header if this method\n   * returns an empty string.\n   */\n  async getHeartbeatsHeader() {\n    var _a;\n    if (this._heartbeatsCache === null) {\n      await this._heartbeatsCachePromise;\n    }\n    if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {\n      return \"\";\n    }\n    const date = getUTCDateString();\n    const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n    const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\n    this._heartbeatsCache.lastSentHeartbeatDate = date;\n    if (unsentEntries.length > 0) {\n      this._heartbeatsCache.heartbeats = unsentEntries;\n      await this._storage.overwrite(this._heartbeatsCache);\n    } else {\n      this._heartbeatsCache.heartbeats = [];\n      void this._storage.overwrite(this._heartbeatsCache);\n    }\n    return headerString;\n  }\n};\nfunction getUTCDateString() {\n  const today = /* @__PURE__ */ new Date();\n  return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n  const heartbeatsToSend = [];\n  let unsentEntries = heartbeatsCache.slice();\n  for (const singleDateHeartbeat of heartbeatsCache) {\n    const heartbeatEntry = heartbeatsToSend.find((hb) => hb.agent === singleDateHeartbeat.agent);\n    if (!heartbeatEntry) {\n      heartbeatsToSend.push({\n        agent: singleDateHeartbeat.agent,\n        dates: [singleDateHeartbeat.date]\n      });\n      if (countBytes(heartbeatsToSend) > maxSize) {\n        heartbeatsToSend.pop();\n        break;\n      }\n    } else {\n      heartbeatEntry.dates.push(singleDateHeartbeat.date);\n      if (countBytes(heartbeatsToSend) > maxSize) {\n        heartbeatEntry.dates.pop();\n        break;\n      }\n    }\n    unsentEntries = unsentEntries.slice(1);\n  }\n  return {\n    heartbeatsToSend,\n    unsentEntries\n  };\n}\nvar HeartbeatStorageImpl = class {\n  constructor(app) {\n    this.app = app;\n    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n  }\n  async runIndexedDBEnvironmentCheck() {\n    if (!isIndexedDBAvailable()) {\n      return false;\n    } else {\n      return validateIndexedDBOpenable().then(() => true).catch(() => false);\n    }\n  }\n  /**\n   * Read all heartbeats.\n   */\n  async read() {\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return { heartbeats: [] };\n    } else {\n      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n      return idbHeartbeatObject || { heartbeats: [] };\n    }\n  }\n  // overwrite the storage with the provided heartbeats\n  async overwrite(heartbeatsObject) {\n    var _a;\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return;\n    } else {\n      const existingHeartbeatsObject = await this.read();\n      return writeHeartbeatsToIndexedDB(this.app, {\n        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n        heartbeats: heartbeatsObject.heartbeats\n      });\n    }\n  }\n  // add heartbeats\n  async add(heartbeatsObject) {\n    var _a;\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return;\n    } else {\n      const existingHeartbeatsObject = await this.read();\n      return writeHeartbeatsToIndexedDB(this.app, {\n        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n        heartbeats: [\n          ...existingHeartbeatsObject.heartbeats,\n          ...heartbeatsObject.heartbeats\n        ]\n      });\n    }\n  }\n};\nfunction countBytes(heartbeatsCache) {\n  return base64urlEncodeWithoutPadding(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })\n  ).length;\n}\nfunction registerCoreComponents(variant) {\n  _registerComponent(new Component(\n    \"platform-logger\",\n    (container) => new PlatformLoggerServiceImpl(container),\n    \"PRIVATE\"\n    /* ComponentType.PRIVATE */\n  ));\n  _registerComponent(new Component(\n    \"heartbeat\",\n    (container) => new HeartbeatServiceImpl(container),\n    \"PRIVATE\"\n    /* ComponentType.PRIVATE */\n  ));\n  registerVersion(name$o, version$1, variant);\n  registerVersion(name$o, version$1, \"esm2017\");\n  registerVersion(\"fire-js\", \"\");\n}\nregisterCoreComponents(\"\");\n\nexport {\n  base64Decode,\n  getDefaultEmulatorHost,\n  getExperimentalSetting,\n  getUA,\n  isMobileCordova,\n  isBrowserExtension,\n  isReactNative,\n  isIE,\n  FirebaseError,\n  ErrorFactory,\n  isEmpty,\n  deepEqual,\n  querystring,\n  querystringDecode,\n  extractQuerystring,\n  createSubscribe,\n  getModularInstance,\n  Component,\n  LogLevel,\n  Logger,\n  DEFAULT_ENTRY_NAME2 as DEFAULT_ENTRY_NAME,\n  _apps,\n  _components,\n  _addComponent,\n  _addOrOverwriteComponent,\n  _registerComponent,\n  _getProvider,\n  _removeServiceInstance,\n  _clearComponents,\n  SDK_VERSION,\n  initializeApp,\n  getApp,\n  getApps,\n  deleteApp,\n  registerVersion,\n  onLog,\n  setLogLevel2 as setLogLevel\n};\n/*! Bundled license information:\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2022 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n  (**\n   * @license\n   * Copyright 2021 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2022 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2022 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2019 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2020 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2021 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/component/dist/esm/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2019 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/logger/dist/esm/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/app/dist/esm/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2019 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n  (**\n   * @license\n   * Copyright 2021 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n*/\n//# sourceMappingURL=chunk-B7GYBXJM.js.map\n",
      "start": 1701867792352,
      "end": 1701867792432,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1701867792432,
      "end": 1701867792432,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1701867792432,
      "end": 1701867792432,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1701867792432,
      "end": 1701867792432,
      "order": "normal"
    },
    {
      "name": "vite:react-swc",
      "start": 1701867792432,
      "end": 1701867792432,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1701867792432,
      "end": 1701867792432,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1701867792432,
      "end": 1701867792432,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1701867792432,
      "end": 1701867792432,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1701867792432,
      "end": 1701867792432,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1701867792432,
      "end": 1701867792433,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1701867792433,
      "end": 1701867792433,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1701867792433,
      "end": 1701867792433,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "// node_modules/@firebase/util/dist/index.esm2017.js\nvar stringToByteArray$1 = function(str) {\n  const out = [];\n  let p = 0;\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i);\n    if (c < 128) {\n      out[p++] = c;\n    } else if (c < 2048) {\n      out[p++] = c >> 6 | 192;\n      out[p++] = c & 63 | 128;\n    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {\n      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);\n      out[p++] = c >> 18 | 240;\n      out[p++] = c >> 12 & 63 | 128;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    } else {\n      out[p++] = c >> 12 | 224;\n      out[p++] = c >> 6 & 63 | 128;\n      out[p++] = c & 63 | 128;\n    }\n  }\n  return out;\n};\nvar byteArrayToString = function(bytes) {\n  const out = [];\n  let pos = 0, c = 0;\n  while (pos < bytes.length) {\n    const c1 = bytes[pos++];\n    if (c1 < 128) {\n      out[c++] = String.fromCharCode(c1);\n    } else if (c1 > 191 && c1 < 224) {\n      const c2 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n    } else if (c1 > 239 && c1 < 365) {\n      const c2 = bytes[pos++];\n      const c3 = bytes[pos++];\n      const c4 = bytes[pos++];\n      const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;\n      out[c++] = String.fromCharCode(55296 + (u >> 10));\n      out[c++] = String.fromCharCode(56320 + (u & 1023));\n    } else {\n      const c2 = bytes[pos++];\n      const c3 = bytes[pos++];\n      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n    }\n  }\n  return out.join(\"\");\n};\nvar base64 = {\n  /**\n   * Maps bytes to characters.\n   */\n  byteToCharMap_: null,\n  /**\n   * Maps characters to bytes.\n   */\n  charToByteMap_: null,\n  /**\n   * Maps bytes to websafe characters.\n   * @private\n   */\n  byteToCharMapWebSafe_: null,\n  /**\n   * Maps websafe characters to bytes.\n   * @private\n   */\n  charToByteMapWebSafe_: null,\n  /**\n   * Our default alphabet, shared between\n   * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n   */\n  ENCODED_VALS_BASE: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n  /**\n   * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n   */\n  get ENCODED_VALS() {\n    return this.ENCODED_VALS_BASE + \"+/=\";\n  },\n  /**\n   * Our websafe alphabet.\n   */\n  get ENCODED_VALS_WEBSAFE() {\n    return this.ENCODED_VALS_BASE + \"-_.\";\n  },\n  /**\n   * Whether this browser supports the atob and btoa functions. This extension\n   * started at Mozilla but is now implemented by many browsers. We use the\n   * ASSUME_* variables to avoid pulling in the full useragent detection library\n   * but still allowing the standard per-browser compilations.\n   *\n   */\n  HAS_NATIVE_SUPPORT: typeof atob === \"function\",\n  /**\n   * Base64-encode an array of bytes.\n   *\n   * @param input An array of bytes (numbers with\n   *     value in [0, 255]) to encode.\n   * @param webSafe Boolean indicating we should use the\n   *     alternative alphabet.\n   * @return The base64 encoded string.\n   */\n  encodeByteArray(input, webSafe) {\n    if (!Array.isArray(input)) {\n      throw Error(\"encodeByteArray takes an array as a parameter\");\n    }\n    this.init_();\n    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;\n    const output = [];\n    for (let i = 0; i < input.length; i += 3) {\n      const byte1 = input[i];\n      const haveByte2 = i + 1 < input.length;\n      const byte2 = haveByte2 ? input[i + 1] : 0;\n      const haveByte3 = i + 2 < input.length;\n      const byte3 = haveByte3 ? input[i + 2] : 0;\n      const outByte1 = byte1 >> 2;\n      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;\n      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;\n      let outByte4 = byte3 & 63;\n      if (!haveByte3) {\n        outByte4 = 64;\n        if (!haveByte2) {\n          outByte3 = 64;\n        }\n      }\n      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n    }\n    return output.join(\"\");\n  },\n  /**\n   * Base64-encode a string.\n   *\n   * @param input A string to encode.\n   * @param webSafe If true, we should use the\n   *     alternative alphabet.\n   * @return The base64 encoded string.\n   */\n  encodeString(input, webSafe) {\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return btoa(input);\n    }\n    return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n  },\n  /**\n   * Base64-decode a string.\n   *\n   * @param input to decode.\n   * @param webSafe True if we should use the\n   *     alternative alphabet.\n   * @return string representing the decoded value.\n   */\n  decodeString(input, webSafe) {\n    if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n      return atob(input);\n    }\n    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n  },\n  /**\n   * Base64-decode a string.\n   *\n   * In base-64 decoding, groups of four characters are converted into three\n   * bytes.  If the encoder did not apply padding, the input length may not\n   * be a multiple of 4.\n   *\n   * In this case, the last group will have fewer than 4 characters, and\n   * padding will be inferred.  If the group has one or two characters, it decodes\n   * to one byte.  If the group has three characters, it decodes to two bytes.\n   *\n   * @param input Input to decode.\n   * @param webSafe True if we should use the web-safe alphabet.\n   * @return bytes representing the decoded value.\n   */\n  decodeStringToByteArray(input, webSafe) {\n    this.init_();\n    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;\n    const output = [];\n    for (let i = 0; i < input.length; ) {\n      const byte1 = charToByteMap[input.charAt(i++)];\n      const haveByte2 = i < input.length;\n      const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n      ++i;\n      const haveByte3 = i < input.length;\n      const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      const haveByte4 = i < input.length;\n      const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n      ++i;\n      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n        throw new DecodeBase64StringError();\n      }\n      const outByte1 = byte1 << 2 | byte2 >> 4;\n      output.push(outByte1);\n      if (byte3 !== 64) {\n        const outByte2 = byte2 << 4 & 240 | byte3 >> 2;\n        output.push(outByte2);\n        if (byte4 !== 64) {\n          const outByte3 = byte3 << 6 & 192 | byte4;\n          output.push(outByte3);\n        }\n      }\n    }\n    return output;\n  },\n  /**\n   * Lazy static initialization function. Called before\n   * accessing any of the static map variables.\n   * @private\n   */\n  init_() {\n    if (!this.byteToCharMap_) {\n      this.byteToCharMap_ = {};\n      this.charToByteMap_ = {};\n      this.byteToCharMapWebSafe_ = {};\n      this.charToByteMapWebSafe_ = {};\n      for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n        this.charToByteMap_[this.byteToCharMap_[i]] = i;\n        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n        if (i >= this.ENCODED_VALS_BASE.length) {\n          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n        }\n      }\n    }\n  }\n};\nvar DecodeBase64StringError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"DecodeBase64StringError\";\n  }\n};\nvar base64Encode = function(str) {\n  const utf8Bytes = stringToByteArray$1(str);\n  return base64.encodeByteArray(utf8Bytes, true);\n};\nvar base64urlEncodeWithoutPadding = function(str) {\n  return base64Encode(str).replace(/\\./g, \"\");\n};\nvar base64Decode = function(str) {\n  try {\n    return base64.decodeString(str, true);\n  } catch (e) {\n    console.error(\"base64Decode failed: \", e);\n  }\n  return null;\n};\nfunction getGlobal() {\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"Unable to locate global object.\");\n}\nvar getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\nvar getDefaultsFromEnvVariable = () => {\n  if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n    return;\n  }\n  const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n  if (defaultsJsonString) {\n    return JSON.parse(defaultsJsonString);\n  }\n};\nvar getDefaultsFromCookie = () => {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n  let match;\n  try {\n    match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n  } catch (e) {\n    return;\n  }\n  const decoded = match && base64Decode(match[1]);\n  return decoded && JSON.parse(decoded);\n};\nvar getDefaults = () => {\n  try {\n    return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();\n  } catch (e) {\n    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n    return;\n  }\n};\nvar getDefaultEmulatorHost = (productName) => {\n  var _a, _b;\n  return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];\n};\nvar getDefaultAppConfig = () => {\n  var _a;\n  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;\n};\nvar getExperimentalSetting = (name2) => {\n  var _a;\n  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name2}`];\n};\nvar Deferred = class {\n  constructor() {\n    this.reject = () => {\n    };\n    this.resolve = () => {\n    };\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n  /**\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\n   */\n  wrapCallback(callback) {\n    return (error, value) => {\n      if (error) {\n        this.reject(error);\n      } else {\n        this.resolve(value);\n      }\n      if (typeof callback === \"function\") {\n        this.promise.catch(() => {\n        });\n        if (callback.length === 1) {\n          callback(error);\n        } else {\n          callback(error, value);\n        }\n      }\n    };\n  }\n};\nfunction getUA() {\n  if (typeof navigator !== \"undefined\" && typeof navigator[\"userAgent\"] === \"string\") {\n    return navigator[\"userAgent\"];\n  } else {\n    return \"\";\n  }\n}\nfunction isMobileCordova() {\n  return typeof window !== \"undefined\" && // @ts-ignore Setting up an broadly applicable index signature for Window\n  // just to deal with this case would probably be a bad idea.\n  !!(window[\"cordova\"] || window[\"phonegap\"] || window[\"PhoneGap\"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());\n}\nfunction isBrowserExtension() {\n  const runtime = typeof chrome === \"object\" ? chrome.runtime : typeof browser === \"object\" ? browser.runtime : void 0;\n  return typeof runtime === \"object\" && runtime.id !== void 0;\n}\nfunction isReactNative() {\n  return typeof navigator === \"object\" && navigator[\"product\"] === \"ReactNative\";\n}\nfunction isIE() {\n  const ua = getUA();\n  return ua.indexOf(\"MSIE \") >= 0 || ua.indexOf(\"Trident/\") >= 0;\n}\nfunction isIndexedDBAvailable() {\n  try {\n    return typeof indexedDB === \"object\";\n  } catch (e) {\n    return false;\n  }\n}\nfunction validateIndexedDBOpenable() {\n  return new Promise((resolve, reject) => {\n    try {\n      let preExist = true;\n      const DB_CHECK_NAME = \"validate-browser-context-for-indexeddb-analytics-module\";\n      const request = self.indexedDB.open(DB_CHECK_NAME);\n      request.onsuccess = () => {\n        request.result.close();\n        if (!preExist) {\n          self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n        }\n        resolve(true);\n      };\n      request.onupgradeneeded = () => {\n        preExist = false;\n      };\n      request.onerror = () => {\n        var _a;\n        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || \"\");\n      };\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nvar ERROR_NAME = \"FirebaseError\";\nvar FirebaseError = class _FirebaseError extends Error {\n  constructor(code, message, customData) {\n    super(message);\n    this.code = code;\n    this.customData = customData;\n    this.name = ERROR_NAME;\n    Object.setPrototypeOf(this, _FirebaseError.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ErrorFactory.prototype.create);\n    }\n  }\n};\nvar ErrorFactory = class {\n  constructor(service, serviceName, errors) {\n    this.service = service;\n    this.serviceName = serviceName;\n    this.errors = errors;\n  }\n  create(code, ...data) {\n    const customData = data[0] || {};\n    const fullCode = `${this.service}/${code}`;\n    const template = this.errors[code];\n    const message = template ? replaceTemplate(template, customData) : \"Error\";\n    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n    const error = new FirebaseError(fullCode, fullMessage, customData);\n    return error;\n  }\n};\nfunction replaceTemplate(template, data) {\n  return template.replace(PATTERN, (_, key) => {\n    const value = data[key];\n    return value != null ? String(value) : `<${key}?>`;\n  });\n}\nvar PATTERN = /\\{\\$([^}]+)}/g;\nfunction isEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  for (const k of aKeys) {\n    if (!bKeys.includes(k)) {\n      return false;\n    }\n    const aProp = a[k];\n    const bProp = b[k];\n    if (isObject(aProp) && isObject(bProp)) {\n      if (!deepEqual(aProp, bProp)) {\n        return false;\n      }\n    } else if (aProp !== bProp) {\n      return false;\n    }\n  }\n  for (const k of bKeys) {\n    if (!aKeys.includes(k)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isObject(thing) {\n  return thing !== null && typeof thing === \"object\";\n}\nfunction querystring(querystringParams) {\n  const params = [];\n  for (const [key, value] of Object.entries(querystringParams)) {\n    if (Array.isArray(value)) {\n      value.forEach((arrayVal) => {\n        params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(arrayVal));\n      });\n    } else {\n      params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n    }\n  }\n  return params.length ? \"&\" + params.join(\"&\") : \"\";\n}\nfunction querystringDecode(querystring2) {\n  const obj = {};\n  const tokens = querystring2.replace(/^\\?/, \"\").split(\"&\");\n  tokens.forEach((token) => {\n    if (token) {\n      const [key, value] = token.split(\"=\");\n      obj[decodeURIComponent(key)] = decodeURIComponent(value);\n    }\n  });\n  return obj;\n}\nfunction extractQuerystring(url) {\n  const queryStart = url.indexOf(\"?\");\n  if (!queryStart) {\n    return \"\";\n  }\n  const fragmentStart = url.indexOf(\"#\", queryStart);\n  return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);\n}\nfunction createSubscribe(executor, onNoObservers) {\n  const proxy = new ObserverProxy(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\nvar ObserverProxy = class {\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor, onNoObservers) {\n    this.observers = [];\n    this.unsubscribes = [];\n    this.observerCount = 0;\n    this.task = Promise.resolve();\n    this.finalized = false;\n    this.onNoObservers = onNoObservers;\n    this.task.then(() => {\n      executor(this);\n    }).catch((e) => {\n      this.error(e);\n    });\n  }\n  next(value) {\n    this.forEachObserver((observer) => {\n      observer.next(value);\n    });\n  }\n  error(error) {\n    this.forEachObserver((observer) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n  complete() {\n    this.forEachObserver((observer) => {\n      observer.complete();\n    });\n    this.close();\n  }\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(nextOrObserver, error, complete) {\n    let observer;\n    if (nextOrObserver === void 0 && error === void 0 && complete === void 0) {\n      throw new Error(\"Missing Observer.\");\n    }\n    if (implementsAnyMethods(nextOrObserver, [\n      \"next\",\n      \"error\",\n      \"complete\"\n    ])) {\n      observer = nextOrObserver;\n    } else {\n      observer = {\n        next: nextOrObserver,\n        error,\n        complete\n      };\n    }\n    if (observer.next === void 0) {\n      observer.next = noop;\n    }\n    if (observer.error === void 0) {\n      observer.error = noop;\n    }\n    if (observer.complete === void 0) {\n      observer.complete = noop;\n    }\n    const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n        }\n        return;\n      });\n    }\n    this.observers.push(observer);\n    return unsub;\n  }\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  unsubscribeOne(i) {\n    if (this.observers === void 0 || this.observers[i] === void 0) {\n      return;\n    }\n    delete this.observers[i];\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== void 0) {\n      this.onNoObservers(this);\n    }\n  }\n  forEachObserver(fn) {\n    if (this.finalized) {\n      return;\n    }\n    for (let i = 0; i < this.observers.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  sendOne(i, fn) {\n    this.task.then(() => {\n      if (this.observers !== void 0 && this.observers[i] !== void 0) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          if (typeof console !== \"undefined\" && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n  close(err) {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== void 0) {\n      this.finalError = err;\n    }\n    this.task.then(() => {\n      this.observers = void 0;\n      this.onNoObservers = void 0;\n    });\n  }\n};\nfunction implementsAnyMethods(obj, methods) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return false;\n  }\n  for (const method of methods) {\n    if (method in obj && typeof obj[method] === \"function\") {\n      return true;\n    }\n  }\n  return false;\n}\nfunction noop() {\n}\nvar MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;\nfunction getModularInstance(service) {\n  if (service && service._delegate) {\n    return service._delegate;\n  } else {\n    return service;\n  }\n}\n\n// node_modules/@firebase/component/dist/esm/index.esm2017.js\nvar Component = class {\n  /**\n   *\n   * @param name The public service name, e.g. app, auth, firestore, database\n   * @param instanceFactory Service factory responsible for creating the public interface\n   * @param type whether the service provided by the component is public or private\n   */\n  constructor(name2, instanceFactory, type) {\n    this.name = name2;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\";\n    this.onInstanceCreated = null;\n  }\n  setInstantiationMode(mode) {\n    this.instantiationMode = mode;\n    return this;\n  }\n  setMultipleInstances(multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  }\n  setServiceProps(props) {\n    this.serviceProps = props;\n    return this;\n  }\n  setInstanceCreatedCallback(callback) {\n    this.onInstanceCreated = callback;\n    return this;\n  }\n};\nvar DEFAULT_ENTRY_NAME = \"[DEFAULT]\";\nvar Provider = class {\n  constructor(name2, container) {\n    this.name = name2;\n    this.container = container;\n    this.component = null;\n    this.instances = /* @__PURE__ */ new Map();\n    this.instancesDeferred = /* @__PURE__ */ new Map();\n    this.instancesOptions = /* @__PURE__ */ new Map();\n    this.onInitCallbacks = /* @__PURE__ */ new Map();\n  }\n  /**\n   * @param identifier A provider can provide mulitple instances of a service\n   * if this.component.multipleInstances is true.\n   */\n  get(identifier) {\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      const deferred = new Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        try {\n          const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {\n        }\n      }\n    }\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  }\n  getImmediate(options) {\n    var _a;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n    const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      if (optional) {\n        return null;\n      } else {\n        throw Error(`Service ${this.name} is not available`);\n      }\n    }\n  }\n  getComponent() {\n    return this.component;\n  }\n  setComponent(component) {\n    if (component.name !== this.name) {\n      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n    }\n    if (this.component) {\n      throw Error(`Component for ${this.name} has already been provided`);\n    }\n    this.component = component;\n    if (!this.shouldAutoInitialize()) {\n      return;\n    }\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n      } catch (e) {\n      }\n    }\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n      try {\n        const instance = this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n        instanceDeferred.resolve(instance);\n      } catch (e) {\n      }\n    }\n  }\n  clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  }\n  // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n  async delete() {\n    const services = Array.from(this.instances.values());\n    await Promise.all([\n      ...services.filter((service) => \"INTERNAL\" in service).map((service) => service.INTERNAL.delete()),\n      ...services.filter((service) => \"_delete\" in service).map((service) => service._delete())\n    ]);\n  }\n  isComponentSet() {\n    return this.component != null;\n  }\n  isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instances.has(identifier);\n  }\n  getOptions(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instancesOptions.get(identifier) || {};\n  }\n  initialize(opts = {}) {\n    const { options = {} } = opts;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n    }\n    if (!this.isComponentSet()) {\n      throw Error(`Component ${this.name} has not been registered yet`);\n    }\n    const instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options\n    });\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n      if (normalizedIdentifier === normalizedDeferredIdentifier) {\n        instanceDeferred.resolve(instance);\n      }\n    }\n    return instance;\n  }\n  /**\n   *\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n   *\n   * @param identifier An optional instance identifier\n   * @returns a function to unregister the callback\n   */\n  onInit(callback, identifier) {\n    var _a;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Set();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n    const existingInstance = this.instances.get(normalizedIdentifier);\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n    return () => {\n      existingCallbacks.delete(callback);\n    };\n  }\n  /**\n   * Invoke onInit callbacks synchronously\n   * @param instance the service instance`\n   */\n  invokeOnInitCallbacks(instance, identifier) {\n    const callbacks = this.onInitCallbacks.get(identifier);\n    if (!callbacks) {\n      return;\n    }\n    for (const callback of callbacks) {\n      try {\n        callback(instance, identifier);\n      } catch (_a) {\n      }\n    }\n  }\n  getOrInitializeService({ instanceIdentifier, options = {} }) {\n    let instance = this.instances.get(instanceIdentifier);\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n        } catch (_a) {\n        }\n      }\n    }\n    return instance || null;\n  }\n  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier;\n    }\n  }\n  shouldAutoInitialize() {\n    return !!this.component && this.component.instantiationMode !== \"EXPLICIT\";\n  }\n};\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;\n}\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\";\n}\nvar ComponentContainer = class {\n  constructor(name2) {\n    this.name = name2;\n    this.providers = /* @__PURE__ */ new Map();\n  }\n  /**\n   *\n   * @param component Component being added\n   * @param overwrite When a component with the same name has already been registered,\n   * if overwrite is true: overwrite the existing component with the new component and create a new\n   * provider with the new component. It can be useful in tests where you want to use different mocks\n   * for different tests.\n   * if overwrite is false: throw an exception\n   */\n  addComponent(component) {\n    const provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n    }\n    provider.setComponent(component);\n  }\n  addOrOverwriteComponent(component) {\n    const provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      this.providers.delete(component.name);\n    }\n    this.addComponent(component);\n  }\n  /**\n   * getProvider provides a type safe interface where it can only be called with a field name\n   * present in NameServiceMapping interface.\n   *\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\n   * themselves.\n   */\n  getProvider(name2) {\n    if (this.providers.has(name2)) {\n      return this.providers.get(name2);\n    }\n    const provider = new Provider(name2, this);\n    this.providers.set(name2, provider);\n    return provider;\n  }\n  getProviders() {\n    return Array.from(this.providers.values());\n  }\n};\n\n// node_modules/@firebase/logger/dist/esm/index.esm2017.js\nvar instances = [];\nvar LogLevel;\n(function(LogLevel2) {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"VERBOSE\"] = 1] = \"VERBOSE\";\n  LogLevel2[LogLevel2[\"INFO\"] = 2] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 3] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 4] = \"ERROR\";\n  LogLevel2[LogLevel2[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nvar levelStringToEnum = {\n  \"debug\": LogLevel.DEBUG,\n  \"verbose\": LogLevel.VERBOSE,\n  \"info\": LogLevel.INFO,\n  \"warn\": LogLevel.WARN,\n  \"error\": LogLevel.ERROR,\n  \"silent\": LogLevel.SILENT\n};\nvar defaultLogLevel = LogLevel.INFO;\nvar ConsoleMethod = {\n  [LogLevel.DEBUG]: \"log\",\n  [LogLevel.VERBOSE]: \"log\",\n  [LogLevel.INFO]: \"info\",\n  [LogLevel.WARN]: \"warn\",\n  [LogLevel.ERROR]: \"error\"\n};\nvar defaultLogHandler = (instance, logType, ...args) => {\n  if (logType < instance.logLevel) {\n    return;\n  }\n  const now = (/* @__PURE__ */ new Date()).toISOString();\n  const method = ConsoleMethod[logType];\n  if (method) {\n    console[method](`[${now}]  ${instance.name}:`, ...args);\n  } else {\n    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n  }\n};\nvar Logger = class {\n  /**\n   * Gives you an instance of a Logger to capture messages according to\n   * Firebase's logging scheme.\n   *\n   * @param name The name that the logs will be associated with\n   */\n  constructor(name2) {\n    this.name = name2;\n    this._logLevel = defaultLogLevel;\n    this._logHandler = defaultLogHandler;\n    this._userLogHandler = null;\n    instances.push(this);\n  }\n  get logLevel() {\n    return this._logLevel;\n  }\n  set logLevel(val) {\n    if (!(val in LogLevel)) {\n      throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n    }\n    this._logLevel = val;\n  }\n  // Workaround for setter/getter having to be the same type.\n  setLogLevel(val) {\n    this._logLevel = typeof val === \"string\" ? levelStringToEnum[val] : val;\n  }\n  get logHandler() {\n    return this._logHandler;\n  }\n  set logHandler(val) {\n    if (typeof val !== \"function\") {\n      throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n    }\n    this._logHandler = val;\n  }\n  get userLogHandler() {\n    return this._userLogHandler;\n  }\n  set userLogHandler(val) {\n    this._userLogHandler = val;\n  }\n  /**\n   * The functions below are all based on the `console` interface\n   */\n  debug(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n    this._logHandler(this, LogLevel.DEBUG, ...args);\n  }\n  log(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n    this._logHandler(this, LogLevel.VERBOSE, ...args);\n  }\n  info(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n    this._logHandler(this, LogLevel.INFO, ...args);\n  }\n  warn(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n    this._logHandler(this, LogLevel.WARN, ...args);\n  }\n  error(...args) {\n    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n    this._logHandler(this, LogLevel.ERROR, ...args);\n  }\n};\nfunction setLogLevel(level) {\n  instances.forEach((inst) => {\n    inst.setLogLevel(level);\n  });\n}\nfunction setUserLogHandler(logCallback, options) {\n  for (const instance of instances) {\n    let customLogLevel = null;\n    if (options && options.level) {\n      customLogLevel = levelStringToEnum[options.level];\n    }\n    if (logCallback === null) {\n      instance.userLogHandler = null;\n    } else {\n      instance.userLogHandler = (instance2, level, ...args) => {\n        const message = args.map((arg) => {\n          if (arg == null) {\n            return null;\n          } else if (typeof arg === \"string\") {\n            return arg;\n          } else if (typeof arg === \"number\" || typeof arg === \"boolean\") {\n            return arg.toString();\n          } else if (arg instanceof Error) {\n            return arg.message;\n          } else {\n            try {\n              return JSON.stringify(arg);\n            } catch (ignored) {\n              return null;\n            }\n          }\n        }).filter((arg) => arg).join(\" \");\n        if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance2.logLevel)) {\n          logCallback({\n            level: LogLevel[level].toLowerCase(),\n            message,\n            args,\n            type: instance2.name\n          });\n        }\n      };\n    }\n  }\n}\n\n// node_modules/idb/build/wrap-idb-value.js\nvar instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\nvar idbProxyableTypes;\nvar cursorAdvanceMethods;\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [\n    IDBDatabase,\n    IDBObjectStore,\n    IDBIndex,\n    IDBCursor,\n    IDBTransaction\n  ]);\n}\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [\n    IDBCursor.prototype.advance,\n    IDBCursor.prototype.continue,\n    IDBCursor.prototype.continuePrimaryKey\n  ]);\n}\nvar cursorRequestMap = /* @__PURE__ */ new WeakMap();\nvar transactionDoneMap = /* @__PURE__ */ new WeakMap();\nvar transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();\nvar transformCache = /* @__PURE__ */ new WeakMap();\nvar reverseTransformCache = /* @__PURE__ */ new WeakMap();\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener(\"success\", success);\n      request.removeEventListener(\"error\", error);\n    };\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener(\"success\", success);\n    request.addEventListener(\"error\", error);\n  });\n  promise.then((value) => {\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    }\n  }).catch(() => {\n  });\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  if (transactionDoneMap.has(tx))\n    return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener(\"complete\", complete);\n      tx.removeEventListener(\"error\", error);\n      tx.removeEventListener(\"abort\", error);\n    };\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n    const error = () => {\n      reject(tx.error || new DOMException(\"AbortError\", \"AbortError\"));\n      unlisten();\n    };\n    tx.addEventListener(\"complete\", complete);\n    tx.addEventListener(\"error\", error);\n    tx.addEventListener(\"abort\", error);\n  });\n  transactionDoneMap.set(tx, done);\n}\nvar idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      if (prop === \"done\")\n        return transactionDoneMap.get(target);\n      if (prop === \"objectStoreNames\") {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      }\n      if (prop === \"store\") {\n        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    return wrap(target[prop]);\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === \"done\" || prop === \"store\")) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  if (func === IDBDatabase.prototype.transaction && !(\"objectStoreNames\" in IDBTransaction.prototype)) {\n    return function(storeNames, ...args) {\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  }\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function(...args) {\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n  return function(...args) {\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === \"function\")\n    return wrapFunction(value);\n  if (value instanceof IDBTransaction)\n    cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes()))\n    return new Proxy(value, idbProxyTraps);\n  return value;\n}\nfunction wrap(value) {\n  if (value instanceof IDBRequest)\n    return promisifyRequest(value);\n  if (transformCache.has(value))\n    return transformCache.get(value);\n  const newValue = transformCachableValue(value);\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nvar unwrap = (value) => reverseTransformCache.get(value);\n\n// node_modules/idb/build/index.js\nfunction openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {\n  const request = indexedDB.open(name2, version2);\n  const openPromise = wrap(request);\n  if (upgrade) {\n    request.addEventListener(\"upgradeneeded\", (event) => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n    });\n  }\n  if (blocked) {\n    request.addEventListener(\"blocked\", (event) => blocked(\n      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n      event.oldVersion,\n      event.newVersion,\n      event\n    ));\n  }\n  openPromise.then((db) => {\n    if (terminated)\n      db.addEventListener(\"close\", () => terminated());\n    if (blocking) {\n      db.addEventListener(\"versionchange\", (event) => blocking(event.oldVersion, event.newVersion, event));\n    }\n  }).catch(() => {\n  });\n  return openPromise;\n}\nvar readMethods = [\"get\", \"getKey\", \"getAll\", \"getAllKeys\", \"count\"];\nvar writeMethods = [\"put\", \"add\", \"delete\", \"clear\"];\nvar cachedMethods = /* @__PURE__ */ new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === \"string\")) {\n    return;\n  }\n  if (cachedMethods.get(prop))\n    return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, \"\");\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))\n  ) {\n    return;\n  }\n  const method = async function(storeName, ...args) {\n    const tx = this.transaction(storeName, isWrite ? \"readwrite\" : \"readonly\");\n    let target2 = tx.store;\n    if (useIndex)\n      target2 = target2.index(args.shift());\n    return (await Promise.all([\n      target2[targetFuncName](...args),\n      isWrite && tx.done\n    ]))[0];\n  };\n  cachedMethods.set(prop, method);\n  return method;\n}\nreplaceTraps((oldTraps) => ({\n  ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\n\n// node_modules/@firebase/app/dist/esm/index.esm2017.js\nvar PlatformLoggerServiceImpl = class {\n  constructor(container) {\n    this.container = container;\n  }\n  // In initial implementation, this will be called by installations on\n  // auth token refresh, and installations will send this string.\n  getPlatformInfoString() {\n    const providers = this.container.getProviders();\n    return providers.map((provider) => {\n      if (isVersionServiceProvider(provider)) {\n        const service = provider.getImmediate();\n        return `${service.library}/${service.version}`;\n      } else {\n        return null;\n      }\n    }).filter((logString) => logString).join(\" \");\n  }\n};\nfunction isVersionServiceProvider(provider) {\n  const component = provider.getComponent();\n  return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\";\n}\nvar name$o = \"@firebase/app\";\nvar version$1 = \"0.9.23\";\nvar logger = new Logger(\"@firebase/app\");\nvar name$n = \"@firebase/app-compat\";\nvar name$m = \"@firebase/analytics-compat\";\nvar name$l = \"@firebase/analytics\";\nvar name$k = \"@firebase/app-check-compat\";\nvar name$j = \"@firebase/app-check\";\nvar name$i = \"@firebase/auth\";\nvar name$h = \"@firebase/auth-compat\";\nvar name$g = \"@firebase/database\";\nvar name$f = \"@firebase/database-compat\";\nvar name$e = \"@firebase/functions\";\nvar name$d = \"@firebase/functions-compat\";\nvar name$c = \"@firebase/installations\";\nvar name$b = \"@firebase/installations-compat\";\nvar name$a = \"@firebase/messaging\";\nvar name$9 = \"@firebase/messaging-compat\";\nvar name$8 = \"@firebase/performance\";\nvar name$7 = \"@firebase/performance-compat\";\nvar name$6 = \"@firebase/remote-config\";\nvar name$5 = \"@firebase/remote-config-compat\";\nvar name$4 = \"@firebase/storage\";\nvar name$3 = \"@firebase/storage-compat\";\nvar name$2 = \"@firebase/firestore\";\nvar name$1 = \"@firebase/firestore-compat\";\nvar name = \"firebase\";\nvar version = \"10.6.0\";\nvar DEFAULT_ENTRY_NAME2 = \"[DEFAULT]\";\nvar PLATFORM_LOG_STRING = {\n  [name$o]: \"fire-core\",\n  [name$n]: \"fire-core-compat\",\n  [name$l]: \"fire-analytics\",\n  [name$m]: \"fire-analytics-compat\",\n  [name$j]: \"fire-app-check\",\n  [name$k]: \"fire-app-check-compat\",\n  [name$i]: \"fire-auth\",\n  [name$h]: \"fire-auth-compat\",\n  [name$g]: \"fire-rtdb\",\n  [name$f]: \"fire-rtdb-compat\",\n  [name$e]: \"fire-fn\",\n  [name$d]: \"fire-fn-compat\",\n  [name$c]: \"fire-iid\",\n  [name$b]: \"fire-iid-compat\",\n  [name$a]: \"fire-fcm\",\n  [name$9]: \"fire-fcm-compat\",\n  [name$8]: \"fire-perf\",\n  [name$7]: \"fire-perf-compat\",\n  [name$6]: \"fire-rc\",\n  [name$5]: \"fire-rc-compat\",\n  [name$4]: \"fire-gcs\",\n  [name$3]: \"fire-gcs-compat\",\n  [name$2]: \"fire-fst\",\n  [name$1]: \"fire-fst-compat\",\n  \"fire-js\": \"fire-js\",\n  [name]: \"fire-js-all\"\n};\nvar _apps = /* @__PURE__ */ new Map();\nvar _components = /* @__PURE__ */ new Map();\nfunction _addComponent(app, component) {\n  try {\n    app.container.addComponent(component);\n  } catch (e) {\n    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n  }\n}\nfunction _addOrOverwriteComponent(app, component) {\n  app.container.addOrOverwriteComponent(component);\n}\nfunction _registerComponent(component) {\n  const componentName = component.name;\n  if (_components.has(componentName)) {\n    logger.debug(`There were multiple attempts to register component ${componentName}.`);\n    return false;\n  }\n  _components.set(componentName, component);\n  for (const app of _apps.values()) {\n    _addComponent(app, component);\n  }\n  return true;\n}\nfunction _getProvider(app, name2) {\n  const heartbeatController = app.container.getProvider(\"heartbeat\").getImmediate({ optional: true });\n  if (heartbeatController) {\n    void heartbeatController.triggerHeartbeat();\n  }\n  return app.container.getProvider(name2);\n}\nfunction _removeServiceInstance(app, name2, instanceIdentifier = DEFAULT_ENTRY_NAME2) {\n  _getProvider(app, name2).clearInstance(instanceIdentifier);\n}\nfunction _clearComponents() {\n  _components.clear();\n}\nvar ERRORS = {\n  [\n    \"no-app\"\n    /* AppError.NO_APP */\n  ]: \"No Firebase App '{$appName}' has been created - call initializeApp() first\",\n  [\n    \"bad-app-name\"\n    /* AppError.BAD_APP_NAME */\n  ]: \"Illegal App name: '{$appName}\",\n  [\n    \"duplicate-app\"\n    /* AppError.DUPLICATE_APP */\n  ]: \"Firebase App named '{$appName}' already exists with different options or config\",\n  [\n    \"app-deleted\"\n    /* AppError.APP_DELETED */\n  ]: \"Firebase App named '{$appName}' already deleted\",\n  [\n    \"no-options\"\n    /* AppError.NO_OPTIONS */\n  ]: \"Need to provide options, when not being deployed to hosting via source.\",\n  [\n    \"invalid-app-argument\"\n    /* AppError.INVALID_APP_ARGUMENT */\n  ]: \"firebase.{$appName}() takes either no argument or a Firebase App instance.\",\n  [\n    \"invalid-log-argument\"\n    /* AppError.INVALID_LOG_ARGUMENT */\n  ]: \"First argument to `onLog` must be null or a function.\",\n  [\n    \"idb-open\"\n    /* AppError.IDB_OPEN */\n  ]: \"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.\",\n  [\n    \"idb-get\"\n    /* AppError.IDB_GET */\n  ]: \"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.\",\n  [\n    \"idb-set\"\n    /* AppError.IDB_WRITE */\n  ]: \"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.\",\n  [\n    \"idb-delete\"\n    /* AppError.IDB_DELETE */\n  ]: \"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.\"\n};\nvar ERROR_FACTORY = new ErrorFactory(\"app\", \"Firebase\", ERRORS);\nvar FirebaseAppImpl = class {\n  constructor(options, config, container) {\n    this._isDeleted = false;\n    this._options = Object.assign({}, options);\n    this._config = Object.assign({}, config);\n    this._name = config.name;\n    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;\n    this._container = container;\n    this.container.addComponent(new Component(\n      \"app\",\n      () => this,\n      \"PUBLIC\"\n      /* ComponentType.PUBLIC */\n    ));\n  }\n  get automaticDataCollectionEnabled() {\n    this.checkDestroyed();\n    return this._automaticDataCollectionEnabled;\n  }\n  set automaticDataCollectionEnabled(val) {\n    this.checkDestroyed();\n    this._automaticDataCollectionEnabled = val;\n  }\n  get name() {\n    this.checkDestroyed();\n    return this._name;\n  }\n  get options() {\n    this.checkDestroyed();\n    return this._options;\n  }\n  get config() {\n    this.checkDestroyed();\n    return this._config;\n  }\n  get container() {\n    return this._container;\n  }\n  get isDeleted() {\n    return this._isDeleted;\n  }\n  set isDeleted(val) {\n    this._isDeleted = val;\n  }\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  checkDestroyed() {\n    if (this.isDeleted) {\n      throw ERROR_FACTORY.create(\"app-deleted\", { appName: this._name });\n    }\n  }\n};\nvar SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n  let options = _options;\n  if (typeof rawConfig !== \"object\") {\n    const name3 = rawConfig;\n    rawConfig = { name: name3 };\n  }\n  const config = Object.assign({ name: DEFAULT_ENTRY_NAME2, automaticDataCollectionEnabled: false }, rawConfig);\n  const name2 = config.name;\n  if (typeof name2 !== \"string\" || !name2) {\n    throw ERROR_FACTORY.create(\"bad-app-name\", {\n      appName: String(name2)\n    });\n  }\n  options || (options = getDefaultAppConfig());\n  if (!options) {\n    throw ERROR_FACTORY.create(\n      \"no-options\"\n      /* AppError.NO_OPTIONS */\n    );\n  }\n  const existingApp = _apps.get(name2);\n  if (existingApp) {\n    if (deepEqual(options, existingApp.options) && deepEqual(config, existingApp.config)) {\n      return existingApp;\n    } else {\n      throw ERROR_FACTORY.create(\"duplicate-app\", { appName: name2 });\n    }\n  }\n  const container = new ComponentContainer(name2);\n  for (const component of _components.values()) {\n    container.addComponent(component);\n  }\n  const newApp = new FirebaseAppImpl(options, config, container);\n  _apps.set(name2, newApp);\n  return newApp;\n}\nfunction getApp(name2 = DEFAULT_ENTRY_NAME2) {\n  const app = _apps.get(name2);\n  if (!app && name2 === DEFAULT_ENTRY_NAME2 && getDefaultAppConfig()) {\n    return initializeApp();\n  }\n  if (!app) {\n    throw ERROR_FACTORY.create(\"no-app\", { appName: name2 });\n  }\n  return app;\n}\nfunction getApps() {\n  return Array.from(_apps.values());\n}\nasync function deleteApp(app) {\n  const name2 = app.name;\n  if (_apps.has(name2)) {\n    _apps.delete(name2);\n    await Promise.all(app.container.getProviders().map((provider) => provider.delete()));\n    app.isDeleted = true;\n  }\n}\nfunction registerVersion(libraryKeyOrName, version2, variant) {\n  var _a;\n  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n  if (variant) {\n    library += `-${variant}`;\n  }\n  const libraryMismatch = library.match(/\\s|\\//);\n  const versionMismatch = version2.match(/\\s|\\//);\n  if (libraryMismatch || versionMismatch) {\n    const warning = [\n      `Unable to register library \"${library}\" with version \"${version2}\":`\n    ];\n    if (libraryMismatch) {\n      warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n    }\n    if (libraryMismatch && versionMismatch) {\n      warning.push(\"and\");\n    }\n    if (versionMismatch) {\n      warning.push(`version name \"${version2}\" contains illegal characters (whitespace or \"/\")`);\n    }\n    logger.warn(warning.join(\" \"));\n    return;\n  }\n  _registerComponent(new Component(\n    `${library}-version`,\n    () => ({ library, version: version2 }),\n    \"VERSION\"\n    /* ComponentType.VERSION */\n  ));\n}\nfunction onLog(logCallback, options) {\n  if (logCallback !== null && typeof logCallback !== \"function\") {\n    throw ERROR_FACTORY.create(\n      \"invalid-log-argument\"\n      /* AppError.INVALID_LOG_ARGUMENT */\n    );\n  }\n  setUserLogHandler(logCallback, options);\n}\nfunction setLogLevel2(logLevel) {\n  setLogLevel(logLevel);\n}\nvar DB_NAME = \"firebase-heartbeat-database\";\nvar DB_VERSION = 1;\nvar STORE_NAME = \"firebase-heartbeat-store\";\nvar dbPromise = null;\nfunction getDbPromise() {\n  if (!dbPromise) {\n    dbPromise = openDB(DB_NAME, DB_VERSION, {\n      upgrade: (db, oldVersion) => {\n        switch (oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME);\n        }\n      }\n    }).catch((e) => {\n      throw ERROR_FACTORY.create(\"idb-open\", {\n        originalErrorMessage: e.message\n      });\n    });\n  }\n  return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n  try {\n    const db = await getDbPromise();\n    const result = await db.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app));\n    return result;\n  } catch (e) {\n    if (e instanceof FirebaseError) {\n      logger.warn(e.message);\n    } else {\n      const idbGetError = ERROR_FACTORY.create(\"idb-get\", {\n        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n      });\n      logger.warn(idbGetError.message);\n    }\n  }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n  try {\n    const db = await getDbPromise();\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\n    const objectStore = tx.objectStore(STORE_NAME);\n    await objectStore.put(heartbeatObject, computeKey(app));\n    await tx.done;\n  } catch (e) {\n    if (e instanceof FirebaseError) {\n      logger.warn(e.message);\n    } else {\n      const idbGetError = ERROR_FACTORY.create(\"idb-set\", {\n        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n      });\n      logger.warn(idbGetError.message);\n    }\n  }\n}\nfunction computeKey(app) {\n  return `${app.name}!${app.options.appId}`;\n}\nvar MAX_HEADER_BYTES = 1024;\nvar STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3;\nvar HeartbeatServiceImpl = class {\n  constructor(container) {\n    this.container = container;\n    this._heartbeatsCache = null;\n    const app = this.container.getProvider(\"app\").getImmediate();\n    this._storage = new HeartbeatStorageImpl(app);\n    this._heartbeatsCachePromise = this._storage.read().then((result) => {\n      this._heartbeatsCache = result;\n      return result;\n    });\n  }\n  /**\n   * Called to report a heartbeat. The function will generate\n   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n   * to IndexedDB.\n   * Note that we only store one heartbeat per day. So if a heartbeat for today is\n   * already logged, subsequent calls to this function in the same day will be ignored.\n   */\n  async triggerHeartbeat() {\n    var _a;\n    const platformLogger = this.container.getProvider(\"platform-logger\").getImmediate();\n    const agent = platformLogger.getPlatformInfoString();\n    const date = getUTCDateString();\n    if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n      this._heartbeatsCache = await this._heartbeatsCachePromise;\n    }\n    if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {\n      return;\n    } else {\n      this._heartbeatsCache.heartbeats.push({ date, agent });\n    }\n    this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat) => {\n      const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n      const now = Date.now();\n      return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n    });\n    return this._storage.overwrite(this._heartbeatsCache);\n  }\n  /**\n   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n   * It also clears all heartbeats from memory as well as in IndexedDB.\n   *\n   * NOTE: Consuming product SDKs should not send the header if this method\n   * returns an empty string.\n   */\n  async getHeartbeatsHeader() {\n    var _a;\n    if (this._heartbeatsCache === null) {\n      await this._heartbeatsCachePromise;\n    }\n    if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {\n      return \"\";\n    }\n    const date = getUTCDateString();\n    const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n    const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\n    this._heartbeatsCache.lastSentHeartbeatDate = date;\n    if (unsentEntries.length > 0) {\n      this._heartbeatsCache.heartbeats = unsentEntries;\n      await this._storage.overwrite(this._heartbeatsCache);\n    } else {\n      this._heartbeatsCache.heartbeats = [];\n      void this._storage.overwrite(this._heartbeatsCache);\n    }\n    return headerString;\n  }\n};\nfunction getUTCDateString() {\n  const today = /* @__PURE__ */ new Date();\n  return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n  const heartbeatsToSend = [];\n  let unsentEntries = heartbeatsCache.slice();\n  for (const singleDateHeartbeat of heartbeatsCache) {\n    const heartbeatEntry = heartbeatsToSend.find((hb) => hb.agent === singleDateHeartbeat.agent);\n    if (!heartbeatEntry) {\n      heartbeatsToSend.push({\n        agent: singleDateHeartbeat.agent,\n        dates: [singleDateHeartbeat.date]\n      });\n      if (countBytes(heartbeatsToSend) > maxSize) {\n        heartbeatsToSend.pop();\n        break;\n      }\n    } else {\n      heartbeatEntry.dates.push(singleDateHeartbeat.date);\n      if (countBytes(heartbeatsToSend) > maxSize) {\n        heartbeatEntry.dates.pop();\n        break;\n      }\n    }\n    unsentEntries = unsentEntries.slice(1);\n  }\n  return {\n    heartbeatsToSend,\n    unsentEntries\n  };\n}\nvar HeartbeatStorageImpl = class {\n  constructor(app) {\n    this.app = app;\n    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n  }\n  async runIndexedDBEnvironmentCheck() {\n    if (!isIndexedDBAvailable()) {\n      return false;\n    } else {\n      return validateIndexedDBOpenable().then(() => true).catch(() => false);\n    }\n  }\n  /**\n   * Read all heartbeats.\n   */\n  async read() {\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return { heartbeats: [] };\n    } else {\n      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n      return idbHeartbeatObject || { heartbeats: [] };\n    }\n  }\n  // overwrite the storage with the provided heartbeats\n  async overwrite(heartbeatsObject) {\n    var _a;\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return;\n    } else {\n      const existingHeartbeatsObject = await this.read();\n      return writeHeartbeatsToIndexedDB(this.app, {\n        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n        heartbeats: heartbeatsObject.heartbeats\n      });\n    }\n  }\n  // add heartbeats\n  async add(heartbeatsObject) {\n    var _a;\n    const canUseIndexedDB = await this._canUseIndexedDBPromise;\n    if (!canUseIndexedDB) {\n      return;\n    } else {\n      const existingHeartbeatsObject = await this.read();\n      return writeHeartbeatsToIndexedDB(this.app, {\n        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n        heartbeats: [\n          ...existingHeartbeatsObject.heartbeats,\n          ...heartbeatsObject.heartbeats\n        ]\n      });\n    }\n  }\n};\nfunction countBytes(heartbeatsCache) {\n  return base64urlEncodeWithoutPadding(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })\n  ).length;\n}\nfunction registerCoreComponents(variant) {\n  _registerComponent(new Component(\n    \"platform-logger\",\n    (container) => new PlatformLoggerServiceImpl(container),\n    \"PRIVATE\"\n    /* ComponentType.PRIVATE */\n  ));\n  _registerComponent(new Component(\n    \"heartbeat\",\n    (container) => new HeartbeatServiceImpl(container),\n    \"PRIVATE\"\n    /* ComponentType.PRIVATE */\n  ));\n  registerVersion(name$o, version$1, variant);\n  registerVersion(name$o, version$1, \"esm2017\");\n  registerVersion(\"fire-js\", \"\");\n}\nregisterCoreComponents(\"\");\n\nexport {\n  base64Decode,\n  getDefaultEmulatorHost,\n  getExperimentalSetting,\n  getUA,\n  isMobileCordova,\n  isBrowserExtension,\n  isReactNative,\n  isIE,\n  FirebaseError,\n  ErrorFactory,\n  isEmpty,\n  deepEqual,\n  querystring,\n  querystringDecode,\n  extractQuerystring,\n  createSubscribe,\n  getModularInstance,\n  Component,\n  LogLevel,\n  Logger,\n  DEFAULT_ENTRY_NAME2 as DEFAULT_ENTRY_NAME,\n  _apps,\n  _components,\n  _addComponent,\n  _addOrOverwriteComponent,\n  _registerComponent,\n  _getProvider,\n  _removeServiceInstance,\n  _clearComponents,\n  SDK_VERSION,\n  initializeApp,\n  getApp,\n  getApps,\n  deleteApp,\n  registerVersion,\n  onLog,\n  setLogLevel2 as setLogLevel\n};\n/*! Bundled license information:\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2022 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n  (**\n   * @license\n   * Copyright 2021 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2022 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2022 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2019 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2020 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/util/dist/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2021 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/component/dist/esm/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2019 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/logger/dist/esm/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2017 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n\n@firebase/app/dist/esm/index.esm2017.js:\n  (**\n   * @license\n   * Copyright 2019 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n  (**\n   * @license\n   * Copyright 2021 Google LLC\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *)\n*/\n//# sourceMappingURL=chunk-B7GYBXJM.js.map\n",
      "start": 1701867792433,
      "end": 1701867792433,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
