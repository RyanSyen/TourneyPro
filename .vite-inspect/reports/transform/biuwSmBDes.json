{
  "resolvedId": "/@react-refresh",
  "transforms": [
    {
      "name": "vite:react-swc:resolve-runtime",
      "result": "/*! Copyright (c) Meta Platforms, Inc. and affiliates. **/\nconst REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nconst REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nlet allFamiliesByID = /* @__PURE__ */ new Map();\nlet allFamiliesByType = /* @__PURE__ */ new WeakMap();\nlet allSignaturesByType = /* @__PURE__ */ new WeakMap();\nconst updatedFamiliesByType = /* @__PURE__ */ new WeakMap();\nlet pendingUpdates = [];\nconst helpersByRendererID = /* @__PURE__ */ new Map();\nconst helpersByRoot = /* @__PURE__ */ new Map();\nconst mountedRoots = /* @__PURE__ */ new Set();\nconst failedRoots = /* @__PURE__ */ new Set();\nlet rootElements = /* @__PURE__ */ new WeakMap();\nlet isPerformingRefresh = false;\nfunction computeFullKey(signature) {\n  if (signature.fullKey !== null) {\n    return signature.fullKey;\n  }\n  let fullKey = signature.ownKey;\n  let hooks;\n  try {\n    hooks = signature.getCustomHooks();\n  } catch (err) {\n    signature.forceReset = true;\n    signature.fullKey = fullKey;\n    return fullKey;\n  }\n  for (let i = 0; i < hooks.length; i++) {\n    const hook = hooks[i];\n    if (typeof hook !== \"function\") {\n      signature.forceReset = true;\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n    const nestedHookSignature = allSignaturesByType.get(hook);\n    if (nestedHookSignature === void 0) {\n      continue;\n    }\n    const nestedHookKey = computeFullKey(nestedHookSignature);\n    if (nestedHookSignature.forceReset) {\n      signature.forceReset = true;\n    }\n    fullKey += \"\\n---\\n\" + nestedHookKey;\n  }\n  signature.fullKey = fullKey;\n  return fullKey;\n}\nfunction haveEqualSignatures(prevType, nextType) {\n  const prevSignature = allSignaturesByType.get(prevType);\n  const nextSignature = allSignaturesByType.get(nextType);\n  if (prevSignature === void 0 && nextSignature === void 0) {\n    return true;\n  }\n  if (prevSignature === void 0 || nextSignature === void 0) {\n    return false;\n  }\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n    return false;\n  }\n  if (nextSignature.forceReset) {\n    return false;\n  }\n  return true;\n}\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\nfunction canPreserveStateBetween(prevType, nextType) {\n  if (isReactClass(prevType) || isReactClass(nextType)) {\n    return false;\n  }\n  if (haveEqualSignatures(prevType, nextType)) {\n    return true;\n  }\n  return false;\n}\nfunction resolveFamily(type) {\n  return updatedFamiliesByType.get(type);\n}\nfunction getProperty(object, property) {\n  try {\n    return object[property];\n  } catch (err) {\n    return void 0;\n  }\n}\nfunction performReactRefresh() {\n  if (pendingUpdates.length === 0) {\n    return null;\n  }\n  if (isPerformingRefresh) {\n    return null;\n  }\n  isPerformingRefresh = true;\n  try {\n    const staleFamilies = /* @__PURE__ */ new Set();\n    const updatedFamilies = /* @__PURE__ */ new Set();\n    const updates = pendingUpdates;\n    pendingUpdates = [];\n    updates.forEach(([family, nextType]) => {\n      const prevType = family.current;\n      updatedFamiliesByType.set(prevType, family);\n      updatedFamiliesByType.set(nextType, family);\n      family.current = nextType;\n      if (canPreserveStateBetween(prevType, nextType)) {\n        updatedFamilies.add(family);\n      } else {\n        staleFamilies.add(family);\n      }\n    });\n    const update = {\n      updatedFamilies,\n      // Families that will re-render preserving state\n      staleFamilies\n      // Families that will be remounted\n    };\n    helpersByRendererID.forEach((helpers) => {\n      helpers.setRefreshHandler(resolveFamily);\n    });\n    let didError = false;\n    let firstError = null;\n    const failedRootsSnapshot = new Set(failedRoots);\n    const mountedRootsSnapshot = new Set(mountedRoots);\n    const helpersByRootSnapshot = new Map(helpersByRoot);\n    failedRootsSnapshot.forEach((root) => {\n      const helpers = helpersByRootSnapshot.get(root);\n      if (helpers === void 0) {\n        throw new Error(\n          \"Could not find helpers for a root. This is a bug in React Refresh.\"\n        );\n      }\n      if (!failedRoots.has(root)) {\n      }\n      if (rootElements === null) {\n        return;\n      }\n      if (!rootElements.has(root)) {\n        return;\n      }\n      const element = rootElements.get(root);\n      try {\n        helpers.scheduleRoot(root, element);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        }\n      }\n    });\n    mountedRootsSnapshot.forEach((root) => {\n      const helpers = helpersByRootSnapshot.get(root);\n      if (helpers === void 0) {\n        throw new Error(\n          \"Could not find helpers for a root. This is a bug in React Refresh.\"\n        );\n      }\n      if (!mountedRoots.has(root)) {\n      }\n      try {\n        helpers.scheduleRefresh(root, update);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        }\n      }\n    });\n    if (didError) {\n      throw firstError;\n    }\n    return update;\n  } finally {\n    isPerformingRefresh = false;\n  }\n}\nfunction register(type, id) {\n  if (type === null) {\n    return;\n  }\n  if (typeof type !== \"function\" && typeof type !== \"object\") {\n    return;\n  }\n  if (allFamiliesByType.has(type)) {\n    return;\n  }\n  let family = allFamiliesByID.get(id);\n  if (family === void 0) {\n    family = { current: type };\n    allFamiliesByID.set(id, family);\n  } else {\n    pendingUpdates.push([family, type]);\n  }\n  allFamiliesByType.set(type, family);\n  if (typeof type === \"object\" && type !== null) {\n    switch (getProperty(type, \"$$typeof\")) {\n      case REACT_FORWARD_REF_TYPE:\n        register(type.render, id + \"$render\");\n        break;\n      case REACT_MEMO_TYPE:\n        register(type.type, id + \"$type\");\n        break;\n    }\n  }\n}\nfunction setSignature(type, key, forceReset, getCustomHooks) {\n  if (!allSignaturesByType.has(type)) {\n    allSignaturesByType.set(type, {\n      forceReset,\n      ownKey: key,\n      fullKey: null,\n      getCustomHooks: getCustomHooks || (() => [])\n    });\n  }\n  if (typeof type === \"object\" && type !== null) {\n    switch (getProperty(type, \"$$typeof\")) {\n      case REACT_FORWARD_REF_TYPE:\n        setSignature(type.render, key, forceReset, getCustomHooks);\n        break;\n      case REACT_MEMO_TYPE:\n        setSignature(type.type, key, forceReset, getCustomHooks);\n        break;\n    }\n  }\n}\nfunction collectCustomHooksForSignature(type) {\n  const signature = allSignaturesByType.get(type);\n  if (signature !== void 0) {\n    computeFullKey(signature);\n  }\n}\nfunction injectIntoGlobalHook(globalObject) {\n  let hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook === void 0) {\n    let nextID = 0;\n    globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n      renderers: /* @__PURE__ */ new Map(),\n      supportsFiber: true,\n      inject: (injected) => nextID++,\n      onScheduleFiberRoot: (id, root, children) => {\n      },\n      onCommitFiberRoot: (id, root, maybePriorityLevel, didError) => {\n      },\n      onCommitFiberUnmount() {\n      }\n    };\n  }\n  if (hook.isDisabled) {\n    console[\"warn\"](\n      \"Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). Fast Refresh is not compatible with this shim and will be disabled.\"\n    );\n    return;\n  }\n  const oldInject = hook.inject;\n  hook.inject = function(injected) {\n    const id = oldInject.apply(this, arguments);\n    if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n      helpersByRendererID.set(id, injected);\n    }\n    return id;\n  };\n  hook.renderers.forEach((injected, id) => {\n    if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n      helpersByRendererID.set(id, injected);\n    }\n  });\n  const oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n  const oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || (() => {\n  });\n  hook.onScheduleFiberRoot = function(id, root, children) {\n    if (!isPerformingRefresh) {\n      failedRoots.delete(root);\n      if (rootElements !== null) {\n        rootElements.set(root, children);\n      }\n    }\n    return oldOnScheduleFiberRoot.apply(this, arguments);\n  };\n  hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {\n    const helpers = helpersByRendererID.get(id);\n    if (helpers !== void 0) {\n      helpersByRoot.set(root, helpers);\n      const current = root.current;\n      const alternate = current.alternate;\n      if (alternate !== null) {\n        const wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n        const isMounted = current.memoizedState != null && current.memoizedState.element != null;\n        if (!wasMounted && isMounted) {\n          mountedRoots.add(root);\n          failedRoots.delete(root);\n        } else if (wasMounted && isMounted) {\n        } else if (wasMounted && !isMounted) {\n          mountedRoots.delete(root);\n          if (didError) {\n            failedRoots.add(root);\n          } else {\n            helpersByRoot.delete(root);\n          }\n        } else if (!wasMounted && !isMounted) {\n          if (didError) {\n            failedRoots.add(root);\n          }\n        }\n      } else {\n        mountedRoots.add(root);\n      }\n    }\n    return oldOnCommitFiberRoot.apply(this, arguments);\n  };\n}\nfunction createSignatureFunctionForTransform() {\n  let savedType;\n  let hasCustomHooks;\n  let didCollectHooks = false;\n  return function(type, key, forceReset, getCustomHooks) {\n    if (typeof key === \"string\") {\n      if (!savedType) {\n        savedType = type;\n        hasCustomHooks = typeof getCustomHooks === \"function\";\n      }\n      if (type != null && (typeof type === \"function\" || typeof type === \"object\")) {\n        setSignature(type, key, forceReset, getCustomHooks);\n      }\n      return type;\n    } else {\n      if (!didCollectHooks && hasCustomHooks) {\n        didCollectHooks = true;\n        collectCustomHooksForSignature(savedType);\n      }\n    }\n  };\n}\nfunction isLikelyComponentType(type) {\n  switch (typeof type) {\n    case \"function\": {\n      if (type.prototype != null) {\n        if (type.prototype.isReactComponent) {\n          return true;\n        }\n        const ownNames = Object.getOwnPropertyNames(type.prototype);\n        if (ownNames.length > 1 || ownNames[0] !== \"constructor\") {\n          return false;\n        }\n        if (type.prototype.__proto__ !== Object.prototype) {\n          return false;\n        }\n      }\n      const name = type.name || type.displayName;\n      return typeof name === \"string\" && /^[A-Z]/.test(name);\n    }\n    case \"object\": {\n      if (type != null) {\n        switch (getProperty(type, \"$$typeof\")) {\n          case REACT_FORWARD_REF_TYPE:\n          case REACT_MEMO_TYPE:\n            return true;\n          default:\n            return false;\n        }\n      }\n      return false;\n    }\n    default: {\n      return false;\n    }\n  }\n}\nif (window.$RefreshReg$) {\n  throw new Error(\n    \"React refresh runtime was loaded twice. Maybe you forgot the base path?\"\n  );\n}\nfunction getRefreshReg(filename) {\n  return (type, id) => register(type, filename + \" \" + id);\n}\nfunction registerExportsForReactRefresh(filename, moduleExports) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const exportValue = moduleExports[key];\n    if (isLikelyComponentType(exportValue)) {\n      register(exportValue, filename + \" export \" + key);\n    }\n  }\n}\nfunction debounce(fn, delay) {\n  let handle;\n  return () => {\n    clearTimeout(handle);\n    handle = setTimeout(fn, delay);\n  };\n}\nconst enqueueUpdate = debounce(performReactRefresh, 16);\nfunction validateRefreshBoundaryAndEnqueueUpdate(prevExports, nextExports) {\n  if (!predicateOnExport(prevExports, (key) => key in nextExports)) {\n    return \"Could not Fast Refresh (export removed)\";\n  }\n  if (!predicateOnExport(nextExports, (key) => key in prevExports)) {\n    return \"Could not Fast Refresh (new export)\";\n  }\n  let hasExports = false;\n  const allExportsAreComponentsOrUnchanged = predicateOnExport(\n    nextExports,\n    (key, value) => {\n      hasExports = true;\n      if (isLikelyComponentType(value))\n        return true;\n      return prevExports[key] === nextExports[key];\n    }\n  );\n  if (hasExports && allExportsAreComponentsOrUnchanged) {\n    enqueueUpdate();\n  } else {\n    return \"Could not Fast Refresh. Learn more at https://github.com/vitejs/vite-plugin-react-swc#consistent-components-exports\";\n  }\n}\nfunction predicateOnExport(moduleExports, predicate) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n    if (desc && desc.get)\n      return false;\n    if (!predicate(key, moduleExports[key]))\n      return false;\n  }\n  return true;\n}\nconst __hmr_import = (module) => import(\n  /* @vite-ignore */\n  module\n);\nvar refresh_runtime_default = { injectIntoGlobalHook };\nexport {\n  __hmr_import,\n  createSignatureFunctionForTransform,\n  refresh_runtime_default as default,\n  getRefreshReg,\n  injectIntoGlobalHook,\n  registerExportsForReactRefresh,\n  validateRefreshBoundaryAndEnqueueUpdate\n};\n",
      "start": 1701867791852,
      "end": 1701867791852,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1701867791853,
      "end": 1701867791853,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1701867791853,
      "end": 1701867791853,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1701867791853,
      "end": 1701867791853,
      "order": "normal"
    },
    {
      "name": "vite:react-swc",
      "start": 1701867791853,
      "end": 1701867791853,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1701867791853,
      "end": 1701867791853,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1701867791853,
      "end": 1701867791854,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1701867791854,
      "end": 1701867791854,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1701867791854,
      "end": 1701867791854,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1701867791854,
      "end": 1701867791856,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1701867791856,
      "end": 1701867791856,
      "order": "normal"
    },
    {
      "name": "vite:client-inject",
      "start": 1701867791856,
      "end": 1701867791856,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { injectQuery as __vite__injectQuery } from \"/@vite/client\";/*! Copyright (c) Meta Platforms, Inc. and affiliates. **/\nconst REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nconst REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nlet allFamiliesByID = /* @__PURE__ */ new Map();\nlet allFamiliesByType = /* @__PURE__ */ new WeakMap();\nlet allSignaturesByType = /* @__PURE__ */ new WeakMap();\nconst updatedFamiliesByType = /* @__PURE__ */ new WeakMap();\nlet pendingUpdates = [];\nconst helpersByRendererID = /* @__PURE__ */ new Map();\nconst helpersByRoot = /* @__PURE__ */ new Map();\nconst mountedRoots = /* @__PURE__ */ new Set();\nconst failedRoots = /* @__PURE__ */ new Set();\nlet rootElements = /* @__PURE__ */ new WeakMap();\nlet isPerformingRefresh = false;\nfunction computeFullKey(signature) {\n  if (signature.fullKey !== null) {\n    return signature.fullKey;\n  }\n  let fullKey = signature.ownKey;\n  let hooks;\n  try {\n    hooks = signature.getCustomHooks();\n  } catch (err) {\n    signature.forceReset = true;\n    signature.fullKey = fullKey;\n    return fullKey;\n  }\n  for (let i = 0; i < hooks.length; i++) {\n    const hook = hooks[i];\n    if (typeof hook !== \"function\") {\n      signature.forceReset = true;\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n    const nestedHookSignature = allSignaturesByType.get(hook);\n    if (nestedHookSignature === void 0) {\n      continue;\n    }\n    const nestedHookKey = computeFullKey(nestedHookSignature);\n    if (nestedHookSignature.forceReset) {\n      signature.forceReset = true;\n    }\n    fullKey += \"\\n---\\n\" + nestedHookKey;\n  }\n  signature.fullKey = fullKey;\n  return fullKey;\n}\nfunction haveEqualSignatures(prevType, nextType) {\n  const prevSignature = allSignaturesByType.get(prevType);\n  const nextSignature = allSignaturesByType.get(nextType);\n  if (prevSignature === void 0 && nextSignature === void 0) {\n    return true;\n  }\n  if (prevSignature === void 0 || nextSignature === void 0) {\n    return false;\n  }\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n    return false;\n  }\n  if (nextSignature.forceReset) {\n    return false;\n  }\n  return true;\n}\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\nfunction canPreserveStateBetween(prevType, nextType) {\n  if (isReactClass(prevType) || isReactClass(nextType)) {\n    return false;\n  }\n  if (haveEqualSignatures(prevType, nextType)) {\n    return true;\n  }\n  return false;\n}\nfunction resolveFamily(type) {\n  return updatedFamiliesByType.get(type);\n}\nfunction getProperty(object, property) {\n  try {\n    return object[property];\n  } catch (err) {\n    return void 0;\n  }\n}\nfunction performReactRefresh() {\n  if (pendingUpdates.length === 0) {\n    return null;\n  }\n  if (isPerformingRefresh) {\n    return null;\n  }\n  isPerformingRefresh = true;\n  try {\n    const staleFamilies = /* @__PURE__ */ new Set();\n    const updatedFamilies = /* @__PURE__ */ new Set();\n    const updates = pendingUpdates;\n    pendingUpdates = [];\n    updates.forEach(([family, nextType]) => {\n      const prevType = family.current;\n      updatedFamiliesByType.set(prevType, family);\n      updatedFamiliesByType.set(nextType, family);\n      family.current = nextType;\n      if (canPreserveStateBetween(prevType, nextType)) {\n        updatedFamilies.add(family);\n      } else {\n        staleFamilies.add(family);\n      }\n    });\n    const update = {\n      updatedFamilies,\n      // Families that will re-render preserving state\n      staleFamilies\n      // Families that will be remounted\n    };\n    helpersByRendererID.forEach((helpers) => {\n      helpers.setRefreshHandler(resolveFamily);\n    });\n    let didError = false;\n    let firstError = null;\n    const failedRootsSnapshot = new Set(failedRoots);\n    const mountedRootsSnapshot = new Set(mountedRoots);\n    const helpersByRootSnapshot = new Map(helpersByRoot);\n    failedRootsSnapshot.forEach((root) => {\n      const helpers = helpersByRootSnapshot.get(root);\n      if (helpers === void 0) {\n        throw new Error(\n          \"Could not find helpers for a root. This is a bug in React Refresh.\"\n        );\n      }\n      if (!failedRoots.has(root)) {\n      }\n      if (rootElements === null) {\n        return;\n      }\n      if (!rootElements.has(root)) {\n        return;\n      }\n      const element = rootElements.get(root);\n      try {\n        helpers.scheduleRoot(root, element);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        }\n      }\n    });\n    mountedRootsSnapshot.forEach((root) => {\n      const helpers = helpersByRootSnapshot.get(root);\n      if (helpers === void 0) {\n        throw new Error(\n          \"Could not find helpers for a root. This is a bug in React Refresh.\"\n        );\n      }\n      if (!mountedRoots.has(root)) {\n      }\n      try {\n        helpers.scheduleRefresh(root, update);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        }\n      }\n    });\n    if (didError) {\n      throw firstError;\n    }\n    return update;\n  } finally {\n    isPerformingRefresh = false;\n  }\n}\nfunction register(type, id) {\n  if (type === null) {\n    return;\n  }\n  if (typeof type !== \"function\" && typeof type !== \"object\") {\n    return;\n  }\n  if (allFamiliesByType.has(type)) {\n    return;\n  }\n  let family = allFamiliesByID.get(id);\n  if (family === void 0) {\n    family = { current: type };\n    allFamiliesByID.set(id, family);\n  } else {\n    pendingUpdates.push([family, type]);\n  }\n  allFamiliesByType.set(type, family);\n  if (typeof type === \"object\" && type !== null) {\n    switch (getProperty(type, \"$$typeof\")) {\n      case REACT_FORWARD_REF_TYPE:\n        register(type.render, id + \"$render\");\n        break;\n      case REACT_MEMO_TYPE:\n        register(type.type, id + \"$type\");\n        break;\n    }\n  }\n}\nfunction setSignature(type, key, forceReset, getCustomHooks) {\n  if (!allSignaturesByType.has(type)) {\n    allSignaturesByType.set(type, {\n      forceReset,\n      ownKey: key,\n      fullKey: null,\n      getCustomHooks: getCustomHooks || (() => [])\n    });\n  }\n  if (typeof type === \"object\" && type !== null) {\n    switch (getProperty(type, \"$$typeof\")) {\n      case REACT_FORWARD_REF_TYPE:\n        setSignature(type.render, key, forceReset, getCustomHooks);\n        break;\n      case REACT_MEMO_TYPE:\n        setSignature(type.type, key, forceReset, getCustomHooks);\n        break;\n    }\n  }\n}\nfunction collectCustomHooksForSignature(type) {\n  const signature = allSignaturesByType.get(type);\n  if (signature !== void 0) {\n    computeFullKey(signature);\n  }\n}\nfunction injectIntoGlobalHook(globalObject) {\n  let hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook === void 0) {\n    let nextID = 0;\n    globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n      renderers: /* @__PURE__ */ new Map(),\n      supportsFiber: true,\n      inject: (injected) => nextID++,\n      onScheduleFiberRoot: (id, root, children) => {\n      },\n      onCommitFiberRoot: (id, root, maybePriorityLevel, didError) => {\n      },\n      onCommitFiberUnmount() {\n      }\n    };\n  }\n  if (hook.isDisabled) {\n    console[\"warn\"](\n      \"Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). Fast Refresh is not compatible with this shim and will be disabled.\"\n    );\n    return;\n  }\n  const oldInject = hook.inject;\n  hook.inject = function(injected) {\n    const id = oldInject.apply(this, arguments);\n    if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n      helpersByRendererID.set(id, injected);\n    }\n    return id;\n  };\n  hook.renderers.forEach((injected, id) => {\n    if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n      helpersByRendererID.set(id, injected);\n    }\n  });\n  const oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n  const oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || (() => {\n  });\n  hook.onScheduleFiberRoot = function(id, root, children) {\n    if (!isPerformingRefresh) {\n      failedRoots.delete(root);\n      if (rootElements !== null) {\n        rootElements.set(root, children);\n      }\n    }\n    return oldOnScheduleFiberRoot.apply(this, arguments);\n  };\n  hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {\n    const helpers = helpersByRendererID.get(id);\n    if (helpers !== void 0) {\n      helpersByRoot.set(root, helpers);\n      const current = root.current;\n      const alternate = current.alternate;\n      if (alternate !== null) {\n        const wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n        const isMounted = current.memoizedState != null && current.memoizedState.element != null;\n        if (!wasMounted && isMounted) {\n          mountedRoots.add(root);\n          failedRoots.delete(root);\n        } else if (wasMounted && isMounted) {\n        } else if (wasMounted && !isMounted) {\n          mountedRoots.delete(root);\n          if (didError) {\n            failedRoots.add(root);\n          } else {\n            helpersByRoot.delete(root);\n          }\n        } else if (!wasMounted && !isMounted) {\n          if (didError) {\n            failedRoots.add(root);\n          }\n        }\n      } else {\n        mountedRoots.add(root);\n      }\n    }\n    return oldOnCommitFiberRoot.apply(this, arguments);\n  };\n}\nfunction createSignatureFunctionForTransform() {\n  let savedType;\n  let hasCustomHooks;\n  let didCollectHooks = false;\n  return function(type, key, forceReset, getCustomHooks) {\n    if (typeof key === \"string\") {\n      if (!savedType) {\n        savedType = type;\n        hasCustomHooks = typeof getCustomHooks === \"function\";\n      }\n      if (type != null && (typeof type === \"function\" || typeof type === \"object\")) {\n        setSignature(type, key, forceReset, getCustomHooks);\n      }\n      return type;\n    } else {\n      if (!didCollectHooks && hasCustomHooks) {\n        didCollectHooks = true;\n        collectCustomHooksForSignature(savedType);\n      }\n    }\n  };\n}\nfunction isLikelyComponentType(type) {\n  switch (typeof type) {\n    case \"function\": {\n      if (type.prototype != null) {\n        if (type.prototype.isReactComponent) {\n          return true;\n        }\n        const ownNames = Object.getOwnPropertyNames(type.prototype);\n        if (ownNames.length > 1 || ownNames[0] !== \"constructor\") {\n          return false;\n        }\n        if (type.prototype.__proto__ !== Object.prototype) {\n          return false;\n        }\n      }\n      const name = type.name || type.displayName;\n      return typeof name === \"string\" && /^[A-Z]/.test(name);\n    }\n    case \"object\": {\n      if (type != null) {\n        switch (getProperty(type, \"$$typeof\")) {\n          case REACT_FORWARD_REF_TYPE:\n          case REACT_MEMO_TYPE:\n            return true;\n          default:\n            return false;\n        }\n      }\n      return false;\n    }\n    default: {\n      return false;\n    }\n  }\n}\nif (window.$RefreshReg$) {\n  throw new Error(\n    \"React refresh runtime was loaded twice. Maybe you forgot the base path?\"\n  );\n}\nfunction getRefreshReg(filename) {\n  return (type, id) => register(type, filename + \" \" + id);\n}\nfunction registerExportsForReactRefresh(filename, moduleExports) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const exportValue = moduleExports[key];\n    if (isLikelyComponentType(exportValue)) {\n      register(exportValue, filename + \" export \" + key);\n    }\n  }\n}\nfunction debounce(fn, delay) {\n  let handle;\n  return () => {\n    clearTimeout(handle);\n    handle = setTimeout(fn, delay);\n  };\n}\nconst enqueueUpdate = debounce(performReactRefresh, 16);\nfunction validateRefreshBoundaryAndEnqueueUpdate(prevExports, nextExports) {\n  if (!predicateOnExport(prevExports, (key) => key in nextExports)) {\n    return \"Could not Fast Refresh (export removed)\";\n  }\n  if (!predicateOnExport(nextExports, (key) => key in prevExports)) {\n    return \"Could not Fast Refresh (new export)\";\n  }\n  let hasExports = false;\n  const allExportsAreComponentsOrUnchanged = predicateOnExport(\n    nextExports,\n    (key, value) => {\n      hasExports = true;\n      if (isLikelyComponentType(value))\n        return true;\n      return prevExports[key] === nextExports[key];\n    }\n  );\n  if (hasExports && allExportsAreComponentsOrUnchanged) {\n    enqueueUpdate();\n  } else {\n    return \"Could not Fast Refresh. Learn more at https://github.com/vitejs/vite-plugin-react-swc#consistent-components-exports\";\n  }\n}\nfunction predicateOnExport(moduleExports, predicate) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n    if (desc && desc.get)\n      return false;\n    if (!predicate(key, moduleExports[key]))\n      return false;\n  }\n  return true;\n}\nconst __hmr_import = (module) => import(\n  /* @vite-ignore */\n  __vite__injectQuery(module, 'import'));\nvar refresh_runtime_default = { injectIntoGlobalHook };\nexport {\n  __hmr_import,\n  createSignatureFunctionForTransform,\n  refresh_runtime_default as default,\n  getRefreshReg,\n  injectIntoGlobalHook,\n  registerExportsForReactRefresh,\n  validateRefreshBoundaryAndEnqueueUpdate\n};\n",
      "start": 1701867791856,
      "end": 1701867791859,
      "order": "normal",
      "sourcemaps": null
    }
  ]
}
